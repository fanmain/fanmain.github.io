[{"categories":null,"content":"2024/10 换电脑 更新hugo新版本后 hugo --environment _stack server -D ERROR Error: external resource 'Vibrant' is not found ERROR Error: external resource 'PhotoSwipe' is not found ERROR Error: external resource 'KaTeX' is not found 问题是新版本Hugo和旧版本主题不兼容 升级之后解决 git pull \u0026\u0026 git submodule update --init --recursive","date":"2024-10-11","objectID":"/post/site/hugo_issus/:0:0","tags":null,"title":"Hugo_issus","uri":"/post/site/hugo_issus/"},{"categories":null,"content":"项目中使用Getx 遇到的问题 1.简单状态管理下 #view #widget class DropMenuWidget extends StatefulWidget { ... final String? selectedValue; //默认选中的值 } GetBuilder(builder: (_){ return DropMenuWidget(data: ..., selectCallBack: ..., selectedValue: logic.state.cmdType.toString(), ); }) #logic update();//不刷新对应GetBuilder #修改view GetBuilder(id:0x01,builder: (_){ return DropMenuWidget(data: ..., selectCallBack: ..., selectedValue: logic.state.cmdType.toString(), ); }) update([0x01]);//刷新对应GetBuilder 但是DropMenuWidget未能刷新 #最终修改 #将第三方widget构造加入 key: Key(\"${state.cmdType}\"), GetBuilder(id:0x01,builder: (_){ return DropMenuWidget(key:Key('...'),data: ..., selectCallBack: ..., selectedValue: logic.state.cmdType.toString(), ); }) update([0x01]); //问题解决","date":"2024-07-31","objectID":"/post/ios/2024/07_getx_issues/:0:1","tags":null,"title":"07_Getx_issues","uri":"/post/ios/2024/07_getx_issues/"},{"categories":null,"content":"flutter 升级 3.22.1 记录 ","date":"2024-07-02","objectID":"/post/ios/2024/06_flutter_issues/:0:0","tags":null,"title":"06_flutter_issues","uri":"/post/ios/2024/06_flutter_issues/"},{"categories":null,"content":"dependencies 升级报错修复 ","date":"2024-07-02","objectID":"/post/ios/2024/06_flutter_issues/:0:1","tags":null,"title":"06_flutter_issues","uri":"/post/ios/2024/06_flutter_issues/"},{"categories":null,"content":"flutter attach 无法连接 尝试： 首先怀疑防火墙问题,开关防火墙 =\u003e 无效 手机重启 =\u003e 无效 调试 flutter attach -v # 检索服务 dns-sd -Z _dartobservatory._tcp # 手动attach flutter attach --debug-uri=\"http://127.0.0.1:53168/HC5AIqfdvCQ\\=/\" -v # 提示iproxy文件安全权限，在mac安全和隐私中允许 # 在防火墙中将dart flutter iproxy 相关的文件加入 info.plist 加入mdns dart服务名 _dartVmService._tcp 参考 官方issue Flutter多引擎无法Attach问题分析及热重载卡死问题处理 解决方法 ","date":"2024-07-02","objectID":"/post/ios/2024/06_flutter_issues/:0:2","tags":null,"title":"06_flutter_issues","uri":"/post/ios/2024/06_flutter_issues/"},{"categories":null,"content":"2024 音视频学习目录 kcp 协议初步了解 ","date":"2024-06-24","objectID":"/post/media/2024/:0:0","tags":null,"title":"2024","uri":"/post/media/2024/"},{"categories":null,"content":"cocoapods 升级记录 1.12.1 =\u003e 1.14.0 ➜ ~ gem list --local | grep cocoapods cocoapods (1.12.1) cocoapods-core (1.12.1) cocoapods-deintegrate (1.0.5) cocoapods-downloader (1.6.3) cocoapods-plugins (1.0.0) cocoapods-search (1.0.1) cocoapods-trunk (1.6.0) cocoapods-try (1.2.0) ➜ ~ sudo gem install cocoapods -v 1.14.0 Password: Fetching cocoapods-1.14.0.gem Fetching xcodeproj-1.24.0.gem Fetching concurrent-ruby-1.3.3.gem Fetching cocoapods-core-1.14.0.gem Fetching cocoapods-downloader-2.1.gem Successfully installed xcodeproj-1.24.0 Successfully installed cocoapods-downloader-2.1 Successfully installed concurrent-ruby-1.3.3 Successfully installed cocoapods-core-1.14.0 Successfully installed cocoapods-1.14.0 Parsing documentation for xcodeproj-1.24.0 Installing ri documentation for xcodeproj-1.24.0 Parsing documentation for cocoapods-downloader-2.1 Installing ri documentation for cocoapods-downloader-2.1 Parsing documentation for concurrent-ruby-1.3.3 Installing ri documentation for concurrent-ruby-1.3.3 Parsing documentation for cocoapods-core-1.14.0 Installing ri documentation for cocoapods-core-1.14.0 Parsing documentation for cocoapods-1.14.0 Installing ri documentation for cocoapods-1.14.0 Done installing documentation for xcodeproj, cocoapods-downloader, concurrent-ruby, cocoapods-core, cocoapods after 3 seconds 5 gems installed ➜ ~ gem list --local | grep cocoapods cocoapods (1.14.0, 1.12.1) cocoapods-core (1.14.0, 1.12.1) cocoapods-deintegrate (1.0.5) cocoapods-downloader (2.1, 1.6.3) cocoapods-plugins (1.0.0) cocoapods-search (1.0.1) cocoapods-trunk (1.6.0) cocoapods-try (1.2.0) ➜ ~ sudo gem uninstall cocoapods 1.12.1 Gem '1.12.1' is not installed Select gem to uninstall: 1. cocoapods-1.12.1 2. cocoapods-1.14.0 3. All versions \u003e 1 Successfully uninstalled cocoapods-1.12.1 ➜ ~ gem list --local | grep cocoapods cocoapods (1.14.0) cocoapods-core (1.14.0, 1.12.1) cocoapods-deintegrate (1.0.5) cocoapods-downloader (2.1, 1.6.3) cocoapods-plugins (1.0.0) cocoapods-search (1.0.1) cocoapods-trunk (1.6.0) cocoapods-try (1.2.0) ➜ ~ sudo gem uninstall cocoapods-core Select gem to uninstall: 1. cocoapods-core-1.12.1 2. cocoapods-core-1.14.0 3. All versions \u003e 1 Successfully uninstalled cocoapods-core-1.12.1 ➜ ~ sudo gem uninstall cocoapods-downloader Select gem to uninstall: 1. cocoapods-downloader-1.6.3 2. cocoapods-downloader-2.1 3. All versions \u003e 1 Successfully uninstalled cocoapods-downloader-1.6.3","date":"2024-06-14","objectID":"/post/ios/2024/05_cocoapods/:0:0","tags":null,"title":"05_cocoapods","uri":"/post/ios/2024/05_cocoapods/"},{"categories":null,"content":"前言 最近不想折腾贝壳云了 想着把openwrt的Pa*w**l改到群晖docker 上去 ","date":"2024-05-25","objectID":"/post/nas/2024/dsm_docker_openwrt/:0:1","tags":null,"title":"Dsm_docker_openwrt","uri":"/post/nas/2024/dsm_docker_openwrt/"},{"categories":null,"content":"1.设置docker网卡 #获取root权限 sudo -i #设置混杂模式 ifconfig eth0 promisc # 禁用混杂模式 ifconfig eth0 \\-promisc创建 macvlan 网络 docker network create -d macvlan \\ --subnet=192.168.2.0/24 \\ --gateway=192.168.2.1 \\ -o parent=eth0 \\ macnet 查看加入 docker network ls生成配置 # 新建文件夹 openwrt 和 子目录 mkdir \\-p /volume1/docker/openwrt/data/lock \\ # 进入 openwrt 目录 cd /volume1/docker/openwrt \\ # 创建 network.conf 文件 touch network.conf \\ # 编辑 network.conf 文件 vi network.conf编辑配置 config interface 'loopback' option ifname 'lo' option proto 'static' option ipaddr '127.0.0.1' option netmask '255.0.0.0' config globals 'globals' option packet_steering '1' config interface 'lan' option ifname 'eth0' option proto 'static' option netmask '255.255.255.0' option ip6assign '60' option ipaddr '192.168.2.3' option gateway '192.168.2.1' option dns '8.8.8.8 114.114.114.114'启动容器 docker run -d –restart always –name openwrt –network macnet –privileged –ip 192.168.2.3 -v $(pwd)/network.conf:/etc/config/network -v $(pwd)/data:/var kiddin9_openwrt /sbin/init ","date":"2024-05-25","objectID":"/post/nas/2024/dsm_docker_openwrt/:0:2","tags":null,"title":"Dsm_docker_openwrt","uri":"/post/nas/2024/dsm_docker_openwrt/"},{"categories":null,"content":" 京喜APP最早在2019年引入了Swift，使用Swift完成了第一个订单模块的开发。之后一年多我们持续在团队/公司内部推广和普及Swift，目前Swift已经支撑了70%+以上的业务。通过使用Swift提高了团队内同学的开发效率，同时也带来了质量的提升，目前来自Swift的Crash的占比不到1%。在这过程中不断的学习/实践，团队内的Code Review，也对如何使用Swift来提高代码质量有更深的理解。 前言 京喜APP最早在2019年引入了Swift，使用Swift完成了第一个订单模块的开发。之后一年多我们持续在团队/公司内部推广和普及Swift，目前Swift已经支撑了70%+以上的业务。通过使用Swift提高了团队内同学的开发效率，同时也带来了质量的提升，目前来自Swift的Crash的占比不到1%。在这过程中不断的学习/实践，团队内的Code Review，也对如何使用Swift来提高代码质量有更深的理解。 Swift特性 在讨论如何使用Swift提高代码质量之前，我们先来看看Swift本身相比ObjC或其他编程语言有什么优势。Swift有三个重要的特性分别是富有表现力/安全性/快速，接下来我们分别从这三个特性简单介绍一下： ","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:0:0","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"富有表现力 Swift提供更多的编程范式和特性支持，可以编写更少的代码，而且易于阅读和维护。 基础类型 - 元组、Enum关联类型 方法 - 方法重载 protocol - 不限制只支持class、协议默认实现、类专属协议 泛型 - protocol关联类型、where实现类型约束、泛型扩展 可选值 - 可选值申明、可选链、隐式可选值 属性 - let、lazy、计算属性`、willset/didset、Property Wrappers 函数式编程 - 集合filter/map/reduce方法，提供更多标准库方法 并发 - async/await、actor 标准库框架 - Combine响应式框架、SwiftUI申明式UI框架、CodableJSON模型转换 Result builder - 描述实现DSL的能力 动态性 - dynamicCallable、dynamicMemberLookup 其他 - 扩展、subscript、操作符重写、嵌套类型、区间 Swift Package Manager - 基于Swift的包管理工具，可以直接用Xcode进行管理更方便 struct - 初始化方法自动补齐 类型推断 - 通过编译器强大的类型推断编写代码时可以减少很多类型申明 提示：类型推断同时也会增加一定的编译耗时，不过Swift团队也在不断的改善编译速度。 ","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:0:1","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"安全性 代码安全 let属性 - 使用let申明常量避免被修改。 值类型 - 值类型可以避免在方法调用等参数传递过程中状态被修改。 访问控制 - 通过public和final限制模块外使用class不能被继承和重写。 强制异常处理 - 方法需要抛出异常时，需要申明为throw方法。当调用可能会throw异常的方法，需要强制捕获异常避免将异常暴露到上层。 模式匹配 - 通过模式匹配检测switch中未处理的case。 类型安全 强制类型转换 - 禁止隐式类型转换避免转换中带来的异常问题。同时类型转换不会带来额外的运行时消耗。。 提示：编写ObjC代码时，我们通常会在编码时添加类型检查避免运行时崩溃导致Crash。 KeyPath - KeyPath相比使用字符串可以提供属性名和类型信息，可以利用编译器检查。 泛型 - 提供泛型和协议关联类型，可以编写出类型安全的代码。相比Any可以更多利用编译时检查发现类型问题。 Enum关联类型 - 通过给特定枚举指定类型避免使用Any。 内存安全 空安全 - 通过标识可选值避免空指针带来的异常问题 ARC - 使用自动内存管理避免手动管理内存带来的各种内存问题 强制初始化 - 变量使用前必须初始化 内存独占访问 - 通过编译器检查发现潜在的内存冲突问题 线程安全 值类型 - 更多使用值类型减少在多线程中遇到的数据竞争问题 async/await - 提供async函数使我们可以用结构化的方式编写并发操作。避免基于闭包的异步方式带来的内存循环引用和无法抛出异常的问题 Actor - 提供Actor模型避免多线程开发中进行数据共享时发生的数据竞争问题，同时避免在使用锁时带来的死锁等问题 ","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:0:2","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"快速 值类型 - 相比class不需要额外的堆内存分配/释放和更少的内存消耗 方法静态派发 - 方法调用支持静态调用相比原有ObjC消息转发调用性能更好 编译器优化 - Swift的静态性可以使编译器做更多优化。例如Tree Shaking相关优化移除未使用的类型/方法等减少二进制文件大小。使用静态派发/方法内联优化/泛型特化/写时复制等优化提高运行时性能 提示：ObjC消息派发会导致编译器无法进行移除无用方法/类的优化，编译器并不知道是否可能被用到。 ARC优化 - 虽然和ObjC一样都是使用ARC，Swift通过编译器优化，可以进行更快的内存回收和更少的内存引用计数管理 提示： 相比ObjC，Swift内部不需要使用autorelease进行管理。 代码质量指标 以上是一些常见的代码质量指标。我们的目标是如何更好的使用Swift编写出符合代码质量指标要求的代码。 提示：本文不涉及设计模式/架构，更多关注如何通过合理使用Swift特性做局部代码段的重构。 ","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:0:3","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"一些不错的实践 ","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:0","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"利用编译检查 减少使用Any/AnyObject 因为Any/AnyObject缺少明确的类型信息，编译器无法进行类型检查，会带来一些问题： 编译器无法检查类型是否正确保证类型安全 代码中大量的as?转换 类型的缺失导致编译器无法做一些潜在的编译优化 使用as?带来的问题 当使用Any/AnyObject时会频繁使用as?进行类型转换。这好像没什么问题因为使用as?并不会导致程序Crash。不过代码错误至少应该分为两类，一类是程序本身的错误通常会引发Crash，另外一种是业务逻辑错误。使用as?只是避免了程序错误Crash，但是并不能防止业务逻辑错误。 func do(data: Any?) { guard let string = data as? String else { return } // } do(1) do(\"\")以上面的例子为例，我们进行了as?转换，当data为String时才会进行处理。但是当do方法内String类型发生了改变函数，使用方并不知道已变更没有做相应的适配，这时候就会造成业务逻辑的错误。 提示：这类错误通常更难发现，这也是我们在一次真实bug场景遇到的。 使用自定义类型代替Dictionary 代码中大量Dictionary数据结构会降低代码可维护性，同时带来潜在的bug： key需要字符串硬编码，编译时无法检查 value没有类型限制。修改时类型无法限制，读取时需要重复类型转换和解包操作 无法利用空安全特性，指定某个属性必须有值 提示：自定义类型还有个好处，例如JSON转自定义类型时会进行类型/nil/属性名检查，可以避免将错误数据丢到下一层。 不推荐 let dic: [String: Any] let num = dic[\"value\"] as? Int dic[\"name\"] = \"name\"推荐 struct Data { let num: Int var name: String? } let num = data.num data.name = \"name\"适合使用Dictionary的场景 数据不使用 - 数据并不读取只是用来传递。 解耦 - 1.组件间通信解耦使用HashMap传递参数进行通信。2.跨技术栈边界的场景，混合栈间通信/前后端通信使用HashMap/JSON进行通信。 使用枚举关联值代替Any 例如使用枚举改造NSAttributedStringAPI，原有APIvalue为Any类型无法限制特定的类型。 优化前 let string = NSMutableAttributedString() string.addAttribute(.foregroundColor, value: UIColor.red, range: range)改造后 enum NSAttributedStringKey { case foregroundColor(UIColor) } let string = NSMutableAttributedString() string.addAttribute(.foregroundColor(UIColor.red), range: range) // 不传递Color会报错使用泛型/协议关联类型代替Any 使用泛型或协议关联类型代替Any，通过泛型类型约束来使编译器进行更多的类型检查。 使用枚举/常量代替硬编码 代码中存在重复的硬编码字符串/数字，在修改时可能会因为不同步引发bug。尽可能减少硬编码字符串/数字，使用枚举或常量代替。 使用KeyPath代替字符串硬编码 KeyPath包含属性名和类型信息，可以避免硬编码字符串，同时当属性名或类型改变时编译器会进行检查。 不推荐 class SomeClass: NSObject { @objc dynamic var someProperty: Int init(someProperty: Int) { self.someProperty = someProperty } } let object = SomeClass(someProperty: 10) object.observeValue(forKeyPath: \"\", of: nil, change: nil, context: nil)推荐 let object = SomeClass(someProperty: 10) object.observe(.someProperty) { object, change in }","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:1","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"内存安全 减少使用!属性 !属性会在读取时隐式强解包，当值不存在时产生运行时异常导致Crash。 class ViewController: UIViewController { @IBOutlet private var label: UILabel! // @IBOutlet需要使用! }减少使用!进行强解包 使用!强解包会在值不存在时产生运行时异常导致Crash。 var num: Int? let num2 = num! // 错误 提示：建议只在小范围的局部代码段使用!强解包。 避免使用try!进行错误处理 使用try!会在方法抛出异常时产生运行时异常导致Crash。 try! method()使用weak/unowned避免循环引用 resource.request().onComplete { [weak self] response in guard let self = self else { return } let model = self.updateModel(response) self.updateUI(model) } resource.request().onComplete { [unowned self] response in let model = self.updateModel(response) self.updateUI(model) }减少使用unowned unowned在值不存在时会产生运行时异常导致Crash，只有在确定self一定会存在时才使用unowned。 class Class { @objc unowned var object: Object @objc weak var object: Object? }unowned/weak区别： weak - 必须设置为可选值，会进行弱引用处理性能更差。会自动设置为nil unowned - 可以不设置为可选值，不会进行弱引用处理性能更好。但是不会自动设置为nil, 如果self已释放会触发错误. ","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:2","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"错误处理方式 可选值 - 调用方并不关注内部可能会发生错误，当发生错误时返回nil try/catch - 明确提示调用方需要处理异常，需要实现Error协议定义明确的错误类型 assert - 断言。只能在Debug模式下生效 precondition - 和assert类似，可以再Debug/Release模式下生效 fatalError - 产生运行时崩溃会导致Crash，应避免使用 Result - 通常用于闭包异步回调返回值 ","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:3","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"减少使用可选值 可选值的价值在于通过明确标识值可能会为nil并且编译器强制对值进行nil判断。但是不应该随意的定义可选值，可选值不能用let定义，并且使用时必须进行解包操作相对比较繁琐。在代码设计时应考虑这个值是否有可能为nil，只在合适的场景使用可选值。 使用init注入代替可选值属性 不推荐 class Object { var num: Int? } let object = Object() object.num = 1推荐 class Object { let num: Int init(num: Int) { self.num = num } } let object = Object(num: 1)避免随意给予可选值默认值 在使用可选值时，通常我们需要在可选值为nil时进行异常处理。有时候我们会通过给予可选值默认值的方式来处理。但是这里应考虑在什么场景下可以给予默认值。在不能给予默认值的场景应当及时使用return或抛出异常，避免错误的值被传递到更多的业务流程。 不推荐 func confirmOrder(id: String) {} // 给予错误的值会导致错误的值被传递到更多的业务流程 confirmOrder(id: orderId ?? \"\")推荐 func confirmOrder(id: String) {} guard let orderId = orderId else { // 异常处理 return } confirmOrder(id: orderId) 提示：通常强业务相关的值不能给予默认值：例如商品/订单id或是价格。在可以使用兜底逻辑的场景使用默认值，例如默认文字/文字颜色。 使用枚举优化可选值 Object结构同时只会有一个值存在： 优化前 class Object { var name: Int? var num: Int? }优化后 降低内存占用 - 枚举关联类型的大小取决于最大的关联类型大小 逻辑更清晰 - 使用enum相比大量使用if/else逻辑更清晰 enum CustomType { case name(String) case num(Int) }","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:4","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"减少var属性 使用计算属性 使用计算属性可以减少多个变量同步带来的潜在bug。 不推荐 class model { var data: Object? var loaded: Bool } model.data = Object() loaded = false推荐 class model { var data: Object? var loaded: Bool { return data != nil } } model.data = Object() 提示：计算属性因为每次都会重复计算，所以计算过程需要轻量避免带来性能问题。 ","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:5","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"控制流 使用filter/reduce/map代替for循环 使用filter/reduce/map可以带来很多好处，包括更少的局部变量，减少模板代码，代码更加清晰，可读性更高。 不推荐 let nums = [1, 2, 3] var result = [] for num in nums { if num \u003c 3 { result.append(String(num)) } } // result = [\"1\", \"2\"]推荐 let nums = [1, 2, 3] let result = nums.filter { $0 \u003c 3 }.map { String($0) } // result = [\"1\", \"2\"]使用guard进行提前返回 推荐 guard !a else { return } guard !b else { return } // do不推荐 if a { if b { // do } }使用三元运算符?: 推荐 let b = true let a = b ? 1 : 2 let c: Int? let b = c ?? 1不推荐 var a: Int? if b { a = 1 } else { a = 2 }使用for where优化循环 for循环添加where语句，只有当where条件满足时才会进入循环 不推荐 for item in collection { if item.hasProperty { // ... } }推荐 for item in collection where item.hasProperty { // item.hasProperty == true，才会进入循环 }使用defer defer可以保证在函数退出前一定会执行。可以使用defer中实现退出时一定会执行的操作例如资源释放等避免遗漏。 func method() { lock.lock() defer { lock.unlock() // 会在method作用域结束的时候调用 } // do }","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:6","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"字符串 使用\"\"\" 在定义复杂字符串时，使用多行字符串字面量可以保持原有字符串的换行符号/引号等特殊字符，不需要使用``进行转义。 let quotation = \"\"\" The White Rabbit put on his spectacles. \"Where shall I begin, please your Majesty?\" he asked. \"Begin at the beginning,\" the King said gravely, \"and go on till you come to the end; then stop.\" \"\"\" 提示：上面字符串中的\"\"和换行可以自动保留。 使用字符串插值 使用字符串插值可以提高代码可读性。 不推荐 let multiplier = 3 let message = String(multiplier) + \"times 2.5 is\" + String((Double(multiplier) * 2.5))推荐 let multiplier = 3 let message = \"(multiplier) times 2.5 is (Double(multiplier) * 2.5)\"","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:7","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"集合 使用标准库提供的高阶函数 不推荐 var nums = [] nums.count == 0 nums[0]推荐 var nums = [] nums.isEmpty nums.first","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:8","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"访问控制 Swift中默认访问控制级别为internal。编码中应当尽可能减小属性/方法/类型的访问控制级别隐藏内部实现。 提示：同时也有利于编译器进行优化。 使用private/fileprivate修饰私有属性和方法 private let num = 1 class MyClass { private var num: Int }使用private(set)修饰外部只读/内部可读写属性 class MyClass { private(set) var num = 1 } let num = MyClass().num MyClass().num = 2 // 会编译报错","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:9","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"函数 使用参数默认值 使用参数默认值，可以使调用方传递更少的参数。 不推荐 func test(a: Int, b: String?, c: Int?) { } test(1, nil, nil)推荐 func test(a: Int, b: String? = nil, c: Int? = nil) { } test(1) 提示：相比ObjC，参数默认值也可以让我们定义更少的方法。 限制参数数量 当方法参数过多时考虑使用自定义类型代替。 不推荐 func f(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int) { }推荐 struct Params { let a, b, c, d, e, f: Int } func f(params: Params) { }使用@discardableResult 某些方法使用方并不一定会处理返回值，可以考虑添加@discardableResult标识提示Xcode允许不处理返回值不进行warning提示。 // 上报方法使用方不关心是否成功 func report(id: String) -\u003e Bool {} @discardableResult func report2(id: String) -\u003e Bool {} report(\"1\") // 编译器会警告 report2(\"1\") // 不处理返回值编译器不会警告","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:10","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"元组 避免过长的元组 元组虽然具有类型信息，但是并不包含变量名信息，使用方并不清晰知道变量的含义。所以当元组数量过多时考虑使用自定义类型代替。 func test() -\u003e (Int, Int, Int) { } let (a, b, c) = test() // a，b，c类型一致，没有命名信息不清楚每个变量的含义","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:11","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"系统库 KVO/Notification 使用 block API block API的优势： KVO 可以支持 KeyPath 不需要主动移除监听，observer释放时自动移除监听 不推荐 class Object: NSObject { init() { super.init() addObserver(self, forKeyPath: \"value\", options: .new, context: nil) NotificationCenter.default.addObserver(self, selector: #selector(test), name: NSNotification.Name(rawValue: \"\"), object: nil) } override class func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) { } @objc private func test() { } deinit { removeObserver(self, forKeyPath: \"value\") NotificationCenter.default.removeObserver(self) } }推荐 class Object: NSObject { private var observer: AnyObserver? private var kvoObserver: NSKeyValueObservation? init() { super.init() observer = NotificationCenter.default.addObserver(forName: NSNotification.Name(rawValue: \"\"), object: nil, queue: nil) { (_) in } kvoObserver = foo.observe(.value, options: [.new]) { (foo, change) in } } }","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:12","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"Protocol 使用protocol代替继承 Swift中针对protocol提供了很多新特性，例如默认实现，关联类型，支持值类型。在代码设计时可以优先考虑使用protocol来避免臃肿的父类同时更多使用值类型。 提示：一些无法用protocol替代继承的场景：1.需要继承NSObject子类。2.需要调用super方法。3.实现抽象类的能力。 ","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:13","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"Extension 使用extension组织代码 使用extension将私有方法/父类方法/协议方法等不同功能代码进行分离更加清晰/易维护。 class MyViewController: UIViewController { // class stuff here } // MARK: - Private extension: MyViewController { private func method() {} } // MARK: - UITableViewDataSource extension MyViewController: UITableViewDataSource { // table view data source methods } // MARK: - UIScrollViewDelegate extension MyViewController: UIScrollViewDelegate { // scroll view delegate methods }","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:14","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"代码风格 良好的代码风格可以提高代码的可读性，统一的代码风格可以降低团队内相互理解成本。对于Swift的代码格式化建议使用自动格式化工具实现，将自动格式化添加到代码提交流程，通过定义Lint规则统一团队内代码风格。考虑使用SwiftFormat和SwiftLint。 提示：SwiftFormat主要关注代码样式的格式化，SwiftLint可以使用autocorrect自动修复部分不规范的代码。 常见的自动格式化修正 移除多余的; 最多只保留一行换行 自动对齐空格 限制每行的宽度自动换行 ","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:1:15","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"性能优化 性能优化上主要关注提高运行时性能和降低二进制体积。需要考虑如何更好的使用Swift特性，同时提供更多信息给编译器进行优化。 ","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:2:0","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"使用Whole Module Optimization 当Xcode开启WMO优化时，编译器可以将整个程序编译为一个文件进行更多的优化。例如通过推断final/函数内联/泛型特化更多使用静态派发，并且可以移除部分未使用的代码。 ","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:2:1","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"使用源代码打包 当我们使用组件化时，为了提高编译速度和打包效率，通常单个组件独立编译生成静态库，最后多个组件直接使用静态库进行打包。这种场景下WMO仅针对internal以内作用域生效，对于public/open缺少外部使用信息所以无法进行优化。所以对于大量使用Swift的项目，使用全量代码打包更有利于编译器做更多优化。 ","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:2:2","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"减少方法动态派发 使用final - class/方法/属性申明为final，编译器可以优化为静态派发 使用private - 方法/属性申明为private，编译器可以优化为静态派发 避免使用dynamic - dynamic会使方法通过ObjC消息转发的方式派发 使用WMO - 编译器可以自动分析推断出final优化为静态派发 ","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:2:3","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"使用Slice共享内存优化性能 在使用Array/String时，可以使用Slice切片获取一部分数据。Slice保存对原始Array/String的引用共享内存数据，不需要重新分配空间进行存储。 let midpoint = absences.count / 2 let firstHalf = absences[..`提示：应避免一直持有Slice，Slice会延长原始Array/String的生命周期导致无法被释放造成内存泄漏。 protocol添加AnyObject protocol AnyProtocol {} protocol ObjectProtocol: AnyObject {} 当protocol仅限制为class使用时，继承AnyObject协议可以使编译器不需要考虑值类型实现，提高运行时性能。 使用@inlinable进行方法内联优化 // 原始代码 let label = UILabel().then { 0.textAlignment=.center0.textColor = UIColor.black $0.text = “Hello, World!” } 以then库为例，他使用闭包进行对象初始化以后的相关设置。但是 then 方法以及闭包也会带来额外的性能消耗。 内联优化 @inlinable public func then(_ block: (Self) throws -\u003e Void) rethrows -\u003e Self { try block(self) return self } // 编译器内联优化后 let label = UILabel() label.textAlignment = .center label.textColor = UIColor.black label.text = “Hello, World!” 属性 使用lazy延时初始化属性 class View { var lazy label: UILabel = { let label = UILabel() self.addSubView(label) return label }() } lazy属性初始化会延迟到第一次使用时，常见的使用场景： 初始化比较耗时 可能不会被使用到 初始化过程需要使用self 提示：lazy属性不能保证线程安全 避免使用private let属性 private let属性会增加每个class对象的内存大小。同时会增加包大小，因为需要为属性生成相关的信息。可以考虑使用文件级private let申明或static常量代替。 不推荐 class Object { private let title = “12345” } 推荐 private let title = “12345” class Object { static let title = \"\" } 提示：这里并不包括通过init初始化注入的属性。 使用didSet/willSet时进行Diff 某些场景需要使用didSet/willSet属性检查器监控属性变化，做一些额外的计算。但是由于didSet/willSet并不会检查新/旧值是否相同，可以考虑添加新/旧值判断，只有当值真的改变时才进行运算提高性能。 优化前 class Object { var orderId: String? { didSet { // 拉取接口等操作 } } } 例如上面的例子，当每一次orderId变更时需要重新拉取当前订单的数据，但是当orderId值一样时，拉取订单数据是无效执行。 优化后 class Object { var orderId: String? { didSet { // 判断新旧值是否相等 guard oldValue != orderId else { return } // 拉取接口等操作 } } } 集合 集合使用lazy延迟序列 var nums = [1, 2, 3] var result = nums.lazy.map { String($0) } result[0] // 对1进行map操作 result[1] // 对2进行map操作 在集合操作时使用lazy，可以将数组运算操作推迟到第一次使用时，避免一次性全部计算。 提示：例如长列表，我们需要创建每个cell对应的视图模型，一次性创建太耗费时间。 使用合适的集合方法优化性能 不推荐 var items = [1, 2, 3] items.filter({ $0 \u003e 1 }).first // 查找出所有大于1的元素，之后找出第一个 推荐 var items = [1, 2, 3] items.first(where: { $0 \u003e 1 }) // 查找出第一个大于1的元素直接返回 使用值类型 Swift中的值类型主要是结构体/枚举/元组。 启动性能 - APP启动时值类型没有额外的消耗，class有一定额外的消耗。 运行时性能- 值类型不需要在堆上分配空间/额外的引用计数管理。更少的内存占用和更快的性能。 包大小 - 相比class，值类型不需要创建ObjC类对应的ro_data_t数据结构。 提示：class即使没有继承NSObject也会生成ro_data_t，里面包含了ivars属性信息。如果属性/方法申明为@objc还会生成对应的方法列表。 提示：struct无法代替class的一些场景：1.需要使用继承调用super。2.需要使用引用类型。3.需要使用deinit。4.需要在运行时动态转换一个实例的类型。 提示：不是所有struct都会保存在栈上，部分数据大的struct也会保存在堆上。 集合元素使用值类型 集合元素使用值类型。因为NSArray并不支持值类型，编译器不需要处理可能需要桥接到NSArray的场景，可以移除部分消耗。 纯静态类型避免使用class 当class只包含静态方法/属性时，考虑使用enum代替class，因为class会生成更多的二进制代码。 不推荐 class Object { static var num: Int static func test() {} } 推荐 enum Object { static var num: Int static func test() {} } 提示：为什么用enum而不是struct，因为struct会额外生成init方法。 值类型性能优化 考虑使用引用类型 值类型为了维持值语义，会在每次赋值/参数传递/修改时进行复制。虽然编译器本身会做一些优化，例如写时复制优化，在修改时减少复制频率，但是这仅针对于标准库提供的集合和String结构有效，对于自定义结构需要自己实现。对于参数传递编译器在一些场景会优化为直接传递引用的方式避免复制行为。 但是对于一些数据特别大的结构，同时需要频繁变更修改时也可以考虑使用引用类型实现。 使用inout传递参数减少复制 虽然编译器本身会进行写时复制的优化，但是部分场景编译器无法处理。 不推荐 func append_one(_ a: [Int]) -\u003e [Int] { var a = a a.append(1) // 无法被编译器优化，因为这时候有2个引用持有数组 return a } var a = [1, 2, 3] a = append_one(a) 推荐 直接使用inout传递参数 func append_one_in_place(a: inout [Int]) { a.append(1) } var a = [1, 2, 3] append_one_in_place(\u0026a) 使用isKnownUniquelyReferenced实现写时复制 默认情况下结构体中包含引用类型，在修改时只会重新拷贝引用。但是我们希望CustomData具备值类型的特性，所以当修改时需要重新复制NSMutableData避免复用。但是复制操作本身是耗时操作，我们希望可以减少一些不必要的复制。 优化前 struct CustomData { fileprivate var _data: NSMutableData var _dataForWriting: NSMutableData { mutating get { _data = _data.mutableCopy() as! NSMutableData return data } } init( data: NSData) { self._data = data.mutableCopy() as! NSMutableData } mutating func append(_ other: MyData) { _dataForWriting.append(other._data as Data) }} var buffer = CustomData(NSData()) for _ in 0..\u003c5 { buffer.append(x) // 每一次调用都会复制 } 优化后 使用isKnownUniquelyReferenced检查如果是唯一引用不进行复制。 final class Box { var unbox: A init(_ value: A) { self.unbox = value } } struct CustomData { fileprivate var _data: Box var _dataForWriting: NSMutableData { mutating get { // 检查引用是否唯一 if !isKnown","date":"2024-05-16","objectID":"/post/ios/2024/04_swifttip/:2:4","tags":null,"title":"04_swiftTip","uri":"/post/ios/2024/04_swifttip/"},{"categories":null,"content":"UnityShader数学基础篇 ","date":"2024-05-16","objectID":"/post/unity/2022/01_unity_math/:0:0","tags":null,"title":"01_unity_math","uri":"/post/unity/2022/01_unity_math/"},{"categories":null,"content":"Mathf Mathf和Math 1、Math是C#中封装好的用于数学计算的工具类，位于System命名空间中。 2、Mathf是Unity中封装好的用于数学计算的工具结构体，位于UnityEngine命名空间中。 Mathf中的常用方法 1.π - PI print(Mathf.PI); 2.取绝对值 - Abs print(Mathf.Abs(-10.5f));//10.5 print(Mathf.Abs(-86));//863.向上取整 - CeilToInt print(Mathf.CeilToInt(1.001f));//2 print(Mathf.CeilToInt(5.6f));//64.向下取整 - FloorToInt print(Mathf.FloorToInt(2.999f));//2 print(Mathf.FloorToInt(1.04f));//15.钳制函数 - Clamp (传入的数据 ，数据传出最小值 ，数据传出最大值) int num = 18； print(Mathf.Clamp(num, 13, 32));//13 print(Mathf.Clamp(num, 13, 32));//32 print(Mathf.Clamp(num, 13, 32));//186.获取最大值 - Max int[] ints = new int[5] {5,9,78,65,23}; print(Mathf.Max(1, 5, 6, 8, 9, 45));//45 print(Mathf.Max(ints));//787.获取最小值 - Min int[] ints2 = new int[5] {-1,5,86,411,20}; print(Mathf.Min(ints2));//-1 print(Mathf.Min(1.2f,5,65,0.86f));//0.868.一个数的n次幂 - Pow print(\"2的6次方\" + Mathf.Pow(2, 6));//64 print(\"3的4次方\" + Mathf.Pow(3, 4));//819.四舍五入 - RoundToInt print(\"四舍五入\" + Mathf.RoundToInt(4.6f));//5 print(\"四舍五入\" + Mathf.RoundToInt(4.3f));//410.返回一个数的平方根 - Sqrt print(\"平方根\" + Mathf.Sqrt(4));//2 print(\"平方根\" + Mathf.Sqrt(9));//311.判断一个数是否是2的n次方 - IsPowerOfTwo print(\"11:\" + Mathf.IsPowerOfTwo(8));//ture print(\"11:\" + Mathf.IsPowerOfTwo(9));//false12.判断正负数 - Sign print(\"判断正负数\" + Mathf.Sign(1));//1 print(\"判断正负数\" + Mathf.Sign(-2));//-113.插值运算 - Lerp 1、Lerp函数公式：result = Mathf.Lerp(start, end, t); 2、t为插值系数,取值范围为0~1：result = start + (end - start)*t float start = 0; float result = 0; float time = 0; void Update() { //插值运算用法一 //每帧改变start的值一变化速度先快后慢,位置无限接近,但是不会得到end位置 start = Mathf.Lerp(start,10,Time.deltaTime); //插值运算用法二 //每帧改变t的值一变化速度匀速,位置每帧result接近end,当t\u003e=1时,得到结果 time += Time.deltaTime; result = Mathf.Lerp(start,10,time); } ","date":"2024-05-16","objectID":"/post/unity/2022/01_unity_math/:0:1","tags":null,"title":"01_unity_math","uri":"/post/unity/2022/01_unity_math/"},{"categories":null,"content":"三角函数 Unity中都是弧度值，让物体曲线移动。 弧度(radian)、角度相互转化 1、1 rad = (180/π)°=\u003e 1 rad = (180/3.14)°= 57.3° 2、弧度转角度：弧度 * 57.3 = 对应的角度 3、Mathf.Rad2Deg float rad = 1; float anger = rad * Mathf.Rad2Deg; print(anger);//57.3 1、1°= (π/180)rad =\u003e 1°= (3.14/180)rad = 0.01745 rad 2、角度转弧度：角度 * 0.01745 = 对应的弧度 3、Mathf.Deg2Rad anger = 1; rad = anger * Mathf.Deg2Rad; print(rad);//0.01745三角函数 **注意:**Mathf中的三角函数相关函数,传入的参数需要弧度值 Sin() Cos() print(Mathf.Sin(30 * Mathf.Deg2Rad));//1/2 print(Mathf.Cos(30 * Mathf.Deg2Rad));//sqrt3/2 print(Mathf.Sin(30f));//1/2反三角函数 **注意:**反三角函数得到的结果是正弦或者余弦值对应的弧度值 Asin() Acos() print(Mathf.Asin(0.5f) * Mathf.Rad2Deg);//30 print(Mathf.Acos(0.5f) * Mathf.Rad2Deg);//60 ","date":"2024-05-16","objectID":"/post/unity/2022/01_unity_math/:0:2","tags":null,"title":"01_unity_math","uri":"/post/unity/2022/01_unity_math/"},{"categories":null,"content":"Unity坐标系 世界坐标系 transform.position transform.rotation transform.eulerAngles transform.lossyScale物体坐标系 1、相对父对象的物体坐标系的位置 本地坐标 相对坐标 2、修改他们会是相对父对象物体坐标系的变化 transform.localPosition; transform.localRotation; transform.localEulerAngles; transform.localScale;屏幕坐标系 Input.mousePosition; Screen.width; Screen.height;坐标转换 //世界转本地 transform.InverseTransformDirection(Direction); //不受缩放影响（向量） transform.InverseTransformVector(Vector); //受缩放影响 transform.InverseTransformPoint(pos); //本地转世界 transform.TransformDirection(localDirection); transform.TransformVector(localVector); transform.TransformPoint(localPos); //世界转屏幕 Camera.main.WorldToScreenPoint(pos); //屏幕转世界 Camera.main.ScreenToWorldPoint(ScreenPos); //世界转视口 Camera.main.WorldToViewportPoint(pos); //视口转世界 Camera.main.ViewportToWorldPoint(ViewportPos); //视口转屏幕 Camera.main.ViewportToScreenPoint(ViewportPos); //屏幕转视口 Camera.main.ScreenToViewportPoint(ScreenPos); ","date":"2024-05-16","objectID":"/post/unity/2022/01_unity_math/:0:3","tags":null,"title":"01_unity_math","uri":"/post/unity/2022/01_unity_math/"},{"categories":null,"content":"向量 1、Vector3这边变量 可以表示一个点 也可以表示一个向量 具体表示什么 是根据我们的具体需求和逻辑决定。 2、如何在Unity里面得到向量，终点减起点，就可以得到向量。点C也可以代表向量，代表的就是oc向量，o是坐标系原点。 3、得到了向量就可以利用vector3中提供的成员属性，得到模长和单位向量。 4、模长相当于可以得到两点之间的距离，单位向量主要是用来进行移动计算的它不会影响我们想要的移动效果。 Vector3 A = new Vector3(1, 2, 3); Vector3 B = new Vector3(5, 4, 7); //两点向量 Vector3 AB = B - A; Vector3 BA = A - B; //两个物体之间的向量 Vector3 Vec = Object .position - transform.position; //magnitude 向量的模长 print(Vec.magnitude); print(Vector3.Distance(Object.position, transform.position)); //单位向量 normalized print(Vec.normalized); print(Vec / Vec.magnitude);向量加减乘除运算 #region 知识点一 向量加法 transform.position += new Vector3(1, 2, 3); #endregion #region 知识点二 向量减法 transform.position -= new Vector3(1,2,3); #endregion #region 知识点三 向量乘除标量 放大缩小n倍 transform.localScale *= 2; transform.localScale /= 2; #endregion向量点乘(dot product) **公式一：**A•B = (a1,b1,c1)•(a2,b2,c2) = a1a2 + b1b2 +c1c3 **公式二：**A•B = |A||B|cosβ 几何意义：投影，判断前后 求角度： #region 知识点一 通过点乘判断对象的方位 //Vector3 提供了计算点乘的方法 Debug.DrawRay(transform.position, transform.forward, Color.blue); Debug.DrawRay(transform.position, Target.position - transform.position, Color.green); if (Vector3.Dot(transform.forward, Target.position - transform.position) \u003e= 0) { print(\"目标在前方\"); } else print(\"目标在后方\"); #endregion #region 知识点二 通过点乘推导公式算出夹角 //公式: 角度 = Acos（单位向量 • 单位向量） //1、用单位向量算出点乘结果 float DotResult = Vector3.Dot(transform.forward, (Target.position - transform.position).normalized); //2、用反三角函数得出弧度,然后转为角度 print(\"角度：\" + Mathf.Acos(DotResult) * Mathf.Rad2Deg); //Vector3中提供了 得到两个向量之间夹角的方法 print(\"角度：\" + Vector3.Angle(transform.forward, Target.position - transform.position)); //作用 //怪物范围检测 角度范围内检测 #endregion向量叉乘(cross product) 公式： 模计算：|a×b|=|a||b|sinθ，平行四边形面积计算 几何意义：判断左右、法向量，三角形面片朝向 #region 知识点一 叉乘计算 print(Vector3.Cross(A.position, B.position).normalized); #endregion if (Vector3.Cross(A.position, B.position).y \u003e 0) print(\"B在A的左边\"); else print(\"B在A的右边\"); ","date":"2024-05-16","objectID":"/post/unity/2022/01_unity_math/:0:4","tags":null,"title":"01_unity_math","uri":"/post/unity/2022/01_unity_math/"},{"categories":null,"content":"矩阵乘法 矩阵概念 矩阵的结构是由 m x n 个标量组成。 在程序中，我们用于存储矩阵结构的容器类型有很多选择，最常见的的为： 1、数组（一维、二维都可以） 2、嵌套列表（两个List嵌套） 3、开发工具提供的类或结构体（Unity中的Matrix4x4、Matrix3x2结构体） 矩阵和标量的乘法 矩阵(M)中的每一个标量和标量(k)相乘即可 矩阵和矩阵的乘法 1、首先需要判断两个矩阵是否能够相乘 **判断条件：**左列右行要相等 2、A和B两个矩阵，AB两个矩阵相乘的结果是C矩阵。 那么C(11) = A(1n).B(n1)、C(12) = A(1n).B(n2)、C(13) = A(1n).B(n3) **解读：**C矩阵中的第一行第一列的值等于A中第一行点乘B中第一列。 矩阵之间的乘法 1、不满足交换律 AB ≠ BA 2、满足结合律 (AB)C = A(BC) ABCDE = (AB)(CD)E = A((BC)D)E ","date":"2024-05-16","objectID":"/post/unity/2022/01_unity_math/:0:5","tags":null,"title":"01_unity_math","uri":"/post/unity/2022/01_unity_math/"},{"categories":null,"content":"特殊矩阵 方块矩阵 —— 行列数相等的矩阵。 对角矩阵 —— 只有主对角线有值，其余元素全为零的方阵。 单位矩阵 —— 主对角线上的元素均为1 的对角矩阵。 数量矩阵 —— 主对角线上的元素为同一值的对角矩阵。 转置矩阵 —— 将原始矩阵的行和列互换得到的新矩阵。 矩阵转置的转置等于原矩阵 (MT)T = M 矩阵串接的转置，等于反向串接各个矩阵的转置 (AB)T =BTAT 逆矩阵 逆矩阵必须是一个方阵，并且不是所有矩阵都有逆矩阵。 假设一个方阵 M ，它的逆矩阵用 M-1 表示。 那么存在 MM-1 = M-1M = E（单位矩阵） 如果一个矩阵存在对应的逆矩阵，我们就说该矩阵是可逆的（或称非奇异的）。 如果不存在，那么该矩阵为不可逆的（或称奇异的）。 判断方式:行列式不为0，那么可逆。 行列式的计算方式 假设矩阵为M，|M| 表示M矩阵的行列式，行列式是一个标量（数值） 计算方法： 1、左下左上画对角，线上数值都相乘，数值数量为行列，数量不够对岸取 2、左下分组加，左上分组减 代数余子式矩阵 标准伴随矩阵 标准伴随矩阵为原矩阵的代数余子式矩阵的转置矩阵。 逆矩阵的计算 1、逆矩阵 = 标准伴随矩阵 / 行列式 M-1 = CT / |M| 2、初等变换 (A E)-\u003e(E A-1) 逆矩阵的重要性质 1.逆矩阵的逆矩阵是原矩阵本身 (M-1)-1 = M 2.矩阵乘以自己的逆矩阵等于单位矩阵 MM-1 = M-1M = E 3.单位矩阵的逆矩阵是它本身 E-1 = E 4.转置矩阵的逆矩阵是逆矩阵的转置 (MT)-1 = (M-1)T 5.矩阵串接相乘后的逆矩阵 等于 反向串接各个矩阵的逆矩阵 相乘 (AB)-1 = B-1A-1 6.逆矩阵可以计算矩阵变换的反向变换（M为矩阵，v为一个矢量） M-1(Mv) = (M-1M)v = Ev = v 正交矩阵 正交矩阵是一种特殊的方阵，正交的意思是垂直 它的特点是： 1、一个方阵和它的转置矩阵相乘为单位矩阵，那么它就是正交矩阵 MMT = MTM = E 2、通过正交矩阵的这一性质，再根据上节课学习的逆矩阵的一个重要性质 MM-1 = M-1M = E 3、我们可以推导出：如果一个矩阵是正交的，那么它的逆矩阵等于其转置矩阵 MT = M-1 4、如果一个矩阵是正交矩阵，那么它的转置矩阵也是正交矩阵 判断是否为正交矩阵 根据正交矩阵的基本概念，我们可以总结出判断一个矩阵是否是正交矩阵的方式有： 判断MMT = MTM = E ，满足则为正交矩阵 判断矩阵的每一行（列）是否是单位向量 判断矩阵的行（列）向量是否彼此正交（垂直） ","date":"2024-05-16","objectID":"/post/unity/2022/01_unity_math/:0:6","tags":null,"title":"01_unity_math","uri":"/post/unity/2022/01_unity_math/"},{"categories":null,"content":"行列矩阵 一、列矩阵和行矩阵的基本概念 1、列矩阵就是只有一列的矩阵；行矩阵就是只有一行的矩阵。他们一般用于表示向量 2、把向量作为列矩阵和行矩阵与矩阵进行乘法运算时，计算顺序（列在后，行在前）和结果是不同的 二、列矩阵和行矩阵在Unity中的使用规则 1、在Unity的Shader开发中，我们采用列矩阵的形式进行向量计算，利用结合律，我们可以从右往左阅读 CBAv = C(B(Av)) 2、如果想要使用行矩阵计算出和列矩阵相同的结果，我们可以乘以变换矩阵的转置矩阵 vATBTCT = (((vAT)BT)CT) ","date":"2024-05-16","objectID":"/post/unity/2022/01_unity_math/:0:7","tags":null,"title":"01_unity_math","uri":"/post/unity/2022/01_unity_math/"},{"categories":null,"content":"矩阵的几何意义 点和向量能在图像中画出来，那么矩阵可以吗？ **矩阵的可视化结果就是：**变换 在游戏开发中，如果你看到了一个矩阵，那么基本上你可以认为你看到的是一个变换，这些变换一般包含：平移、旋转、缩放。 **比如：**我们想要将一个点、一个向量进行一种变换（平移、旋转、缩放）。那么我们可以利用矩阵来进行数学计算，从而达到变换的目的。 我们可以利用矩阵相关知识做什么？ 对三维空间中的向量进行平移、旋转、缩放、坐标变换、投影等等计算，这样我们就可以对Shader中的数据进行处理，让其最终在屏幕上的效果是按照我们的需求来呈现的。 什么是变换？ **线性变换：**指可以保留矢量加和标量乘的变换。缩放、旋转、错切、镜像、正交投影等。 **仿射变换：**指合并线性变换和平移变换的变换类型。齐次坐标。 持续更新中 分类: UnityShader ","date":"2024-05-16","objectID":"/post/unity/2022/01_unity_math/:0:8","tags":null,"title":"01_unity_math","uri":"/post/unity/2022/01_unity_math/"},{"categories":null,"content":"API 翻译 - Easydict ","date":"2024-05-07","objectID":"/post/ios/2024/ios_projects_collection/:0:1","tags":null,"title":"ios 开源项目收集","uri":"/post/ios/2024/ios_projects_collection/"},{"categories":null,"content":"SwiftUI swiftui 照片编辑 照片关键词AI检索 相册 HXPhotoPicker ","date":"2024-05-07","objectID":"/post/ios/2024/ios_projects_collection/:0:2","tags":null,"title":"ios 开源项目收集","uri":"/post/ios/2024/ios_projects_collection/"},{"categories":null,"content":"音频 一步一步教你实现iOS音频频谱动画 ","date":"2024-05-07","objectID":"/post/ios/2024/ios_projects_collection/:0:3","tags":null,"title":"ios 开源项目收集","uri":"/post/ios/2024/ios_projects_collection/"},{"categories":null,"content":"issues iphone14 iOS16.6 保存相册是设置originalFilename 后读取不一致 代码 // 设置 let option = PHAssetResourceCreationOptions() option.originalFilename = \"2024-04-23_08-36-02_1.jpg\" // 读取 let resources = PHAssetResource.assetResources(for: self) if let resource = resources.first { fileName = resource.originalFilename } name = \"2024-04-23_16-36-02_1.jpg\"字符串时间被莫名其妙+8了 关闭iCloud相册同步 开启时间市区自动同步 虫害手机后恢复 ","date":"2024-04-23","objectID":"/post/ios/2024/02_arglass_issues/:0:1","tags":null,"title":"02_ARGlass_issues","uri":"/post/ios/2024/02_arglass_issues/"},{"categories":null,"content":" 录屏 ffmpeg -video_size 1280x720 -framerate 30 -f avfoundation -pixel_format uyvy422 -i “0:0” -f flv output.flv 录屏-\u003e推流 ffmpeg -video_size 1280x720 -framerate 30 -f avfoundation -pixel_format uyvy422 -i “0:0” -ar 44100 -f flv rtmp://127.0.0.1:1935/live ","date":"2024-04-17","objectID":"/post/media/2019/01_ffmpeg_cmd/:0:0","tags":null,"title":"FFmpeg 常用命令","uri":"/post/media/2019/01_ffmpeg_cmd/"},{"categories":null,"content":"Mac搭建nginx+rtmp服务 后台搭建直播服务时，安装nginx： 下载 $ brew tap denji/homebrew-nginx*安装 $ brew install nginx-full --with-rtmp-module注意⚠️ --with-rtmp-module，一定要加上rtmp模块，不然添加rtmp服务时就会报错误：unknown directive \"rtmp\" in /usr/local/etc/nginx/nginx.conf:117 如果遇到这种错误，只能是卸载重装了，下面是卸载命令 $ brew uninstall nginx-full然后重新安装。 打开文件/usr/local/etc/nginx/nginx.conf，编辑文件，在最下边添加如下rtmp配置： rtmp { server { listen 1935; ping 30s; notify_method get; application live { live on; record off; max_connections 1024; } } }更新配置：(版本号替换为自己的) /usr/local/Cellar/nginx-full/1.19.0/bin/nginx -s reload 然后就可以启动服务了。 nginx在浏览器里打开http://localhost:8080 如果看到如下页面，说明配置成功了！ 想要停止服务，命令：（stop是强制退出，quit是执行完任务后退出） $ nginx -s quit 或者 $ nginx -s stop ","date":"2024-04-17","objectID":"/post/ios/2023/01_rtmp/:0:0","tags":null,"title":"01_rtmp","uri":"/post/ios/2023/01_rtmp/"},{"categories":null,"content":"可以用ffmpeg推流，来测试直播服务。 安装ffmpeg $ brew install ffmpeg安装成功后，就可以推流本地视频，如下命令： ffmpeg -re -i 本地视频路径 -vcodec libx264 -acodec aac -strict -2 -f flv rtmp://localhost:1935/live/room 开启推流后，用VLC播放器播放下面直播地址视频： rtmp://localhost:1935/live/room 这样一个简单的本地直播服务就搭建好了！ iOS集成LFLiveKit直播库，替换ffmpeg推流，就可以测试直播功能了！ ","date":"2024-04-17","objectID":"/post/ios/2023/01_rtmp/:0:1","tags":null,"title":"01_rtmp","uri":"/post/ios/2023/01_rtmp/"},{"categories":null,"content":"基础 控件一览 ","date":"2024-04-12","objectID":"/post/ios/2024/01_swiftuitips/:0:1","tags":null,"title":"01_swiftuiTips","uri":"/post/ios/2024/01_swiftuitips/"},{"categories":null,"content":"旧项目使用 UIKit 打开 swiftui页面 UIHostingController(rootView: SwiftUIView()) 版本兼容 swiftUI 自iOS13问世以来，每个版本都不兼容，每个版本都有新的Api，适配不同版本工作量巨大🤣； iOS目前（截止2023低） iOS15之下的设备只占3%，这3%中还包含iOS14， 因此最低版本建议iOS14。 多平台适配（iOS、mac、ipad） 最低版本只能使用iOS14以上 ","date":"2024-04-12","objectID":"/post/ios/2024/01_swiftuitips/:0:2","tags":null,"title":"01_swiftuiTips","uri":"/post/ios/2024/01_swiftuitips/"},{"categories":null,"content":"LIST SwiftUI 实战二、List 的使用\u0026交互 ","date":"2024-04-12","objectID":"/post/ios/2024/01_swiftuitips/:0:3","tags":null,"title":"01_swiftuiTips","uri":"/post/ios/2024/01_swiftuitips/"},{"categories":null,"content":"遇到的问题: SPM加载过慢 通过终端打开xcode,终端开启全局代理。 export ALL_PROXY=http://127.0.0.1:7890 open -a Xcode.app","date":"2024-04-12","objectID":"/post/ios/2024/01_swiftuitips/:0:4","tags":null,"title":"01_swiftuiTips","uri":"/post/ios/2024/01_swiftuitips/"},{"categories":null,"content":"参考文档： tvm_phone/tvm-cmake-ios.md at master · zhaowd2001/tvm_phone · GitHub https://blog.csdn.net/qq_38743313/article/details/101601778/ 参考了前面几个文档，发现都不是最好的解决办法，准确的说就没起作用，哈哈哈。 我的测试目录结构如下： 根目录/ assets/test.txt interface/test/somefile.h src/somefile.cpp CMakeLists.txt ios.toolchain.cmake build.sh assets是我想直接复制到framework中去的资源 CMakeLists.txt内容如下 cmake_minimum_required(VERSION 3.10.2) project(CMakeTestLib) enable_language(CXX) set(LIBRARY_OUTPUT_PATH ${CMAKE_SOURCE_DIR}/lib/${OUTPUT_PATH}) file(GLOB_RECURSE SOURCE_FILES ${CMAKE_SOURCE_DIR}/src/*.cpp)file(GLOB_RECURSE INCLUDE_FILES ${CMAKE_SOURCE_DIR}/interface/*.h)file(GLOB_RECURSE ASSETS_FILES ${CMAKE_SOURCE_DIR}/assets/*.txt) MESSAGE( STATUS \"SOURCE_FILES: \" ${SOURCE_FILES} )MESSAGE( STATUS \"INCLUDE_FILES: \" ${INCLUDE_FILES} )MESSAGE( STATUS \"ASSETS_FILES: \" ${ASSETS_FILES} ) set(RESOURCE_FILES ${CMAKE_SOURCE_DIR}/assets/note.txt ) include_directories(${PROJECT_NAME} ${CMAKE_SOURCE_DIR}/interface) add_library(${PROJECT_NAME} SHARED ${SOURCE_FILES} ${CMAKE_SOURCE_DIR}/interface ${CMAKE_SOURCE_DIR}/assets) # Debug symbols set in XCode project# set_xcode_property(${PROJECT_NAME} GCC_GENERATE_DEBUGGING_SYMBOLS YES \"All\") set_target_properties(${PROJECT_NAME} PROPERTIES FRAMEWORK TRUE FRAMEWORK_VERSION A MACOSX_FRAMEWORK_IDENTIFIER com.test.${PROJECT_NAME} # MACOSX_FRAMEWORK_INFO_PLIST Info.plist # \"current version\" in semantic format in Mach-O binary file VERSION 1.0.1 # \"compatibility version\" in semantic format in Mach-O binary file SOVERSION 1.0.1 PUBLIC_HEADER ${CMAKE_SOURCE_DIR}/interface RESOURCE ${CMAKE_SOURCE_DIR}/assets #XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY \"iPhone Developer\") target_include_directories(${PROJECT_NAME} PRIVATE ${CMAKE_SOURCE_DIR}/interface)注意事项： 1、无论是headers还是assets，都要先在add_library中添加了才有用。 2、PUBLIC_HEADER和RESOURCE 后面都可以直接写目录，而非文件列表。 ","date":"2024-04-10","objectID":"/post/others/cmake_ios/:0:0","tags":null,"title":"Cmake_ios","uri":"/post/others/cmake_ios/"},{"categories":null,"content":"文章目录 前言 一、HTTP-FLV 简介 1、市场上使用 http-flv 的商家 2、http-flv、rtmp 和 hls 直播的优缺点 3、http-flv 技术实现 二、Nginx 配置 http-flv 1、Windows 安装 nginx，已经集成 nginx-http-flv-module 2、nginx.conf 配置文件 3、运行 nginx 服务器 4、ffmpeg 推流 5、VLC 播放 6、flv.js 网页播放 三、FLV 格式简介 1、简介 2、FLV 格式解析 ①、header ②、body 四、FLV Adobe 官方标准 1、单位说明 2、FLV 文件头和文件体 (E.2, E.3) 3、FLV Tag (E.4) 4、AudioTag (E.4.2) 5、VideoTag (E.4.3) 6、SCRIPTDATA (E.4.4) 7、onMetadata (E.5) 8、keyframes 索引信息 五、FlvAnalyzer 分析 flv 文件 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:0:0","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"前言 传统的直播协议要么使用 Adobe 的基于 TCP 的 RTMP 协议， 要么使用 Apple 的基于 HTTP 的 HLS 协议。本文介绍另外一种结合了 RTMP 的低延时， 以及可以复用现有 HTTP 分发资源的流式协议 HTTP-FLV。 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:1:0","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"一、HTTP-FLV 简介 HTTP-FLV，即将音视频数据封装成 FLV，然后通过 HTTP 协议传输给客户端。 HLS 其实是一个 “文本协议” ，而并非流媒体协议，(ts0,ts1,…)。 那么，什么样的协议才能称之为流媒体协议呢？ 答：流（stream）：数据在网络上按时间先后次序传输和播放的连续音/视频数据流。之所以可以按照顺序传输和播放连续是因为在类似 RTMP、FLV 协议中，每一个音视频数据都被封装成了包含时间戳信息头的数据包。而当播放器拿到这些数据包解包的时候能够根据时间戳信息把这些音视频数据和之前到达的音视频数据连续起来播放。 MP4、MKV 等等类似这种封装，必须拿到完整的音视频文件才能播放，因为里面的单个音视频数据块不带有时间戳信息，播放器不能将这些没有时间戳信息数据块连续起来，所以就不能实时的解码播放。 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:2:0","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"1、市场上使用 http-flv 的商家 优酷的 pc 网页直播，斗鱼、 熊猫 tv、 虎牙 pc 网页上也使用了 http-flv ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:2:1","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"2、http-flv、rtmp 和 hls 直播的优缺点 三者的延迟性 http-flv：低延迟，内容延迟可以做到 2-5 秒； Rtmp：低延迟，内容延迟可以做到 2-5 秒。 Hls：延迟较高（ts0，segment-time：5，10s）。 三者的易用性 rtmp 和 http-flv：播放端安装率高。只要浏览器支持 FlashPlayer 就能非常简易的播放。 hls：最大的优点：HTML5 可以直接打开播放；这个意味着可以把一个直播链接通过微信等转发分享，不需要安装任何独立的 APP，有浏览器即可。 rtmp 和 http-flv 比较 穿墙：很多防火墙会墙掉 RTMP，但是不会墙 HTTP，因此 HTTP FLV 出现奇怪问题的概率很小。 调度：RTMP 也有个 302，可惜是播放器 as 中支持的，HTTP FLV 流就支持 302 方便 CDN 纠正 DNS 的错误。 容错：SRS 的 HTTP FLV 回源时可以回多个，和 RTMP 一样，可以支持多级热备。 简单：FLV 是最简单的流媒体封装，HTTP 是最广泛的协议，这两个组合在一起维护性更高，比 RTMP 简单多了。 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:2:2","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"3、http-flv 技术实现 HTTP 协议中有个约定：content-length 字段，http 的 body 部分的长度。 服务器回复 http 请求的时候如果有这个字段，客户端就接收这个长度的数据然后就认为数据传输完成了。 如果服务器回复 http 请求中没有这个字段，客户端就一直接收数据，直到服务器跟客户端的 socket 连接断开。 (流式传输） http-flv 直播就是利用第二个原理，服务器回复客户端请求的时候不加 content-length 字段，在回复了 http 内容之后，紧接着发送 flv 数据，客户端就一直接收数据了。 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:2:3","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"二、Nginx 配置 http-flv ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:3:0","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"1、Windows 安装 nginx，已经集成 nginx-http-flv-module RTMP 服务器：Nginx+rtmp（windows）的环境搭建如有需要可自取： 链接：https://pan.baidu.com/s/1AcIVERWUPbJL1zu8yCcAzw 提取码：mtdf ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:3:1","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"2、nginx.conf 配置文件 nginx.conf 配置文件如下： worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #error_log logs/error.log debug; #pid logs/nginx.pid; events { worker_connections 1024; } # 添加RTMP服务 rtmp { server { listen 1935; # 监听端口 chunk_size 4000; application live { live on; gop_cache on; hls on; hls_path html/hls; } } } # HTTP服务 http { include mime.types; default_type application/octet-stream; #access_log logs/access.log main; server { listen 8080; # 监听端口 location /flv { flv_live on; chunked_transfer_encoding on; add_header 'Access-Control-Allow-Origin' '*'; add_header \"Access-Control-Allow-Credentials\" \"true\"; add_header \"Access-Control-Allow-Methods\" \"*\"; add_header \"Access-Control-Allow-Headers\" \"Content-Type,Access-Token\"; add_header \"Access-Control-Expose-Headers\" \"*\"; } location /stat.xsl { root html; } location /stat { rtmp_stat all; rtmp_stat_stylesheet stat.xsl; } location / { root html; } } }其中涉及到跨域问题：#http-flv location /flv { flv_live on; chunked_transfer_encoding on; add_header 'Access-Control-Allow-Origin' '*'; add_header \"Access-Control-Allow-Credentials\" \"true\"; add_header \"Access-Control-Allow-Methods\" \"*\"; add_header \"Access-Control-Allow-Headers\" \"Content-Type,Access-Token\"; add_header \"Access-Control-Expose-Headers\" \"*\"; }","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:3:2","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"3、运行 nginx 服务器 双击 nginx8080.exe 在任务管理器可以看到目前 nginx 已开始工作 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:3:3","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"4、ffmpeg 推流 ffmpeg -re -i SampleVideo_1280x720_20mb.mp4 -vcodec libx264 -acodec aac -f flv -y rtmp://127.0.0.1:1935/live/test1这个命令使用 FFmpeg 工具来将输入视频文件 SampleVideo_1280x720_20mb.mp4 转换为 FLV 格式并通过 RTMP 协议流式传输到指定的 URL 地址 rtmp://127.0.0.1:1935/live/test1； -re：以实时模式（real-time）读取输入文件，模拟实时流传输的速度。 -i SampleVideo_1280x720_20mb.mp4：指定输入文件名为 SampleVideo_1280x720_20mb.mp4。 -vcodec libx264：选择 H.264 编码器作为视频编码器； -acodec aac：选择 AAC 编码器作为音频编码器； -f flv：指定输出格式为FLV（Flash Video）； -y：自动覆盖输出文件，如果存在同名文件则会被替换； rtmp://127.0.0.1:1935/live/test1：指定输出的 URL 地址，以 RTMP 协议传输到 192.168.36.176 服务器的 1935 端口的 live 应用程序中的 test1 流 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:3:4","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"5、VLC 播放 http-flv：http://localhost:8080/flv?port=1935\u0026app=live\u0026stream=test1 对应关系如下： VLC 进行拉流 rtmp：rtmp://127.0.0.1:1935/live/test1 Hls：http://localhost:8080/hls/test1.m3u8 此外，视频和音频内容分割为小的 TS 文件，并生成相应的 M3U8 文件，以便客户端能够获取和播放这些文件。M3U8 文件可以通过 HTTP 服务器提供给客户端，并使用流媒体播放器（如VLC、HLS播放器等）进行解析和播放。 这个目录是由 nginx.conf 配置文件决定的： ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:3:5","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"6、flv.js 网页播放 前面我们已经解决了跨域问题 html.flv 文件内容如下： worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #error_log logs/error.log debug; #pid logs/nginx.pid; events { worker_connections 1024; } # 添加RTMP服务 rtmp { server { listen 1935; # 监听端口 chunk_size 4000; application live { live on; gop_cache on; hls on; hls_path html/hls; } } } # HTTP服务 http { include mime.types; default_type application/octet-stream; #access_log logs/access.log main; server { listen 8080; # 监听端口 location /flv { flv_live on; chunked_transfer_encoding on; add_header 'Access-Control-Allow-Origin' '*'; add_header \"Access-Control-Allow-Credentials\" \"true\"; add_header \"Access-Control-Allow-Methods\" \"*\"; add_header \"Access-Control-Allow-Headers\" \"Content-Type,Access-Token\"; add_header \"Access-Control-Expose-Headers\" \"*\"; } location /stat.xsl { root html; } location /stat { rtmp_stat all; rtmp_stat_stylesheet stat.xsl; } location / { root html; } } }因此双击 flv.html 文件，可以看到网页播放成功 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:3:6","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"三、FLV 格式简介 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:4:0","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"1、简介 FLV（Flash Video）是现在非常流行的流媒体格式，由于其视频文件体积轻巧、封装播放简单等特点，使其很适合在网络上进行应用，目前主流的视频网站无一例外地使用了 FLV 格式。另外由于当前浏览器与 Flash Player 紧密的结合，使得网页播放 FLV 视频轻而易举，也是 FLV 流行的原因之一。 FLV 是流媒体封装格式，我们可以将其数据看为二进制字节流。总体上看，FLV 包括文件头（File Header：9 字节）和文件体（File Body）两部分，其中文件体由一系列的 Tag 及 Tag Size 对组成。 注意这个大小关系：PreviosTagSize = TagDataSize + 11; ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:4:1","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"2、FLV 格式解析 先来一张图，这是上面我们播放的视频文转换为 FLV 文件 使用 Notepad++ 进行查看二进制数据（注：这里要求 Notepad++ 安装了 HexEditor 插件） 可以参考我以前的博客：notepad++安装HexEditor插件查看二进制文件 SampleVideo_1280x720_20mb.flv 文件二进制内容如下： ①、header 头部分由以下几部分组成：Signature（3 Byte）+Version（1 Byte）+Flags（1 Bypte）+DataOffset（4 Byte） signature 占 3 个字节：固定 FLV 三个字符作为标示。一般发现前三个字符为 FLV 时就认为他是 flv 文件。 Version 占 1 个字节：标示 FLV 的版本号。 这里我们看到是 1 Flags 占 1 个字节：内容标示。第 0 位和第 2 位，分别表示 video 与 audio 存在的情况。(1 表示存在，0 表示不存在)。截图看到是 0x05，也就是 00000101，代表既有视频，也有音频。 DataOffset 4 个字节：表示 FLV 的 header 长度。 这里可以看到固定是 9 ②、body FLV 的 body 部分是由一系列的 back-pointers（ 后向指针） + tag 构成 back-pointers 固定 4 个字节，表示前一个 tag 的 size。 从上图可以看到前一个 tag 的 size 为 0 tag 分三种类型：video、audio、scripts。 tag 组成：tag type[1B]+tag data size[3B]+Timestamp[3B]+TimestampExtended[1B]+stream id[3B]+ tag data type 1 个字节。8 为 Audio，9 为 Video，18 为 scripts 从上图可以看到 type 为 0x123 = 18 --\u003e scripts tag data size 3 个字节。表示 tag data 的长度：从 streamd id 后算起。 从上图可以看到 tag data size 为 0x123 = 297 Timestreamp 3 个字节。 时间戳 从上图可以看到 Timestreamp 为 0x000000 = 0 TimestampExtended 1 个字节。 时间戳扩展字段 从上图可以看到 TimestampExtended 为 0x00 = 0 stream id 3 个字节。 总是 0 tag data 数据部分 tag 头伪代码： ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:4:2","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"四、FLV Adobe 官方标准 FLV 文件格式标准是写在 F4V/FLV file format spec v10.1 的附录 E 里面的 FLV File Format。 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:5:0","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"1、单位说明 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:5:1","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"2、FLV 文件头和文件体 (E.2, E.3) 从整个文件上看，FLV = FLV File Header + FLV File Body。 通常，FLV 的前 13 个字节（flv header + PreviousTagSize0）完全相同，所以，程序中会单独定义一个常量来指定。特殊，比如有的视频文件没有视频流或没有音频流。 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:5:2","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"3、FLV Tag (E.4) Timestamp 和 TimestampExtended 组成了这个 TAG 包数据的 PTS 信息，PTS =Timestamp | TimestampExtended \u003c\u003c 24。 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:5:3","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"4、AudioTag (E.4.2) 由于 AAC 编码的特殊性， 这里着重说明了 AAC 编码的 Tag 格式。 AudioTagHeader 的第一个字节，也就是接跟着 StreamID 的 1 个字节包含了音频类型，采样率等的基本信息。 AudioTagHeader 之后跟着的就是 AUDIODATA 部分了。但是，这里有个特例，如果音频格式（SoundFormat）是 AAC，AudioTagHeader 中会多出 1 个字节的数据 AACPacketType，这个字段来表示 AACAUDIODATA 的类型：0 = AAC sequence header，1 = AAC raw。 AudioSpecificConfig 结构描述非常复杂，在标准文档中是用伪代码描述的，这里先假定要编码的音频格式，做一下简化。 音频编码为：AAC-LC，音频采样率为 44100。 在 FLV 的文件中，一般情况下 AAC sequence header 这种包只出现 1 次，而且是第一个 audio tag，为什么需要这种 tag，因为在做 FLV demux 的时候，如果是 AAC 的音频，需要在每帧 AAC ES 流前边添加 7 个字节 ADST 头， ADST 是解码器通用的格式，也就是说 AAC 的纯 ES 流要打包成 ADST 格式的 AAC 文件，解码器才能正常播放。 就是在打包 ADST 的时候，需要 samplingFrequencyIndex 这个信息，samplingFrequencyIndex 最准确的信息是在 AudioSpecificConfig 中，这样，你就完全可以把 FLV 文件中的音频信息及数据提取出来， 送给音频解码器正常播放了。 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:5:4","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"5、VideoTag (E.4.3) 由于 AVC(H.264) 编码的特殊性， 这里着重说明了 AVC(H.264) 编码的 Tag 格式。 VideoTagHeader 的第一个字节，也就是接跟着 StreamID 的 1 个字节包含着视频帧类型及视频 CodecID 等最基本信息。 VideoTagHeader 之后跟着的就是 VIDEODATA 部分了。但是，这里有个特例，如果视频格式（CodecID）是 AVC， VideoTagHeader 会多出 4 个字节的信息。 AVCDecoderConfigurationRecord 包含着是 H.264 解码相关比较重要的 SPS 和 PPS 信息，在给 AVC 解码器送数据流之前一定要把 SPS 和 PPS 信息送出，否则的话，解码器不能正常解码。而且在解码器 stop 之后再次 start 之前， 如 seek，快进快退状态切换等，都需要重新送一遍 SPS 和 PPS 的信息。AVCDecoderConfigurationRecord 在 FLV 文件中一般情况也只出现 1 次，也就是第一个 video tag。 AVCDecoderConfigurationRecord 长度为 sizeof(UI8) * (11 + sps_size + pps_size)。 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:5:5","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"6、SCRIPTDATA (E.4.4) ScriptTagBody 内容用 AMF 编码 一个 SCRIPTDATAVALUE 记录包含一个有类型的 ActionScript 值。 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:5:6","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"7、onMetadata (E.5) FLV metadata object 保存在 SCRIPTDATA 中，叫 onMetaData。不同的软件生成的 FLV 的 properties 不同。 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:5:7","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"8、keyframes 索引信息 官方的文档中并没有对 keyframes index 做描述，但是，flv 的这种结构每个 tag 又不像 TS 有同步头，如果没有 keyframes index 的话，需要按顺序读取每一个 tag，seek 及快进快退的效果会非常差。后来在做 flv 文件合成的时候，发现网上有的 flv 文件将 keyframes 信息隐藏在 Script Tag 中。 keyframes 几乎是一个非官方的标准，也就是民间标准。两个常用的操作 metadata 的工具是 flvtool2 和 FLVMDI， 都是把 keyframes 作为一个默认的元信息项目。在 FLVMDI 的主页上有描述： 也就是说 keyframes 中包含着 2 个内容 “filepositions” 和 “times”分别指的是关键帧的文件位置和关键帧的 PTS。通过 keyframes 可以建立起自己的 Index，然后在 seek 和快进快退的操作中，快速有效地跳转到你想要找的关键帧位置进行处理。 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:5:8","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"五、FlvAnalyzer 分析 flv 文件 参考我之前的博客：音视频开发常用工具 查看其中第三章的内容： 我的qq：2442391036，欢迎交流！ 原文 ","date":"2024-04-07","objectID":"/post/media/02_http-flv/02_http-flv/:6:0","tags":null,"title":"02_http Flv","uri":"/post/media/02_http-flv/02_http-flv/"},{"categories":null,"content":"入职当前公司，接手App时遇到的问题和解决方案 ","date":"2024-04-01","objectID":"/post/ios/2019/01_cameraissues/:1:0","tags":null,"title":"摄像头项目中遇到的问题","uri":"/post/ios/2019/01_cameraissues/"},{"categories":null,"content":"Object-c ","date":"2024-04-01","objectID":"/post/ios/2019/01_cameraissues/:1:1","tags":null,"title":"摄像头项目中遇到的问题","uri":"/post/ios/2019/01_cameraissues/"},{"categories":null,"content":"Swift ","date":"2024-04-01","objectID":"/post/ios/2019/01_cameraissues/:1:2","tags":null,"title":"摄像头项目中遇到的问题","uri":"/post/ios/2019/01_cameraissues/"},{"categories":null,"content":"音视频 1.iOS录制h265无法保存到相册 if (videoStream-\u003ecodec-\u003ecodec_id == AV_CODEC_ID_H265) { avformat_alloc_output_context2(\u0026mOutFormatContext, NULL, \"mov\", [fileName UTF8String]); videoStream-\u003ecodec-\u003ecodec_tag = MKTAG('h', 'v', 'c', '1'); }参考： 文件输出指定mov hev和hvc tag兼容测试 ","date":"2024-04-01","objectID":"/post/ios/2019/01_cameraissues/:1:3","tags":null,"title":"摄像头项目中遇到的问题","uri":"/post/ios/2019/01_cameraissues/"},{"categories":["iOS","media"],"content":"起因： 目前这家公司项目中用到的mp4v2还是19年之前的版本，不支持h265，bugly崩溃率 \u003c 0.01%。 ","date":"2024-03-29","objectID":"/post/media/libmp4v2_update/libmp4v2_update/:0:1","tags":null,"title":"老项目mp4v2简单升级","uri":"/post/media/libmp4v2_update/libmp4v2_update/"},{"categories":["iOS","media"],"content":"检查更新 github上新版本 ","date":"2024-03-29","objectID":"/post/media/libmp4v2_update/libmp4v2_update/:0:2","tags":null,"title":"老项目mp4v2简单升级","uri":"/post/media/libmp4v2_update/libmp4v2_update/"},{"categories":["iOS","media"],"content":"编译\u0026xcode打包 下载代码 git clone https://github.com/TechSmith/mp4v2.git 配置静态、动态 CMakeLists.txt //动态链接 add_library(mp4v2 SHARED ${HEADER_FILES} ${SOURCE_FILES}) //静态链接 add_library(mp4v2 STATIC ${HEADER_FILES} ${SOURCE_FILES}) 使用cmake生成xcode工程 cd mp4v2 cmake -G \"Xcode\" . xcode 打开,选择对应target 配置打包 ","date":"2024-03-29","objectID":"/post/media/libmp4v2_update/libmp4v2_update/:0:3","tags":null,"title":"老项目mp4v2简单升级","uri":"/post/media/libmp4v2_update/libmp4v2_update/"},{"categories":null,"content":"前言 vscode调试C/C++教程很多，操作麻烦，这里试图找到一个最简单的使用vscode调试C/C++代码的方法。这里是使用Makefile的多文件方式。 ","date":"2024-03-27","objectID":"/post/code/2024/01_makefile/01_makefile/:0:1","tags":null,"title":"vscode调试C/C++代码的方法。这里是使用Makefile的多文件方式【转】","uri":"/post/code/2024/01_makefile/01_makefile/"},{"categories":null,"content":"测试文件 tree . ├── func.c ├── func.h ├── main.c └── Makefilefun.c #include \u003cstdio.h\u003e #include \"func.h\" int foo1(int a) { int b = ++a; printf(\"This is foo1 %d\\n\",b); }fun.h int foo1(int a);main.c #include \u003cstdio.h\u003e #include \"func.h\" int main() { int a = 1; printf(\"Hello, I am coming %d\\n\", a); foo1(a); return 0; }Makefile CC = gcc CFLAGS = -g LDFLAGS = TARGET = test SRCS = $(wildcard *.c) OBJS = $(SRCS:.c=.o) all: $(TARGET) $(TARGET): $(OBJS) $(CC) $(CFLAGS) $(OBJS) -o $(TARGET) $(LDFLAGS) %.o: %.c $(CC) $(CFLAGS) -c $\u003c -o $@ clean: rm -f $(OBJS) $(TARGET) ","date":"2024-03-27","objectID":"/post/code/2024/01_makefile/01_makefile/:0:2","tags":null,"title":"vscode调试C/C++代码的方法。这里是使用Makefile的多文件方式【转】","uri":"/post/code/2024/01_makefile/01_makefile/"},{"categories":null,"content":"关键配置文件 在.vscode路径下 lauch.json { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"(gdb) 启动\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/test\", //编译后可执行文件路径 \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${fileDirname}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"为 gdb 启用整齐打印\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true }, { \"description\": \"将反汇编风格设置为 Intel\", \"text\": \"-gdb-set disassembly-flavor intel\", \"ignoreFailures\": true } ], \"preLaunchTask\" :\"C/C++: gcc 生成活动文件\", // 与task中label一致 \"miDebuggerPath\": \"/usr/bin/gdb\" } ] }tasks.json { \"tasks\": [ { \"type\": \"cppbuild\", \"label\": \"C/C++: gcc 生成活动文件\", \"command\": \"make\", // 使用Mafile编译 \"args\": [ //\"-fdiagnostics-color=always\", //\"-g\", //\"${file}\", //\"-o\", //\"${fileDirname}/${fileBasenameNoExtension}\" ], \"options\": { \"cwd\": \"${workspaceFolder}\" //项目所在目录 }, \"problemMatcher\": [ \"$gcc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"detail\": \"调试器生成的任务。\" } ], \"version\": \"2.0.0\" }最终调试时文件 /ws/example$ tree -a . ├── func.c ├── func.h ├── func.o ├── main.c ├── main.o ├── Makefile ├── test └── .vscode ├── launch.json ├── settings.json └── tasks.json","date":"2024-03-27","objectID":"/post/code/2024/01_makefile/01_makefile/:0:3","tags":null,"title":"vscode调试C/C++代码的方法。这里是使用Makefile的多文件方式【转】","uri":"/post/code/2024/01_makefile/01_makefile/"},{"categories":null,"content":"成功调试 ","date":"2024-03-27","objectID":"/post/code/2024/01_makefile/01_makefile/:0:4","tags":null,"title":"vscode调试C/C++代码的方法。这里是使用Makefile的多文件方式【转】","uri":"/post/code/2024/01_makefile/01_makefile/"},{"categories":null,"content":"1、创建目录 os.makedirs可以递归的创建目录结构 import osos.makedirs('dirname', exist_ok=True)exist_ok = True指定了，如果某个要创建的目录已经存在，也不报错。 2、删除文件或目录 os.remove可以删除一个文件 os.remove('xx.py')shutil.rmtree() 可以递归的删除某个目录所有的子目录和子文件 import shutilshutil.rmtree('tmp', ignore_errors=True)参数ignore_errors = True 保证如果目录不为空，不会抛出异常。 3、拷贝目录 要拷贝一个目录里面所有的内容（包括子目录和文件、子目录里面的子目录和文件）到另一个目录中，可以使用shutil的copytree函数 form shutil import copytreecopytree('d:/tools/aaa', 'e:/new/bbb')拷贝前，目标目录必须不存在，否则会报错。 拷贝前，如果e:/new这个目录不存在，执行时会创建e:/new目录，再创建e:/new/bbb目录，再拷贝 拷贝前，如果e:/new存在，但是e:/new/bbb不存在，就只会创建e:/new/bbb，再拷贝 4、修改文件名、目录名 os.rename('d:/tools/aaa', 'd:/tools/bbb')os.rename('d:/tools/first.py', 'd:/tools/second.py')linux系统上，如果重命名之前d:/tools/second.py已存在，则会覆盖。 5、对文件路径的操作 import ospath = '/user/beazley/data/data.csv'# 获取路径中的文件名部分os.path.basename(pat) # 'data.csv'# 获取路径中的目录部分os.path.dirname(path) # '/user/beazley/data'# 文件路径的拼接os.path.join('tmp', 'data', os.path.basename(path))# 'tmp/data/data.csv'6、判断文件、目录是否存在 os.path.exists('d:/systems/cmd.exe')os.paht.exists('d:/systems')7、判断是否是文件或目录 os.path.isfile('d:/systems/cmd.exe')os.path.isdir('d:systems')8、文件大小和修改日期 # 返回文件大小os.path.getsize('file')# 返回文件的最后修改日期，是秒时间os.path.getmtime('file')# 把秒时间转化为日期时间time.ctime(os.path.getmtime('/etc/passwd'))9、取当前工作目录 cwd = os.getcwd()# 切抽当前工作目录到另外的路径os.chdir(path)10、遍历目录下文件 # 目标目录targetDir = r'd:/tmp/util/dist/check'files = []dirs = [] # dirpath:当前遍历到的目录名# dirnames:存放当前dirpath中的所有子目录名# filenames:存放当前dirpath中的所有文件名for(dirpath, dirnames, filenames) in os.walk(targetDir): files += filenames dirs += dirnamesprint(files)print(dirs)获取目录下所有文件的全路径： targetDir = r'd:/tmp/util/dist/check'for(dirpath, dirnames, filenames) in os.walk(targetDir): for fn in filenames: # 把dirpath和每个文件名拼接起来 fpath = os.path.join(dirpath, fn)取目录中所有的文件和子目录名： targetDir = r'd:/tmp/util/dist/check'files = os.listdir(targetDir)print(files)如果只需要获取目录中所有的文件，或只需要子目录： import osfrom os.path import isfile, join, isdirtargetDir = r'd:/tmp/util/dist/check'# 所有的文件print([f for f in os.listdir(targetDir) if isfile(join(targetDir, f))])# 所有的目录print([f for f in os.listdir(targetDir) if isdir(join(targetDir, f))])11、取目录中指定扩展名的文件和子目录 import globexes = glob.glob(r'd:/tmp/*.txt')print(exes) 注意 python 运行的相对路径 vscode 运行、调试时路径 ","date":"2022-03-28","objectID":"/post/python/2022/01_file/:0:0","tags":null,"title":"01_file","uri":"/post/python/2022/01_file/"},{"categories":null,"content":"win10 本地时间为UTC时间 Reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1 ","date":"2021-06-08","objectID":"/post/others/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"日常小技巧【未分类】","uri":"/post/others/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"edge缓存修改 2021-12-01更新：经过测试最新版Edge不再需要2种方法结合才能生效，2种方法单独都可以使用(谷歌Chrome同理) 方法一(一劳永逸)： ①创建新的缓存文件夹，以E:\\Cache\\Edge为例，必须在第3步之前创建； ②关闭Edge浏览器，删除 C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Edge\\User Data\\Default路径下的Cache文件夹(加粗字体修改成当前计算机登陆的用户名，Win10用户通过“设置-账户-账户信息”、Win7用户通过“控制面板-用户帐户-用户帐户”查看，用户名必须核实)； ③以管理员身份运行cmd命令行输入mklink /D “C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Edge\\User Data\\Default\\Cache” “E:\\Cache\\Edge\"并运行(加粗字体修改成当前登陆用户名，第二个引号内容修改成新路径)； 方法二(简单)： ①右键Edge图标 -\u003e 属性 -\u003e 目标 -\u003e 最末尾加上 –disk-cache-dir=“E:\\Cache\\Edge”(注意–前面有个空格，引号里面内容修改成新路径)，点击确定。此方法虽然简单但是必须通过这个图标打开浏览器才能正常缓存到新路径。 ","date":"2021-06-08","objectID":"/post/others/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"日常小技巧【未分类】","uri":"/post/others/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"categories":["iOS","media"],"content":"原文地址 blog.csdn.net 编解码协议 H264（视频）和 AAC（音频）有软编解码和硬编解码。 网络传输都是用的大端序（高地址低字节），H264 网络传输的 startcode 是数据的 length，不是 0x00000001。NALU 有两种格式：Annex B 和 AVCC。Annex B 格式 startcode 以 0x 00 00 01 或 0x 00 00 00 01 开头， AVCC 格式以 NALU 的长度开头。 AAC 也有两种传输格式：ADTS 和 ADIF ADIF：Audio Data Interchange Format 音频数据交换格式。这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，即它的解码必须在明确定义的开始处进行。故这种格式常用在磁盘文件中。 ADTS：Audio Data Transport Stream 音频数据传输流。这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于 mp3 数据流格式。 软编码：使用 CPU 进行编码。编码框架 ffmpeg+x264。 https://www.jianshu.com/p/e631b041e96d https://www.jianshu.com/p/3de01105d735 硬编码：不使用 CPU 进行编码，使用显卡（GPU）进行硬件加速。 专用的 DSP、FPGA、ASIC 芯片等硬件进行编码。ios 上硬编码框架 Video ToolBox 和 AudioToolbox。 Intel 硬编码使用 Intel 处理器内部集成的显卡进行硬件加速，qsv 加速方法便对应着 Intel 硬编码。Intel 硬编码对 H.264 加速效果明显，且不需要安装额外库（仅使用相应的 ffmpeg 命令）。 NVIDIA 硬编码使用英伟达的显卡对视频编码进行加速。CUDA 加速方法对应着 NVIDIA 硬编码。使用英伟达硬编码之前需要安装 CUDA 与英伟达的必要驱动。安装好两个环境后就可以使用 NVIDIA 的硬编码了。英伟达关于视频的编解码提供了两个相关的 SDK：NVENC（硬编码）和 NVCUVID（硬解码），前者负责硬件编码，二后者负责硬件解码。CUDA 支持 Windows、Linux、MacOS 三种主流操作系统。https://blog.csdn.net/qq_29350001/article/details/75144665（CUDA 详解） FFmpeg 中也支持了硬编码，集成了显示视频处理模块。在命令行中使用 ffmpeg -hwaccels 可以查看 ffmpeg 支持的硬件加速方法。 FFMPEG 目前存在一个编码器 nvenc 是对于 NVIDIA 的 NVENC 的封装，通过使用它可以和 FFMPEG 无缝的整合起来。不过 FFMPEG 只存在 NVENC 的接口，不存在 NVCUVID（解码器） 的封装。如果需要实现相关的解码器可能需要自己实现 FFMPEG 接口。FFMPEG 实现了对于 Intel QSV 的封装。 DXVA 是微软定制的视频加速规范、在 Linux 平台上则是由 NVIDIA 提供的 VDPAU 和 Intel 提供的 VAAPI 加速规范。 在不同平台上可通过不同 API 使用 Intel GPU 的硬件加速能力。目前主要由两套 API：VAAPI 以及 libmfx。VAAPI (视频加速 API，Video Acceleration API) 包含一套开源的库 (LibVA) 以及 API 规范, 用于硬件加速下的视频编解码以及处理，只有 Linux 上的驱动提供支持。libmfx。Intel Media SDK 中的 API 规范，支持视频编解码以及媒体处理。支持 Windows 以及 Linux。除了 Intel 自己的 API，在 Windows 系统上还有其他 API 可使用 Intel GPU 的硬件加速能力，这些 API 属于 Windows 标准，由 Intel 显卡驱动实现。DXVA2 / D3D11VA。标准 Windows API，支持通过 Intel 显卡驱动进行视频编解码，FFmpeg 有对应实现。Media Foundation。标准 Windows API，支持通过 Intel 显卡驱动进行视频编解码，FFmpeg 不支持该 API。https://blog.jianchihu.net/intel-gpu-hw-video-codec-develop.html 目前的主流 GPU 加速平台： INTEL、AMD、NVIDIA目前主流的 GPU 平台开发框架： CUDA：NVIDIA 的封闭编程框架，通过框架可以调用 GPU 计算资源 AMD APP：AMD 为自己的 GPU 提出的一套通用并行编程框架，标准开放，通过在 CPU、GPU 同时支持 OpenCL 框架，进行计算力融合。 OpenCL：开放计算语言，为异构平台编写程序的该框架，异构平台可包含 CPU、GPU 以及其他计算处理器，目标是使相同的运算能支持不同平台硬件加速。 Inel QuickSync：集成于 Intel 显卡中的专用视频编解码模块。 https://www.jianshu.com/p/8423724dffc1 https://blog.csdn.net/haowei0926/article/details/56012139 ios 中的硬编码文档 ios 上硬编码框架 Video ToolBox 和 AudioToolbox。Video ToolBox 是一个底层框架，可以直接访问硬件编码器和解码器。 它提供视频压缩和解压缩服务，并在 CoreVideo 像素缓冲区中存储的光栅 raster 图像格式之间进行转换。 这些服务以会话对象（压缩，解压缩和像素传输）的形式提供，它们以 Core Foundation（CF）类型呈现。 不需要直接访问硬件编码器和解码器的应用程序 App 就不需要直接使用 VideoToolbox。iOS 8.0 及以上苹果开放了 VideoToolbox 框架来实现 H264 硬编码（H264 是一种编解码协议，有多种编解码器能编解码 H264，这里是利用硬件进行编解码，FFmpeg 中可以利用硬编解码和软编解码）。 CVPixelBufferRef/CVImageBufferRef：存放编码前和解码后的图像数据（未压缩的数据），这两个是相同的对象。 CMTime：时间戳相关，时间以 64-bit/32-bit 的形式出现 CMBlockBufferRef：编码后输出的数据（压缩后的数据） CMFormatDescriptionRef/CMVideoFormatDescriptionRef：图像存储方式，编解码器等格式描述。这两个是相同的对象。 CMSampleBufferRef：存放编解码前后的视频图像的容器数据，iOS 中表示一帧音频 / 视频数据 CMSampleBuffer 可能是一个压缩的数据，也可能是一个未压缩的数据。取决于 CMSampleBuffer 里面是 CMBlockBuffer（压缩后） 还是 CVPixelBuffer（未压缩）。 硬编码的步骤 ：从相机或读取视频文件输出的 CVPixelBuffer（也是以 CMSampleBufferRef 封装形式存在）—\u003eEncoder—\u003eCMSampleBufferRef（编码后得到的数据封装）—\u003e 重新组装 NALUs。 通过 VTCompressionSessionCreate 创建编码器 VTCompressionSessionCreate( CM_NULLABLE CFAllocatorRef allocator, int32_t width, int32_t height, CMVideoCodecType codecType, CM_NULLABLE CFDictionaryRef encoderSpecification, CM_NULLABLE CFDictionaryRef sourceImageBufferAttributes, CM_NULLABLE CFAllocatorRef compressedDataAllocator, CM_NULLABLE VTCompressionOutputCallback outputCallback, void * CM_NULLABLE outputCallbackRefCon, CM_RETURNS_RETAINED_PARAMETER CM_NULLABLE VTCompressionSessionRef * CM_NONNULL compressionSessionOut) allocator：内存分配器，填NULL为默认分配器 width、height：视频帧像素的宽高，如果编码器不支持这个宽高的话可能会改变 codecType：编码类型，枚举 encoderSpecification：指定特定的编码器，填NULL的话由VideoToolBox自动选择 sourceImageBufferAttributes：源像素缓冲区的属性，如果这个参数有值的话，VideoToolBox会创建一个缓冲池，不需要缓冲池可以设置为NULL compressedDataAllocator：压缩后数据的内存分配器，填NULL使用默认分配器 outputCallback：视频编码后输出数据回调函","date":"2020-03-09","objectID":"/post/media/01_ios-%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81/:0:0","tags":["iOS"],"title":"iOS 音视频编解码","uri":"/post/media/01_ios-%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81/"},{"categories":["algorithm"],"content":"目录 一、冒泡排序： 二、插入排序： 三、选择排序： 四、希尔排序： 五、堆排序： 六、快速排序： 6.1挖坑法： 6.2左右指针法 6.3前后指针法： 七、归并排序： 八、桶排序： 九、计数排序： 9.1绝对映射： 9.2现对映射： 十、基数排序： ","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:0:0","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":"一、冒泡排序： **1、思路：**通过对待排序序列从前向后（从下标较小的元素开始）,依次对相邻两个元素的值进行两两比较，若发现前一个数大于后一个数则交换，使值较大的元素逐渐从前移向后部，就如果水底下的气泡一样逐渐向上冒。 2、先以一个数组讲解一下，然后再写代码： 待排序数组：3，9，-1，10，20 第一轮排序： （1）3，9，-1，10，20 —-3跟9比较，不交换 （2）3，-1，9，10，20 —-9比 -1大，所以9跟 -1交换 （3）3，-1，9，10，20 —-9跟10比较，不交换 （4）3，-1，9，10，20 —-10跟20比较，不交换 第一轮过后，将20这个最大的元素固定到了最后的位置。 在第二轮的时候20不参与冒泡。 第二轮排序： 因为20的位置已经固定，所以只对前4个进行排序即可： （1）-1，3，9，10，20 —-3比 -1大，进行交换 （2）-1，3，9，10，20 —-3跟9比较，不交换 （3）-1，3，9，10，20 —-9跟10比较，不交换 第二轮过后，将第二大的元素固定到了倒数第二个位置 第三轮排序： 10和20的位置已经确定，只需对前三个进行排序 （1）-1，3，9，10，20 —-3和-1比较，不交换 （2）-1，3，9，10，20 —-3和9比较，不交换 第三轮过后，将第三大的元素位置确定 第四轮排序： 只对前两个元素进行排序 （1）-1，3，9，10，20 —-3和-1比较，不交换 第四轮过后，将第四大的元素位置确定，此时总共5个元素，已经排序好4个，从而最后一个自然而然就是排好序的了 小结： 设总的元素个数为n，那么由上边的排序过程可以看出： （1）总计需要进行（n-1）轮排序，也就是（n-1）次大循环 （2）每轮排序比较的次数逐轮减少 （3）如果发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序 （4）时间复杂度是O(N^2) 在有序的时候，很快，因为有exchange变量优化了代码 在乱序的时候很慢很慢。 #include\u003cstdio.h\u003e void swap(int* a, int* b){ int tmp = *a; *a = *b; *b = tmp; } //冒泡排序 void BubbleSort(int* a, int n) { int end = n - 1;//不能是n，不然会越界 while(end) { int exchange = 0;//优化，比较之后没有交换，说明已经排好了，就break循环 for (int i = 0; i \u003c end; i++) { if (a[i] \u003c a[i + 1]) { swap(\u0026a[i], \u0026a[i + 1]); exchange++; } } if (exchange == 0) break; end--; } } ","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:0","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":"二、插入排序： 1、思路： 在待排序的元素中，假设前n-1个元素已有序，现将第n个元素插入到前面已经排好的序列中，使得前n个元素有序。按照此法对所有元素进行插入，直到整个序列有序。 但我们并不能确定待排元素中究竟哪一部分是有序的，所以我们一开始只能认为第一个元素是有序的，依次将其后面的元素插入到这个有序序列中来，直到整个序列有序为止。 2、举例： 如下图的插入扑克牌，当摸到7的时候，会不自觉的与前面的数比较，如果比7大，把大的数向后挪动（swap），然后在第一个小于7的后面插入7 //插入排序 void InsertSort(int* a, int n) { for (int i = 1; i \u003c n; i++) { if (a[i] \u003c a[i - 1])//先判断，如果i下标的值大于前面的数，就不进入 { int tmp = a[i]; int j; for (j = i - 1; j \u003e= 0 \u0026\u0026 a[j] \u003etmp; j--) { a[j+1] = a[j]; } a[j+1] = tmp; } } } //两次循环就可以实现 //内部循环完成一趟的插入 //外层循环完成插入排序 ","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:0","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":"三、选择排序： 思路： 1.内层循环一趟找出最小值的下标，与第一个数交换。重复找小，交换的两个操作。 2.实际上，我们可以一趟选出两个值，一个最大值一个最小值，然后将其放在序列开头和末尾，这样可以使选择排序的效率快一倍。 但时间复杂度还是O（N^2），效率还是不高 //选择排序 void SelectSort(int* a, int n) { for (int i = 0; i \u003c n-1; i++)//i\u003cn-1当它是最后一个数的时候不需要进行交换排序 { int min = i; int j; for (j = i; j \u003c n; j++) { if (a[j] \u003c a[min]) { min=j; } } swap(\u0026a[i], \u0026a[min]);//交换函数，前面的代码中有出现，我就不重复写了 } } ","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:0","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":"四、希尔排序： 思路： 1.插入排序的优化版，有一个预排序的过程。让大的数快速的跳到后面，小的数快速的跳到前面。 2.使待排序列接近有序，然后再对该序列进行一次插入排序。 3.相当于把直接插入排序中的1换成gap而已。 //希尔排序 /*步骤： 1.先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再gap--，重复上述操作。 2.当gap==1时就是直接插入排序，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。*/ void ShellSort(int* a, int n) { //这里相当于把插入排序的1换成gap int gap = n; while (gap\u003e1) { gap = gap / 3 + 1; for (int i = gap; i \u003c n; i++) { if (a[i] \u003c a[i - gap]) { int tmp = a[i]; int j; for (j = i - gap; j \u003e= 0 \u0026\u0026 a[j] \u003e tmp; j-=gap)//这里是j-=gap { a[j + gap] = a[j]; } a[j + gap] = tmp; } } } } ","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:0","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":"五、堆排序： 先来认识堆： 1.什么是堆？ 大堆：父亲大于儿子 小堆：父亲小于儿子（父亲，儿子是二叉树的概念） 2.堆的物理结构和逻辑结构？ 物理结构：数组 逻辑结构：完全二叉树 堆排序包括建堆（向下调整+循环） 堆排序（交换+向下调整） 1.建堆： 要建大堆，堆顶的元素和最后一个数交换，然后把size–，就不会破坏堆的结构 2.向下调整算法： 比较两个孩子的大小，选出大的孩子，与父亲比较，如果孩子大于父亲，交换。然后把parent=child，child=parent*2+1；向下调整算法一共会调整h-1次 //向下调整算法（要满足它下面的都满足堆，才能用） void AdjustDown(int* a, int n, int root) { int parent = root; int child = parent * 2 + 1; while (child \u003c n) { if (child + 1 \u003c n \u0026\u0026 a[child] \u003c a[child + 1]) child+=1;//把他移到右孩子那里 if (a[child] \u003e a[parent]) { swap(\u0026a[child], \u0026a[parent]); parent = child; child = parent * 2 + 1; } else break; } } 堆排序 void HeapSort(int* arr, int n) { //建大堆 //从最后一个根开始，就相当于它下面的都满足堆，就可以用向下调整算法 for (int i = (n-1-1)/2; i \u003e= 0; i--)//n-1-1是因为数组的最后一个元素下标是n-1 { AdjustDown(arr, n, i); } //排序 for (int i = n; i \u003e 1; i--) { swap(\u0026arr[0],\u0026arr[i - 1]); AdjustDown(arr, i-1, 0); } } ","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:0","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":"六、快速排序： 三种快排方法：（一定要自己尝试着去写，会有一些坑，自己写才可以体会） 1.挖坑法 2.左右指针法 3.前后指针法 ","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:0","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":"6.1挖坑法： 1.思想： 记第一个数为key，要调整key的位置，使得左边的都要比key的小，右边的数都比key的大。 2.步骤： 选出一个数据（一般是最左边或是最右边的）存放在key变量中，在该数据位置形成一个坑 还是定义一个left和一个right，left从左向右走（当遇到大于key的值时停下来）。right从右向左走（当遇到小于key的值时停下来）。（若在最左边挖坑，则需要right先走；若在最右边挖坑，则需要left先走） 把right的那个小的数放在坑中，在把left那个位置的值放在right那个位置中 重复操作，直到left\u003eright时结束，完成一趟，把key放在了正确的位置 最后用分治思想，分成左边和右边，递归。 //1.挖坑法的快速排序 void QuickSort(int* a,int left,int right) { if (left \u003e= right)//不能写成pivot==left，pivot-1与left不匹配，会报错 { return; } int begin = left,end = right; int key = a[begin];//挖了一个关键字 int pivot = begin;//挖了一个坑 while (begin \u003c end) { //右边找小，一定要先右边找小,放在pivot while (begin \u003c end\u0026\u0026a[end] \u003e= key)//在这里也要判断begin \u003c end,因为这里面end-- { end--; } //小的放在左边的坑里，然后形成新的坑位 a[pivot] = a[end]; pivot = end; //左边找大 while (begin \u003c end \u0026\u0026 a[begin] \u003c= key) { begin++; } a[pivot] = a[begin]; pivot = begin; } //begin==end a[pivot] = key; //[left,right] //[left,pivot-1] pivot [pivot+1,right] //如果左子区间和右子区间都有序，就全部有序。那就分治递归。 QuickSort(a, left, pivot - 1); QuickSort(a, pivot+1, right); } ","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:1","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":"6.2左右指针法 思路： 1、选出一个key，一般是最左边或是最右边的。 2、定义一个begin和一个end，begin从左向右走，end从右向左走。（需要注意的是：若选择最左边的数据作为key，则需要end先走；若选择最右边的数据作为key，则需要bengin先走）（考虑到最后的时候相遇点的和key交换）。 3、在走的过程中，若end遇到小于key的数，则停下，begin开始走，直到begin遇到一个大于key的数时，将begin和right的内容交换，end再次开始走，如此进行下去，直到begin和end最终相遇，此时将相遇点的内容与key交换即可。（选取最左边的值作为key） 4.此时key的左边都是小于key的数，key的右边都是大于key的数 5.将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去，直到左右序列只有一个数据，或是左右序列不存在时 void QuickSort(int* a, int left, int right) { if (left \u003e= right) { return; } int begin = left, end = right; int key = begin;//这里与挖坑法不同的地方，因为要交换key的那个数组中那个位置的数，而不是值 while (begin \u003c end) { while (begin \u003c end \u0026\u0026 a[end] \u003e= a[key]) { end--; } while (begin \u003c end \u0026\u0026 a[begin] \u003c= a[key]) { begin++; } Swap(\u0026a[begin], \u0026a[end]); } Swap(\u0026a[begin], \u0026a[key]); QuickSort(a, left, begin - 1); QuickSort(a, begin + 1, right); } ","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:2","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":"6.3前后指针法： 思路： 1、选出一个key，一般是最左边。 2、起始时，prev指针指向序列开头，cur指针指向prev+1。 3、让cur一直向前走，当遇到小于a[key]时，让prev向前走一格（这个值一定大于a[key]，因为是cur走过的），然后a[cur]和a[prev]交换。 经过一次单趟排序，最终也能使得key左边的数据全部都小于key，key右边的数据全部都大于key。 然后也还是将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去 用if(left\u003eright) { reurn; }//跳出递归 void QuickSort(int* a, int left,int right) { if (left \u003e= right) { return; } int index=GetMidIndex(a,left, right); swap(\u0026a[left], \u0026a[index]); int key = left; int prev = left; int cur = left+1; while (cur \u003c= right) { if (a[cur] \u003c a[key]) { prev++; swap(\u0026a[cur], \u0026a[prev]); } /*可以简写成cur++， 但是当时一定要注意不要放在if语句的前面，因为if语句里面有让cur与prev交换的，cur==right跳出循环，但是a[cur]超过数组的范围，会越界范围。 while (cur\u003c=right\u0026\u0026a[cur] \u003e= a[key]) { cur++; }*/ cur++; } swap(\u0026a[prev], \u0026a[key]); QuickSort(a, left, prev - 1); QuickSort(a, prev+1,right); } ","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:3","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":" 6.4优化快排 三数取中法：取左端、中间、右端三个数，然后进行比较，将中值数当做key 否则有序时时间复杂度为O(N^2) 三数取中法可以套入三种方法中，这里我就写一种 //三数取中 int GetMidIndex(int* a, int left, int right) { int mid = (left + right) / 2; if (a[mid] \u003e= a[left]) { if (a[mid] \u003c= a[right]) { return mid; } else { if (a[right] \u003e= a[left]) { return right; } else { return left; } } } else//a[left]\u003ea[mid] { if (a[right] \u003e= a[left]) { return left; } else { if (a[right] \u003e= a[mid]) { return right; } else { return mid; } } } } //交换 void swap(int* a, int* b) { int tmp = *a; *a = *b; *b = tmp; } //前后指针法 void QuickSort(int* a, int left,int right) { if (left \u003e= right) { return; } int index=GetMidIndex(a,left, right); swap(\u0026a[left], \u0026a[index]); int key = left; int prev = left; int cur = left+1; while (cur \u003c= right) { if (a[cur] \u003c a[key]) { prev++; swap(\u0026a[cur], \u0026a[prev]); } cur++; } swap(\u0026a[prev], \u0026a[key]); QuickSort(a, left, prev - 1); QuickSort(a, prev+1,right); } ","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:4","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":"七、归并排序： 思路： 1.不断的分割数据，让数据的每一段都有序（一个数据相当于有序） 2.当所有子序列有序的时候，在把子序列归并，形成更大的子序列，最终整个数组有序。 ！！！需要开一个_MergeSort,而不是直接在MergeSort中直接递归，是因为MergeSort中有一个malloc 归并排序很像二叉树中的后序思想，先递归，递归到最后的时候再合并。！！！ //归并排序 void _MergeSort(int* a, int left, int right, int* tmp)//在这个函数中调用递归{ if (left \u003e= right) { return; } int mid = (left + right) \u003e\u003e 1; _MergeSort(a, left, mid, tmp); _MergeSort(a, mid+1, right, tmp); //合并 int begin1 = left, end1 = mid; int begin2 = mid + 1, end2 = right; int i = left; while (begin1 \u003c= end1 \u0026\u0026 begin2 \u003c= end2) { if (a[begin1] \u003c= a[begin2]) { tmp[i++] = a[begin1++]; } else { tmp[i++] = a[begin2++]; } } while (begin1 \u003c= end1) { tmp[i++] = a[begin1++]; } while (begin2 \u003c= end2) { tmp[i++] = a[begin2++]; } for (int j = left; j \u003c= right; j++) { a[j] = tmp[j]; } } void MergeSort(int* a, int n) { int* tmp = (int*)malloc(sizeof(int) * n); _MergeSort(a, 0, n - 1, tmp); free(tmp); } ","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:7:0","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":"八、桶排序： **思路：**大问题化小 桶排序 (Bucket sort)或所谓的箱排序，是一种分块的排序算法，工作的原理是将数组分到有限数量的桶里，每个桶的大小都相等。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序） 把待排序序列（数组）中的数据根据函数映射方法分配到若干个桶中，在分别对各个桶进行排序，最后依次按顺序取出桶中的数据。 适用于数据分配均匀，数据比较大，相对集中的情况。 //桶排序 void bucket_sort(int a[],int size,int bucket_size) { int i,j; //数组，数组长度，桶的大小 //定义动态的指针数组 KeyNode **bucket_num = (KeyNode **)malloc(bucket_size * sizeof(KeyNode*)); for(i = 0;i \u003c bucket_size;i++) { bucket_num[i] = (KeyNode*)malloc(sizeof(KeyNode));//为每个链表定义头结点 bucket_num[i]-\u003enum = 0; bucket_num[i]-\u003enext = NULL; //指针变量初始化为空 } for(j = 0;j \u003c size;j++) //准备插入 { KeyNode *node = (KeyNode *)malloc(sizeof(KeyNode));//定义一个节点 node-\u003enum = a[j]; //数据域存数据 node-\u003enext = NULL; //指向空 int index = a[j]/100; //映射函数 计算桶号 KeyNode *p = bucket_num[index];//p指向链表的头 //链表结构的插入排序 while(p-\u003enext != NULL \u0026\u0026 p-\u003enext-\u003enum \u003c= node-\u003enum) { p = p-\u003enext; //1.链表为空，p-\u003enext==NULL，进入不了循环 } //2.链表不为空，因为链表从无开始按顺序插入，数据为有序的， //可以找到 前一个节点 \u003c= node \u003c=后一个节点 //节点插入链表 node-\u003enext = p-\u003enext; p-\u003enext = node; (bucket_num[index]-\u003enum)++; //记录一下该链表中有几个有效节点 } //打印结果 KeyNode * k = NULL; //定义一个空的结构体指针用于储存输出结果 for(i = 0;i \u003c bucket_size;i++) { //for(k = bucket_num[i]-\u003enext;k!=NULL;k=k-\u003enext)//通过最后一个指针指向空 k = bucket_num[i]-\u003enext; for(int m=0;m\u003cbucket_num[i]-\u003enum;m++) //通过头指针记录节点数 { printf(\"%d \",k-\u003enum); k=k-\u003enext; } printf(\"\\n\"); } ","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:8:0","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":"九、计数排序： 一种特殊的排序，唯一种没有比较的排序（指没有前后比较，还是有交换的） 以数组的下标当做数值，有这个数的时候a[i]++; 局限：适用于整数。数要求集中（否则空间的浪费大） ","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:0","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":"9.1绝对映射： int index = 0; int *tmpArr = (int *)malloc(max*sizeof(int)); int *result = (int *)malloc(max*sizeof(int)); for(int k = 0;k\u003cmax;k++) { tmpArr[k] = 0; } for (int i = 0; i\u003ccount; i++) { tmpArr[arr[i]]++; } for (int j = 0; j\u003cmax; j++) { while (tmpArr[j]) { result[index++] = j; tmpArr[j]--; } } free(tmpArr); tmpArr = NULL; return result; }","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:1","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":"9.2现对映射： void CountSort(int* a, int n) { int max = a[0], min = a[0]; for (int i = 0; i \u003c n; i++) { if (a[i] \u003e max) max = a[i]; if (a[i] \u003c min) min = a[i]; } int range = max - min + 1; int* count = (int*)malloc(sizeof(int) * range); memset(count, 0, sizeof(int) * range); for (int i = 0; i \u003c n; i++) { count[a[i] - min]++; } int i = 0; for (int j = 0; j \u003c range; j++) { while (count[j]--) { a[i++] = j + min; } } free(count); } ","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:2","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["algorithm"],"content":"十、基数排序： 原理：是将整数按位数切割成不同的数字，然后按每个位数分别比较。 #include\u003cmath.h\u003e testBS() { inta[] = {2, 343, 342, 1, 123, 43, 4343, 433, 687, 654, 3}; int *a_p = a; //计算数组长度 intsize = sizeof(a) / sizeof(int); //基数排序 bucketSort3(a_p, size); //打印排序后结果 inti; for(i = 0; i \u003c size; i++) { printf(\"%d\\n\", a[i]); } intt; scanf(\"%d\", t); } //基数排序 voidbucketSort3(int *p, intn) { //获取数组中的最大数 intmaxNum = findMaxNum(p, n); //获取最大数的位数，次数也是再分配的次数。 intloopTimes = getLoopTimes(maxNum); inti; //对每一位进行桶分配 for(i = 1; i \u003c= loopTimes; i++) { sort2(p, n, i); } } //获取数字的位数 intgetLoopTimes(intnum) { intcount = 1; inttemp = num / 10; while(temp != 0) { count++; temp = temp / 10; } returncount; } //查询数组中的最大数 intfindMaxNum(int *p, intn) { inti; intmax = 0; for(i = 0; i \u003c n; i++) { if(*(p + i) \u003e max) { max = *(p + i); } } returnmax; } //将数字分配到各自的桶中，然后按照桶的顺序输出排序结果 voidsort2(int *p, intn, intloop) { //建立一组桶此处的20是预设的根据实际数情况修改 intbuckets[10][20] = {}; //求桶的index的除数 //如798个位桶index=(798/1)%10=8 //十位桶index=(798/10)%10=9 //百位桶index=(798/100)%10=7 //tempNum为上式中的1、10、100 inttempNum = (int)pow(10, loop - 1); inti, j; for(i = 0; i \u003c n; i++) { introw_index = (*(p + i) / tempNum) % 10; for(j = 0; j \u003c 20; j++) { if(buckets[row_index][j] == NULL) { buckets[row_index][j] = *(p + i); break; } } } //将桶中的数，倒回到原有数组中 intk = 0; for(i = 0; i \u003c 10; i++) { for(j = 0; j \u003c 20; j++) { if(buckets[i][j] != NULL) { *(p + k) = buckets[i][j]; buckets[i][j] = NULL; k++; } } } }","date":"2019-03-08","objectID":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:10:0","tags":["iOS"],"title":"十大排序算法【转载】","uri":"/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"Hugo, the world's fastest framework for building websites","date":"2019-02-28","objectID":"/page/about/","tags":null,"title":"About","uri":"/page/about/"},{"categories":null,"content":"Written in Go, Hugo is an open source static site generator available under the Apache License 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows. Hugo makes use of a variety of open source projects including: https://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages. Hugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases. Websites built with Hugo are extremely fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider. Learn more and contribute on GitHub. ","date":"2019-02-28","objectID":"/page/about/:0:0","tags":null,"title":"About","uri":"/page/about/"},{"categories":null,"content":" 本文由 简悦 SimpRead 转码， 原文地址 www.jianshu.com flutter SDK 提供的默认标签样式不太吸引人。 但这并不意味着您无法自定义标签的外观。 在 Flutter 中自定义Tab指示器的样式可以通过简单的代码行完成，而无需实现我们自己的窗口小部件。 在本文中，我将向您展示如何为下一个 Flutter 项目添加 5 种不同的标签样式。 首先，您需要使用DefaultTabController类创建一个基本选项卡。 将DefaultTabController分配给MaterialApp小部件的home属性。 作为DefaultTabController的子级，可以将Scaffold与 Appbar和主体一起使用。 将Appbar小部件分配到Scaffold的Appbar属性，以使选项卡的标题部分。 对于脚手架的body属性，可以为TabBarView小部件分配 3 个子小部件，以在单击时显示Tab内容项。 image 检查完整的代码以获取默认Tab。 return DefaultTabController( length: 3, child: Scaffold( appBar: AppBar( elevation: 0, bottom: TabBar( indicatorSize: TabBarIndicatorSize.label, tabs: [ Tab( child: Align( alignment: Alignment.center, child: Text(\"APPS\"), ), ), Tab( child: Align( alignment: Alignment.center, child: Text(\"MOVIES\"), ), ), Tab( child: Align( alignment: Alignment.center, child: Text(\"GAMES\"), ), ), ], ), ), body: TabBarView( children: [ Icon(Icons.apps), Icon(Icons.movie), Icon(Icons.games), ], ), ), );","date":"0001-01-01","objectID":"/post/flutter/2024/%E5%9C%A8-flutter-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BA%94%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84-tab/:0:0","tags":null,"title":"","uri":"/post/flutter/2024/%E5%9C%A8-flutter-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BA%94%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84-tab/"},{"categories":null,"content":"1. 圆角 Tab 风格 作为第一种样式，我们将向选项卡指示器添加圆角样式。 首先，我将简要介绍我们将要修改的参数。 1. unselectedLabelColor –不存在指示符的标签颜色。 基本上，尚未选择的指标。 2. indicatorSize –选定的指标大小。 我们可以添加两个值以使指标为标签宽度或标签宽度。 3. Indicator –这是我们要为指标分配自定义样式的地方 Tab–这将包含Tab标题的列表。 在这里，我们可以为每个Tab标题添加额外的样式。 可以通过添加带有borderRadius 50的BoxDecoration来实现圆角样式。在这里，我们向每个Tab```标题添加红色边框。 当有人选择Tab`` 时，它将用红色填充。 如果您对边框不感兴趣，可以删除边框并保持简单。 image return DefaultTabController( length: 3, child: Scaffold( appBar: AppBar( backgroundColor:Colors.white, elevation: 0, bottom: TabBar( unselectedLabelColor:Colors.redAccent, indicatorSize: TabBarIndicatorSize.label, indicator:BoxDecoration( color:Colors.redAccent, borderRadius:BorderRadius.circular(50), ), tabs: [ Tab( child:Container( decoration:BoxDecoration( borderRadius:BorderRadius.circular(50), border:Border.all(color:Colors.redAccent, width:1, ), ), child:Align( alignment:Alignment.center, child:Text(\"APPS\"), ), ), ), Tab( child:Container( decoration:BoxDecoration( borderRadius:BorderRadius.circular(50), border:Border.all(color:Colors.redAccent, width:1, ), ), child:Align( alignment:Alignment.center, child:Text(\"MOVIES\"), ), ), ), Tab( child:Container( decoration:BoxDecoration( borderRadius:BorderRadius.circular(50), border:Border.all(color:Colors.redAccent, width:1, ), ), child:Align( alignment:Alignment.center, child:Text(\"GASMES\"), ), ), ), ], ), ), body: TabBarView( children: [ Icon(Icons.apps), Icon(Icons.movie), Icon(Icons.games), ], ), ), );","date":"0001-01-01","objectID":"/post/flutter/2024/%E5%9C%A8-flutter-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BA%94%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84-tab/:0:1","tags":null,"title":"","uri":"/post/flutter/2024/%E5%9C%A8-flutter-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BA%94%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84-tab/"},{"categories":null,"content":"2. 圆角带有渐变色 Tab 风格 我们将删除以前方法中添加到每个Tab的样式。 删除后，向BoxDecoration添加渐变。 您可以使用带有两种颜色的LinearGradient小部件来获得渐变效果。 您可以根据自己的喜好更改渐变。 image return DefaultTabController( length: 3, child: Scaffold( appBar: AppBar( backgroundColor:Colors.white, elevation: 0, bottom: TabBar( unselectedLabelColor:Colors.redAccent, indicatorSize: TabBarIndicatorSize.tab, indicator:BoxDecoration( gradient:LinearGradient( colors:[ Colors.redAccent, Colors.orangeAccent, ], ), color:Colors.redAccent, borderRadius:BorderRadius.circular(50), ), tabs: [ Tab( child:Align( alignment:Alignment.center, child:Text(\"APPS\"), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\"MOVIES\"), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\"GASMES\"), ), ), ], ), ), body: TabBarView( children: [ Icon(Icons.apps), Icon(Icons.movie), Icon(Icons.games), ], ), ), );","date":"0001-01-01","objectID":"/post/flutter/2024/%E5%9C%A8-flutter-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BA%94%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84-tab/:0:2","tags":null,"title":"","uri":"/post/flutter/2024/%E5%9C%A8-flutter-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BA%94%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84-tab/"},{"categories":null,"content":"3. 矩形 Tab 风格 矩形样式可以通过更改上一个中的小代码来完成。 可以通过为leftTop和rightTop都添加10来更改boxDecoration的BorderRadius。 然后，我将appbar backgroundColor更改为红色，以使其看起来更好。 image return DefaultTabController( length: 3, child: Scaffold( appBar: AppBar( backgroundColor:Colors.redAccent, elevation: 0, bottom: TabBar( labelColor:Colors.redAccent, unselectedLabelColor:Colors.white, indicatorSize: TabBarIndicatorSize.label, indicator:BoxDecoration( color:Colors.white, borderRadius:BorderRadius.only( topLeft:Radius.circular(10), topRight:Radius.circular(10), ), ), tabs: [ Tab( child:Align( alignment:Alignment.center, child:Text(\"APPS\"), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\"MOVIES\"), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\"GASMES\"), ), ), ], ), ), body: TabBarView( children: [ Icon(Icons.apps), Icon(Icons.movie), Icon(Icons.games), ], ), ), );","date":"0001-01-01","objectID":"/post/flutter/2024/%E5%9C%A8-flutter-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BA%94%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84-tab/:0:3","tags":null,"title":"","uri":"/post/flutter/2024/%E5%9C%A8-flutter-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BA%94%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84-tab/"},{"categories":null,"content":"4. 菱形 Tab 样式 您可以通过为ShapeDecoration小部件的shape参数添加带有 BeveledRectangleBorder 的ShapeDecoration来获得Diamond选项卡样式。 BeveledRectangleBorder将允许您添加展平角而不是圆角。 在这里，我们使用 borderRadius 作为 10 使其看起来像这样。 image return DefaultTabController( length: 3, child: Scaffold( appBar: AppBar( backgroundColor:Colors.white, elevation: 0, bottom: TabBar( unselectedLabelColor:Colors.redAccent, indicatorPadding:EdgeInsets.only(left:30,right:30), indicator:ShapeDecoration( color:Colors.redAccent, shape:BeveledRectangleBorder( side:BorderSide( color:Colors.redAccent, ), borderRadius:BorderRadius.circular(10), ), ), tabs: [ Tab( child:Align( alignment:Alignment.center, child:Text(\"APPS\"), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\"MOVIES\"), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\"GASMES\"), ), ), ], ), ), body: TabBarView( children: [ Icon(Icons.apps), Icon(Icons.movie), Icon(Icons.games), ], ), ), );","date":"0001-01-01","objectID":"/post/flutter/2024/%E5%9C%A8-flutter-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BA%94%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84-tab/:0:4","tags":null,"title":"","uri":"/post/flutter/2024/%E5%9C%A8-flutter-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BA%94%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84-tab/"},{"categories":null,"content":"5. 菱形 Tab 样式（2） 同样，通过更改BeveledRectangleBorder的borderRadius，可以实现不同的形状。 您可以将borderRadius更改为 20，以获得其他形状。 您可以通过更改 borderRadius 值尝试不同的样式。 image return DefaultTabController( length: 3, child: Scaffold( appBar: AppBar( backgroundColor:Colors.white, elevation: 0, bottom: TabBar( unselectedLabelColor:Colors.redAccent, indicatorPadding:EdgeInsets.only(left:30,right:30), indicator:ShapeDecoration( color:Colors.redAccent, shape:BeveledRectangleBorder( side:BorderSide( color:Colors.redAccent, ), borderRadius:BorderRadius.circular(20), ), ), tabs: [ Tab( child:Align( alignment:Alignment.center, child:Text(\"APPS\"), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\"MOVIES\"), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\"GASMES\"), ), ), ], ), ), body: TabBarView( children: [ Icon(Icons.apps), Icon(Icons.movie), Icon(Icons.games), ], ), ), );我希望您能通过几行代码更好地了解如何更改选项卡样式。 如果您想观看此视频，请观看以下视频。 https://www.youtube.com/watch?v=Vnd0yvCkdNA\u0026feature=youtu.be ","date":"0001-01-01","objectID":"/post/flutter/2024/%E5%9C%A8-flutter-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BA%94%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84-tab/:0:5","tags":null,"title":"","uri":"/post/flutter/2024/%E5%9C%A8-flutter-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BA%94%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84-tab/"},{"categories":null,"content":"To use this feature, add links section to frontmatter. This page’s frontmatter: links: - title: GitHub description: GitHub is the world's largest software development platform. website: https://github.com image: https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png - title: TypeScript description: TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. website: https://www.typescriptlang.org image: ts-logo-128.jpgimage field accepts both local and external images. ","date":"0001-01-01","objectID":"/page/links/:0:0","tags":null,"title":"Links","uri":"/page/links/"}]