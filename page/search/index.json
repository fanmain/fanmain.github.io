[{"content":"项目中使用Getx 遇到的问题 1.简单状态管理下 #view #widget class DropMenuWidget extends StatefulWidget { ... final String? selectedValue; //默认选中的值 } GetBuilder(builder: (_){ return DropMenuWidget(data: ..., selectCallBack: ..., selectedValue: logic.state.cmdType.toString(), ); }) #logic update();//不刷新对应GetBuilder #修改view GetBuilder(id:0x01,builder: (_){ return DropMenuWidget(data: ..., selectCallBack: ..., selectedValue: logic.state.cmdType.toString(), ); }) update([0x01]);//刷新对应GetBuilder 但是DropMenuWidget未能刷新 #最终修改 #将第三方widget构造加入 key: Key(\u0026#34;${state.cmdType}\u0026#34;), GetBuilder(id:0x01,builder: (_){ return DropMenuWidget(key:Key(\u0026#39;...\u0026#39;),data: ..., selectCallBack: ..., selectedValue: logic.state.cmdType.toString(), ); }) update([0x01]); //问题解决 ","date":"2024-07-31T10:48:18+08:00","permalink":"https://fanmain.github.io/post/ios/2024/07_getx_issues/","title":"07_Getx_issues"},{"content":"flutter 升级 3.22.1 记录 dependencies 升级报错修复 flutter attach 无法连接 尝试： 首先怀疑防火墙问题,开关防火墙 =\u0026gt; 无效 手机重启 =\u0026gt; 无效 调试 flutter attach -v # 检索服务 dns-sd -Z _dartobservatory._tcp # 手动attach flutter attach --debug-uri=\u0026#34;http://127.0.0.1:53168/HC5AIqfdvCQ\\=/\u0026#34; -v # 提示iproxy文件安全权限，在mac安全和隐私中允许 # 在防火墙中将dart flutter iproxy 相关的文件加入 info.plist 加入mdns dart服务名 _dartVmService._tcp 参考 官方issue Flutter多引擎无法Attach问题分析及热重载卡死问题处理 解决方法 ","date":"2024-07-02T14:43:26+08:00","permalink":"https://fanmain.github.io/post/ios/2024/06_flutter_issues/","title":"06_flutter_issues"},{"content":"2024 音视频学习目录 kcp 协议初步了解\n","date":"2024-06-24T15:01:46+08:00","permalink":"https://fanmain.github.io/post/media/2024/","title":"2024"},{"content":"cocoapods 升级记录 1.12.1 =\u0026gt; 1.14.0\n➜ ~ gem list --local | grep cocoapods cocoapods (1.12.1) cocoapods-core (1.12.1) cocoapods-deintegrate (1.0.5) cocoapods-downloader (1.6.3) cocoapods-plugins (1.0.0) cocoapods-search (1.0.1) cocoapods-trunk (1.6.0) cocoapods-try (1.2.0) ➜ ~ sudo gem install cocoapods -v 1.14.0 Password: Fetching cocoapods-1.14.0.gem Fetching xcodeproj-1.24.0.gem Fetching concurrent-ruby-1.3.3.gem Fetching cocoapods-core-1.14.0.gem Fetching cocoapods-downloader-2.1.gem Successfully installed xcodeproj-1.24.0 Successfully installed cocoapods-downloader-2.1 Successfully installed concurrent-ruby-1.3.3 Successfully installed cocoapods-core-1.14.0 Successfully installed cocoapods-1.14.0 Parsing documentation for xcodeproj-1.24.0 Installing ri documentation for xcodeproj-1.24.0 Parsing documentation for cocoapods-downloader-2.1 Installing ri documentation for cocoapods-downloader-2.1 Parsing documentation for concurrent-ruby-1.3.3 Installing ri documentation for concurrent-ruby-1.3.3 Parsing documentation for cocoapods-core-1.14.0 Installing ri documentation for cocoapods-core-1.14.0 Parsing documentation for cocoapods-1.14.0 Installing ri documentation for cocoapods-1.14.0 Done installing documentation for xcodeproj, cocoapods-downloader, concurrent-ruby, cocoapods-core, cocoapods after 3 seconds 5 gems installed ➜ ~ gem list --local | grep cocoapods cocoapods (1.14.0, 1.12.1) cocoapods-core (1.14.0, 1.12.1) cocoapods-deintegrate (1.0.5) cocoapods-downloader (2.1, 1.6.3) cocoapods-plugins (1.0.0) cocoapods-search (1.0.1) cocoapods-trunk (1.6.0) cocoapods-try (1.2.0) ➜ ~ sudo gem uninstall cocoapods 1.12.1 Gem \u0026#39;1.12.1\u0026#39; is not installed Select gem to uninstall: 1. cocoapods-1.12.1 2. cocoapods-1.14.0 3. All versions \u0026gt; 1 Successfully uninstalled cocoapods-1.12.1 ➜ ~ gem list --local | grep cocoapods cocoapods (1.14.0) cocoapods-core (1.14.0, 1.12.1) cocoapods-deintegrate (1.0.5) cocoapods-downloader (2.1, 1.6.3) cocoapods-plugins (1.0.0) cocoapods-search (1.0.1) cocoapods-trunk (1.6.0) cocoapods-try (1.2.0) ➜ ~ sudo gem uninstall cocoapods-core Select gem to uninstall: 1. cocoapods-core-1.12.1 2. cocoapods-core-1.14.0 3. All versions \u0026gt; 1 Successfully uninstalled cocoapods-core-1.12.1 ➜ ~ sudo gem uninstall cocoapods-downloader Select gem to uninstall: 1. cocoapods-downloader-1.6.3 2. cocoapods-downloader-2.1 3. All versions \u0026gt; 1 Successfully uninstalled cocoapods-downloader-1.6.3 ","date":"2024-06-14T11:07:42+08:00","permalink":"https://fanmain.github.io/post/ios/2024/05_cocoapods/","title":"05_cocoapods"},{"content":"前言 最近不想折腾贝壳云了 想着把openwrt的Pa*w**l改到群晖docker 上去\n1.设置docker网卡 #获取root权限 sudo -i #设置混杂模式 ifconfig eth0 promisc # 禁用混杂模式 ifconfig eth0 \\-promisc 创建 macvlan 网络 docker network create -d macvlan \\ --subnet=192.168.2.0/24 \\ --gateway=192.168.2.1 \\ -o parent=eth0 \\ macnet 查看加入\ndocker network ls 生成配置 # 新建文件夹 openwrt 和 子目录 mkdir \\-p /volume1/docker/openwrt/data/lock \\ # 进入 openwrt 目录 cd /volume1/docker/openwrt \\ # 创建 network.conf 文件 touch network.conf \\ # 编辑 network.conf 文件 vi network.conf 编辑配置\nconfig interface \u0026#39;loopback\u0026#39; option ifname \u0026#39;lo\u0026#39; option proto \u0026#39;static\u0026#39; option ipaddr \u0026#39;127.0.0.1\u0026#39; option netmask \u0026#39;255.0.0.0\u0026#39; config globals \u0026#39;globals\u0026#39; option packet_steering \u0026#39;1\u0026#39; config interface \u0026#39;lan\u0026#39; option ifname \u0026#39;eth0\u0026#39; option proto \u0026#39;static\u0026#39; option netmask \u0026#39;255.255.255.0\u0026#39; option ip6assign \u0026#39;60\u0026#39; option ipaddr \u0026#39;192.168.2.3\u0026#39; option gateway \u0026#39;192.168.2.1\u0026#39; option dns \u0026#39;8.8.8.8 114.114.114.114\u0026#39; 启动容器 docker run -d \u0026ndash;restart always \u0026ndash;name openwrt \u0026ndash;network macnet \u0026ndash;privileged \u0026ndash;ip 192.168.2.3 -v $(pwd)/network.conf:/etc/config/network -v $(pwd)/data:/var kiddin9_openwrt /sbin/init\n","date":"2024-05-25T09:33:09+08:00","permalink":"https://fanmain.github.io/post/nas/2024/dsm_docker_openwrt/","title":"Dsm_docker_openwrt"},{"content":" 京喜APP最早在2019年引入了Swift，使用Swift完成了第一个订单模块的开发。之后一年多我们持续在团队/公司内部推广和普及Swift，目前Swift已经支撑了70%+以上的业务。通过使用Swift提高了团队内同学的开发效率，同时也带来了质量的提升，目前来自Swift的Crash的占比不到1%。在这过程中不断的学习/实践，团队内的Code Review，也对如何使用Swift来提高代码质量有更深的理解。\n前言 京喜APP最早在2019年引入了Swift，使用Swift完成了第一个订单模块的开发。之后一年多我们持续在团队/公司内部推广和普及Swift，目前Swift已经支撑了70%+以上的业务。通过使用Swift提高了团队内同学的开发效率，同时也带来了质量的提升，目前来自Swift的Crash的占比不到1%。在这过程中不断的学习/实践，团队内的Code Review，也对如何使用Swift来提高代码质量有更深的理解。\nSwift特性 在讨论如何使用Swift提高代码质量之前，我们先来看看Swift本身相比ObjC或其他编程语言有什么优势。Swift有三个重要的特性分别是富有表现力/安全性/快速，接下来我们分别从这三个特性简单介绍一下：\n富有表现力 Swift提供更多的编程范式和特性支持，可以编写更少的代码，而且易于阅读和维护。\n基础类型 - 元组、Enum关联类型 方法 - 方法重载 protocol - 不限制只支持class、协议默认实现、类专属协议 泛型 - protocol关联类型、where实现类型约束、泛型扩展 可选值 - 可选值申明、可选链、隐式可选值 属性 - let、lazy、计算属性`、willset/didset、Property Wrappers 函数式编程 - 集合filter/map/reduce方法，提供更多标准库方法 并发 - async/await、actor 标准库框架 - Combine响应式框架、SwiftUI申明式UI框架、CodableJSON模型转换 Result builder - 描述实现DSL的能力 动态性 - dynamicCallable、dynamicMemberLookup 其他 - 扩展、subscript、操作符重写、嵌套类型、区间 Swift Package Manager - 基于Swift的包管理工具，可以直接用Xcode进行管理更方便 struct - 初始化方法自动补齐 类型推断 - 通过编译器强大的类型推断编写代码时可以减少很多类型申明 提示：类型推断同时也会增加一定的编译耗时，不过Swift团队也在不断的改善编译速度。\n安全性 代码安全 let属性 - 使用let申明常量避免被修改。 值类型 - 值类型可以避免在方法调用等参数传递过程中状态被修改。 访问控制 - 通过public和final限制模块外使用class不能被继承和重写。 强制异常处理 - 方法需要抛出异常时，需要申明为throw方法。当调用可能会throw异常的方法，需要强制捕获异常避免将异常暴露到上层。 模式匹配 - 通过模式匹配检测switch中未处理的case。 类型安全 强制类型转换 - 禁止隐式类型转换避免转换中带来的异常问题。同时类型转换不会带来额外的运行时消耗。。 提示：编写ObjC代码时，我们通常会在编码时添加类型检查避免运行时崩溃导致Crash。\nKeyPath - KeyPath相比使用字符串可以提供属性名和类型信息，可以利用编译器检查。 泛型 - 提供泛型和协议关联类型，可以编写出类型安全的代码。相比Any可以更多利用编译时检查发现类型问题。 Enum关联类型 - 通过给特定枚举指定类型避免使用Any。 内存安全 空安全 - 通过标识可选值避免空指针带来的异常问题 ARC - 使用自动内存管理避免手动管理内存带来的各种内存问题 强制初始化 - 变量使用前必须初始化 内存独占访问 - 通过编译器检查发现潜在的内存冲突问题 线程安全 值类型 - 更多使用值类型减少在多线程中遇到的数据竞争问题 async/await - 提供async函数使我们可以用结构化的方式编写并发操作。避免基于闭包的异步方式带来的内存循环引用和无法抛出异常的问题 Actor - 提供Actor模型避免多线程开发中进行数据共享时发生的数据竞争问题，同时避免在使用锁时带来的死锁等问题 快速 值类型 - 相比class不需要额外的堆内存分配/释放和更少的内存消耗 方法静态派发 - 方法调用支持静态调用相比原有ObjC消息转发调用性能更好 编译器优化 - Swift的静态性可以使编译器做更多优化。例如Tree Shaking相关优化移除未使用的类型/方法等减少二进制文件大小。使用静态派发/方法内联优化/泛型特化/写时复制等优化提高运行时性能 提示：ObjC消息派发会导致编译器无法进行移除无用方法/类的优化，编译器并不知道是否可能被用到。\nARC优化 - 虽然和ObjC一样都是使用ARC，Swift通过编译器优化，可以进行更快的内存回收和更少的内存引用计数管理 提示： 相比ObjC，Swift内部不需要使用autorelease进行管理。\n代码质量指标 以上是一些常见的代码质量指标。我们的目标是如何更好的使用Swift编写出符合代码质量指标要求的代码。\n提示：本文不涉及设计模式/架构，更多关注如何通过合理使用Swift特性做局部代码段的重构。\n一些不错的实践 利用编译检查 减少使用Any/AnyObject 因为Any/AnyObject缺少明确的类型信息，编译器无法进行类型检查，会带来一些问题：\n编译器无法检查类型是否正确保证类型安全 代码中大量的as?转换 类型的缺失导致编译器无法做一些潜在的编译优化 使用as?带来的问题\n当使用Any/AnyObject时会频繁使用as?进行类型转换。这好像没什么问题因为使用as?并不会导致程序Crash。不过代码错误至少应该分为两类，一类是程序本身的错误通常会引发Crash，另外一种是业务逻辑错误。使用as?只是避免了程序错误Crash，但是并不能防止业务逻辑错误。\nfunc do(data: Any?) { guard let string = data as? String else { return } // } do(1) do(\u0026#34;\u0026#34;) 以上面的例子为例，我们进行了as?转换，当data为String时才会进行处理。但是当do方法内String类型发生了改变函数，使用方并不知道已变更没有做相应的适配，这时候就会造成业务逻辑的错误。\n提示：这类错误通常更难发现，这也是我们在一次真实bug场景遇到的。\n使用自定义类型代替Dictionary 代码中大量Dictionary数据结构会降低代码可维护性，同时带来潜在的bug：\nkey需要字符串硬编码，编译时无法检查 value没有类型限制。修改时类型无法限制，读取时需要重复类型转换和解包操作 无法利用空安全特性，指定某个属性必须有值 提示：自定义类型还有个好处，例如JSON转自定义类型时会进行类型/nil/属性名检查，可以避免将错误数据丢到下一层。\n不推荐\nlet dic: [String: Any] let num = dic[\u0026#34;value\u0026#34;] as? Int dic[\u0026#34;name\u0026#34;] = \u0026#34;name\u0026#34; 推荐\nstruct Data { let num: Int var name: String? } let num = data.num data.name = \u0026#34;name\u0026#34; 适合使用Dictionary的场景\n数据不使用 - 数据并不读取只是用来传递。 解耦 - 1.组件间通信解耦使用HashMap传递参数进行通信。2.跨技术栈边界的场景，混合栈间通信/前后端通信使用HashMap/JSON进行通信。 使用枚举关联值代替Any 例如使用枚举改造NSAttributedStringAPI，原有APIvalue为Any类型无法限制特定的类型。\n优化前\nlet string = NSMutableAttributedString() string.addAttribute(.foregroundColor, value: UIColor.red, range: range) 改造后\nenum NSAttributedStringKey { case foregroundColor(UIColor) } let string = NSMutableAttributedString() string.addAttribute(.foregroundColor(UIColor.red), range: range) // 不传递Color会报错 使用泛型/协议关联类型代替Any 使用泛型或协议关联类型代替Any，通过泛型类型约束来使编译器进行更多的类型检查。\n使用枚举/常量代替硬编码 代码中存在重复的硬编码字符串/数字，在修改时可能会因为不同步引发bug。尽可能减少硬编码字符串/数字，使用枚举或常量代替。\n使用KeyPath代替字符串硬编码 KeyPath包含属性名和类型信息，可以避免硬编码字符串，同时当属性名或类型改变时编译器会进行检查。\n不推荐\nclass SomeClass: NSObject { @objc dynamic var someProperty: Int init(someProperty: Int) { self.someProperty = someProperty } } let object = SomeClass(someProperty: 10) object.observeValue(forKeyPath: \u0026#34;\u0026#34;, of: nil, change: nil, context: nil) 推荐\nlet object = SomeClass(someProperty: 10) object.observe(.someProperty) { object, change in } 内存安全 减少使用!属性 !属性会在读取时隐式强解包，当值不存在时产生运行时异常导致Crash。\nclass ViewController: UIViewController { @IBOutlet private var label: UILabel! // @IBOutlet需要使用! } 减少使用!进行强解包 使用!强解包会在值不存在时产生运行时异常导致Crash。\nvar num: Int? let num2 = num! // 错误 提示：建议只在小范围的局部代码段使用!强解包。\n避免使用try!进行错误处理 使用try!会在方法抛出异常时产生运行时异常导致Crash。\ntry! method() 使用weak/unowned避免循环引用 resource.request().onComplete { [weak self] response in guard let self = self else { return } let model = self.updateModel(response) self.updateUI(model) } resource.request().onComplete { [unowned self] response in let model = self.updateModel(response) self.updateUI(model) } 减少使用unowned unowned在值不存在时会产生运行时异常导致Crash，只有在确定self一定会存在时才使用unowned。\nclass Class { @objc unowned var object: Object @objc weak var object: Object? } unowned/weak区别：\nweak - 必须设置为可选值，会进行弱引用处理性能更差。会自动设置为nil unowned - 可以不设置为可选值，不会进行弱引用处理性能更好。但是不会自动设置为nil, 如果self已释放会触发错误. 错误处理方式 可选值 - 调用方并不关注内部可能会发生错误，当发生错误时返回nil try/catch - 明确提示调用方需要处理异常，需要实现Error协议定义明确的错误类型 assert - 断言。只能在Debug模式下生效 precondition - 和assert类似，可以再Debug/Release模式下生效 fatalError - 产生运行时崩溃会导致Crash，应避免使用 Result - 通常用于闭包异步回调返回值 减少使用可选值 可选值的价值在于通过明确标识值可能会为nil并且编译器强制对值进行nil判断。但是不应该随意的定义可选值，可选值不能用let定义，并且使用时必须进行解包操作相对比较繁琐。在代码设计时应考虑这个值是否有可能为nil，只在合适的场景使用可选值。\n使用init注入代替可选值属性 不推荐\nclass Object { var num: Int? } let object = Object() object.num = 1 推荐\nclass Object { let num: Int init(num: Int) { self.num = num } } let object = Object(num: 1) 避免随意给予可选值默认值 在使用可选值时，通常我们需要在可选值为nil时进行异常处理。有时候我们会通过给予可选值默认值的方式来处理。但是这里应考虑在什么场景下可以给予默认值。在不能给予默认值的场景应当及时使用return或抛出异常，避免错误的值被传递到更多的业务流程。\n不推荐\nfunc confirmOrder(id: String) {} // 给予错误的值会导致错误的值被传递到更多的业务流程 confirmOrder(id: orderId ?? \u0026#34;\u0026#34;) 推荐\nfunc confirmOrder(id: String) {} guard let orderId = orderId else { // 异常处理 return } confirmOrder(id: orderId) 提示：通常强业务相关的值不能给予默认值：例如商品/订单id或是价格。在可以使用兜底逻辑的场景使用默认值，例如默认文字/文字颜色。\n使用枚举优化可选值 Object结构同时只会有一个值存在：\n优化前\nclass Object { var name: Int? var num: Int? } 优化后\n降低内存占用 - 枚举关联类型的大小取决于最大的关联类型大小 逻辑更清晰 - 使用enum相比大量使用if/else逻辑更清晰 enum CustomType { case name(String) case num(Int) } 减少var属性 使用计算属性 使用计算属性可以减少多个变量同步带来的潜在bug。\n不推荐\nclass model { var data: Object? var loaded: Bool } model.data = Object() loaded = false 推荐\nclass model { var data: Object? var loaded: Bool { return data != nil } } model.data = Object() 提示：计算属性因为每次都会重复计算，所以计算过程需要轻量避免带来性能问题。\n控制流 使用filter/reduce/map代替for循环 使用filter/reduce/map可以带来很多好处，包括更少的局部变量，减少模板代码，代码更加清晰，可读性更高。\n不推荐\nlet nums = [1, 2, 3] var result = [] for num in nums { if num \u0026lt; 3 { result.append(String(num)) } } // result = [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;] 推荐\nlet nums = [1, 2, 3] let result = nums.filter { $0 \u0026lt; 3 }.map { String($0) } // result = [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;] 使用guard进行提前返回 推荐\nguard !a else { return } guard !b else { return } // do 不推荐\nif a { if b { // do } } 使用三元运算符?: 推荐\nlet b = true let a = b ? 1 : 2 let c: Int? let b = c ?? 1 不推荐\nvar a: Int? if b { a = 1 } else { a = 2 } 使用for where优化循环 for循环添加where语句，只有当where条件满足时才会进入循环\n不推荐\nfor item in collection { if item.hasProperty { // ... } } 推荐\nfor item in collection where item.hasProperty { // item.hasProperty == true，才会进入循环 } 使用defer defer可以保证在函数退出前一定会执行。可以使用defer中实现退出时一定会执行的操作例如资源释放等避免遗漏。\nfunc method() { lock.lock() defer { lock.unlock() // 会在method作用域结束的时候调用 } // do } 字符串 使用\u0026quot;\u0026quot;\u0026quot; 在定义复杂字符串时，使用多行字符串字面量可以保持原有字符串的换行符号/引号等特殊字符，不需要使用``进行转义。\nlet quotation = \u0026#34;\u0026#34;\u0026#34; The White Rabbit put on his spectacles. \u0026#34;Where shall I begin, please your Majesty?\u0026#34; he asked. \u0026#34;Begin at the beginning,\u0026#34; the King said gravely, \u0026#34;and go on till you come to the end; then stop.\u0026#34; \u0026#34;\u0026#34;\u0026#34; 提示：上面字符串中的\u0026quot;\u0026quot;和换行可以自动保留。\n使用字符串插值 使用字符串插值可以提高代码可读性。\n不推荐\nlet multiplier = 3 let message = String(multiplier) + \u0026#34;times 2.5 is\u0026#34; + String((Double(multiplier) * 2.5)) 推荐\nlet multiplier = 3 let message = \u0026#34;(multiplier) times 2.5 is (Double(multiplier) * 2.5)\u0026#34; 集合 使用标准库提供的高阶函数 不推荐\nvar nums = [] nums.count == 0 nums[0] 推荐\nvar nums = [] nums.isEmpty nums.first 访问控制 Swift中默认访问控制级别为internal。编码中应当尽可能减小属性/方法/类型的访问控制级别隐藏内部实现。\n提示：同时也有利于编译器进行优化。\n使用private/fileprivate修饰私有属性和方法 private let num = 1 class MyClass { private var num: Int } 使用private(set)修饰外部只读/内部可读写属性 class MyClass { private(set) var num = 1 } let num = MyClass().num MyClass().num = 2 // 会编译报错 函数 使用参数默认值 使用参数默认值，可以使调用方传递更少的参数。\n不推荐\nfunc test(a: Int, b: String?, c: Int?) { } test(1, nil, nil) 推荐\nfunc test(a: Int, b: String? = nil, c: Int? = nil) { } test(1) 提示：相比ObjC，参数默认值也可以让我们定义更少的方法。\n限制参数数量 当方法参数过多时考虑使用自定义类型代替。\n不推荐\nfunc f(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int) { } 推荐\nstruct Params { let a, b, c, d, e, f: Int } func f(params: Params) { } 使用@discardableResult 某些方法使用方并不一定会处理返回值，可以考虑添加@discardableResult标识提示Xcode允许不处理返回值不进行warning提示。\n// 上报方法使用方不关心是否成功 func report(id: String) -\u0026gt; Bool {} @discardableResult func report2(id: String) -\u0026gt; Bool {} report(\u0026#34;1\u0026#34;) // 编译器会警告 report2(\u0026#34;1\u0026#34;) // 不处理返回值编译器不会警告 元组 避免过长的元组 元组虽然具有类型信息，但是并不包含变量名信息，使用方并不清晰知道变量的含义。所以当元组数量过多时考虑使用自定义类型代替。\nfunc test() -\u0026gt; (Int, Int, Int) { } let (a, b, c) = test() // a，b，c类型一致，没有命名信息不清楚每个变量的含义 系统库 KVO/Notification 使用 block API block API的优势：\nKVO 可以支持 KeyPath 不需要主动移除监听，observer释放时自动移除监听 不推荐\nclass Object: NSObject { init() { super.init() addObserver(self, forKeyPath: \u0026#34;value\u0026#34;, options: .new, context: nil) NotificationCenter.default.addObserver(self, selector: #selector(test), name: NSNotification.Name(rawValue: \u0026#34;\u0026#34;), object: nil) } override class func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) { } @objc private func test() { } deinit { removeObserver(self, forKeyPath: \u0026#34;value\u0026#34;) NotificationCenter.default.removeObserver(self) } } 推荐\nclass Object: NSObject { private var observer: AnyObserver? private var kvoObserver: NSKeyValueObservation? init() { super.init() observer = NotificationCenter.default.addObserver(forName: NSNotification.Name(rawValue: \u0026#34;\u0026#34;), object: nil, queue: nil) { (_) in } kvoObserver = foo.observe(.value, options: [.new]) { (foo, change) in } } } Protocol 使用protocol代替继承 Swift中针对protocol提供了很多新特性，例如默认实现，关联类型，支持值类型。在代码设计时可以优先考虑使用protocol来避免臃肿的父类同时更多使用值类型。\n提示：一些无法用protocol替代继承的场景：1.需要继承NSObject子类。2.需要调用super方法。3.实现抽象类的能力。\nExtension 使用extension组织代码 使用extension将私有方法/父类方法/协议方法等不同功能代码进行分离更加清晰/易维护。\nclass MyViewController: UIViewController { // class stuff here } // MARK: - Private extension: MyViewController { private func method() {} } // MARK: - UITableViewDataSource extension MyViewController: UITableViewDataSource { // table view data source methods } // MARK: - UIScrollViewDelegate extension MyViewController: UIScrollViewDelegate { // scroll view delegate methods } 代码风格 良好的代码风格可以提高代码的可读性，统一的代码风格可以降低团队内相互理解成本。对于Swift的代码格式化建议使用自动格式化工具实现，将自动格式化添加到代码提交流程，通过定义Lint规则统一团队内代码风格。考虑使用SwiftFormat和SwiftLint。\n提示：SwiftFormat主要关注代码样式的格式化，SwiftLint可以使用autocorrect自动修复部分不规范的代码。\n常见的自动格式化修正\n移除多余的; 最多只保留一行换行 自动对齐空格 限制每行的宽度自动换行 性能优化 性能优化上主要关注提高运行时性能和降低二进制体积。需要考虑如何更好的使用Swift特性，同时提供更多信息给编译器进行优化。\n使用Whole Module Optimization 当Xcode开启WMO优化时，编译器可以将整个程序编译为一个文件进行更多的优化。例如通过推断final/函数内联/泛型特化更多使用静态派发，并且可以移除部分未使用的代码。\n使用源代码打包 当我们使用组件化时，为了提高编译速度和打包效率，通常单个组件独立编译生成静态库，最后多个组件直接使用静态库进行打包。这种场景下WMO仅针对internal以内作用域生效，对于public/open缺少外部使用信息所以无法进行优化。所以对于大量使用Swift的项目，使用全量代码打包更有利于编译器做更多优化。\n减少方法动态派发 使用final - class/方法/属性申明为final，编译器可以优化为静态派发 使用private - 方法/属性申明为private，编译器可以优化为静态派发 避免使用dynamic - dynamic会使方法通过ObjC消息转发的方式派发 使用WMO - 编译器可以自动分析推断出final优化为静态派发 使用Slice共享内存优化性能 在使用Array/String时，可以使用Slice切片获取一部分数据。Slice保存对原始Array/String的引用共享内存数据，不需要重新分配空间进行存储。\nlet midpoint = absences.count / 2 let firstHalf = absences[.. `提示：应避免一直持有Slice，Slice会延长原始Array/String的生命周期导致无法被释放造成内存泄漏。\nprotocol添加AnyObject protocol AnyProtocol {}\nprotocol ObjectProtocol: AnyObject {}\n当protocol仅限制为class使用时，继承AnyObject协议可以使编译器不需要考虑值类型实现，提高运行时性能。\n使用@inlinable进行方法内联优化 // 原始代码 let label = UILabel().then { 0.textAlignment=.center0.textColor = UIColor.black $0.text = \u0026ldquo;Hello, World!\u0026rdquo; }\n以then库为例，他使用闭包进行对象初始化以后的相关设置。但是 then 方法以及闭包也会带来额外的性能消耗。\n内联优化 @inlinable public func then(_ block: (Self) throws -\u0026gt; Void) rethrows -\u0026gt; Self { try block(self) return self }\n// 编译器内联优化后 let label = UILabel() label.textAlignment = .center label.textColor = UIColor.black label.text = \u0026ldquo;Hello, World!\u0026rdquo;\n属性 使用lazy延时初始化属性 class View { var lazy label: UILabel = { let label = UILabel() self.addSubView(label) return label }() }\nlazy属性初始化会延迟到第一次使用时，常见的使用场景：\n初始化比较耗时\n可能不会被使用到\n初始化过程需要使用self\n提示：lazy属性不能保证线程安全\n避免使用private let属性\nprivate let属性会增加每个class对象的内存大小。同时会增加包大小，因为需要为属性生成相关的信息。可以考虑使用文件级private let申明或static常量代替。\n不推荐 class Object { private let title = \u0026ldquo;12345\u0026rdquo; }\n推荐 private let title = \u0026ldquo;12345\u0026rdquo; class Object { static let title = \u0026quot;\u0026quot; }\n提示：这里并不包括通过init初始化注入的属性。\n使用didSet/willSet时进行Diff\n某些场景需要使用didSet/willSet属性检查器监控属性变化，做一些额外的计算。但是由于didSet/willSet并不会检查新/旧值是否相同，可以考虑添加新/旧值判断，只有当值真的改变时才进行运算提高性能。\n优化前 class Object { var orderId: String? { didSet { // 拉取接口等操作 } } }\n例如上面的例子，当每一次orderId变更时需要重新拉取当前订单的数据，但是当orderId值一样时，拉取订单数据是无效执行。\n优化后 class Object { var orderId: String? { didSet { // 判断新旧值是否相等 guard oldValue != orderId else { return } // 拉取接口等操作 } } }\n集合 集合使用lazy延迟序列 var nums = [1, 2, 3] var result = nums.lazy.map { String($0) } result[0] // 对1进行map操作 result[1] // 对2进行map操作\n在集合操作时使用lazy，可以将数组运算操作推迟到第一次使用时，避免一次性全部计算。\n提示：例如长列表，我们需要创建每个cell对应的视图模型，一次性创建太耗费时间。\n使用合适的集合方法优化性能 不推荐 var items = [1, 2, 3] items.filter({ $0 \u0026gt; 1 }).first // 查找出所有大于1的元素，之后找出第一个\n推荐 var items = [1, 2, 3] items.first(where: { $0 \u0026gt; 1 }) // 查找出第一个大于1的元素直接返回\n使用值类型\nSwift中的值类型主要是结构体/枚举/元组。\n启动性能 - APP启动时值类型没有额外的消耗，class有一定额外的消耗。\n运行时性能- 值类型不需要在堆上分配空间/额外的引用计数管理。更少的内存占用和更快的性能。\n包大小 - 相比class，值类型不需要创建ObjC类对应的ro_data_t数据结构。\n提示：class即使没有继承NSObject也会生成ro_data_t，里面包含了ivars属性信息。如果属性/方法申明为@objc还会生成对应的方法列表。\n提示：struct无法代替class的一些场景：1.需要使用继承调用super。2.需要使用引用类型。3.需要使用deinit。4.需要在运行时动态转换一个实例的类型。\n提示：不是所有struct都会保存在栈上，部分数据大的struct也会保存在堆上。\n集合元素使用值类型\n集合元素使用值类型。因为NSArray并不支持值类型，编译器不需要处理可能需要桥接到NSArray的场景，可以移除部分消耗。\n纯静态类型避免使用class\n当class只包含静态方法/属性时，考虑使用enum代替class，因为class会生成更多的二进制代码。\n不推荐 class Object { static var num: Int static func test() {} }\n推荐 enum Object { static var num: Int static func test() {} }\n提示：为什么用enum而不是struct，因为struct会额外生成init方法。\n值类型性能优化 考虑使用引用类型\n值类型为了维持值语义，会在每次赋值/参数传递/修改时进行复制。虽然编译器本身会做一些优化，例如写时复制优化，在修改时减少复制频率，但是这仅针对于标准库提供的集合和String结构有效，对于自定义结构需要自己实现。对于参数传递编译器在一些场景会优化为直接传递引用的方式避免复制行为。\n但是对于一些数据特别大的结构，同时需要频繁变更修改时也可以考虑使用引用类型实现。\n使用inout传递参数减少复制\n虽然编译器本身会进行写时复制的优化，但是部分场景编译器无法处理。\n不推荐 func append_one(_ a: [Int]) -\u0026gt; [Int] { var a = a a.append(1) // 无法被编译器优化，因为这时候有2个引用持有数组 return a }\nvar a = [1, 2, 3] a = append_one(a)\n推荐\n直接使用inout传递参数\nfunc append_one_in_place(a: inout [Int]) { a.append(1) }\nvar a = [1, 2, 3] append_one_in_place(\u0026amp;a)\n使用isKnownUniquelyReferenced实现写时复制\n默认情况下结构体中包含引用类型，在修改时只会重新拷贝引用。但是我们希望CustomData具备值类型的特性，所以当修改时需要重新复制NSMutableData避免复用。但是复制操作本身是耗时操作，我们希望可以减少一些不必要的复制。\n优化前 struct CustomData { fileprivate var _data: NSMutableData var _dataForWriting: NSMutableData { mutating get { _data = _data.mutableCopy() as! NSMutableData return data } } init( data: NSData) { self._data = data.mutableCopy() as! NSMutableData }\nmutating func append(_ other: MyData) { _dataForWriting.append(other._data as Data) } }\nvar buffer = CustomData(NSData()) for _ in 0..\u0026lt;5 { buffer.append(x) // 每一次调用都会复制 }\n优化后\n使用isKnownUniquelyReferenced检查如果是唯一引用不进行复制。\nfinal class Box { var unbox: A init(_ value: A) { self.unbox = value } }\nstruct CustomData { fileprivate var _data: Box var _dataForWriting: NSMutableData { mutating get { // 检查引用是否唯一 if !isKnownUniquelyReferenced(\u0026amp;_data) { _data = Box(_data.unbox.mutableCopy() as! NSMutableData) } return data.unbox } } init( data: NSData) { self._data = Box(data.mutableCopy() as! NSMutableData) } }\nvar buffer = CustomData(NSData()) for _ in 0..\u0026lt;5 { buffer.append(x) // 只会在第一次调用时进行复制 }\n提示：对于ObjC类型isKnownUniquelyReferenced会直接返回false。\n减少使用Objc特性 避免使用Objc类型\n尽可能避免在Swift中使用NSString/NSArray/NSDictionary等ObjC基础类型。以Dictionary为例，虽然Swift Runtime可以在NSArray和Array之间进行隐式桥接需要O(1)的时间。但是字典当Key和Value既不是类也不是@objc协议时，需要对每个值进行桥接，可能会导致消耗O(n)时间。\n减少添加@objc标识\n@objc标识虽然不会强制使用消息转发的方式来调用方法/属性，但是他会默认ObjC是可见的会生成和ObjC一样的ro_data_t结构。\n避免使用@objcMembers\n使用@objcMembers修饰的类，默认会为类/属性/方法/扩展都加上@objc标识。\n@objcMembers class Object: NSObject { }\n提示：你也可以使用@nonobjc取消支持ObjC。\n避免继承NSObject\n你只需要在需要使用NSObject特性时才需要继承，例如需要实现UITableViewDataSource相关协议。\n使用let变量/属性 优化集合创建\n集合不需要修改时，使用let修饰，编译器会优化创建集合的性能。例如针对let集合，编译器在创建时可以分配更小的内存大小。\n优化逃逸闭包\n在Swift中，当捕获var变量时编译器需要生成一个在堆上的Box保存变量用于之后对于变量的读/写，同时需要额外的内存管理操作。如果是let变量，编译器可以保存值复制或引用，避免使用Box。\n避免使用大型struct使用class代替\n大型struct通常是指属性特别多并且嵌套类型很多。目前swift编译器针对struct等值类型编译优化处理的并不好，会生成大量的assignWithCopy、assignWithCopy等copy相关方法，生成大量的二进制代码。使用class类型可以避免生成相关的copy方法。\n提示：不要小看这部分二进制的影响，个人在日常项目中遇到过复杂的大型struct能生成几百KB的二进制代码。但是目前并没有好的方法去发现这类struct去做优化，只能通过相关工具去查看生成的二进制详细信息。希望官方可以早点优化。\n优先使用Encodable/Decodable协议代替Codable\n因为实现Encodable和Decodable协议的结构，编译器在编译时会自动生成对应的init(from decoder: Decoder)和encode(to: Encoder)方法。Codable同时实现了Encodable和Decodable协议，但是大部分场景下我们只需要encode或decode能力，所以明确指定实现Encodable或Decodable协议可以减少生成对应的方法减少包体积。\n提示：对于属性比较多的类型结构会产生很大的二进制代码，有兴趣可以用相关的工具看看生成的二进制文件。\n减少使用Equatable协议\n因为实现Equatable协议的结构，编译器在编译时会自动生成对应的equal方法。默认实现是针对所有字段进行比较会生成大量的代码。所以当我们不需要实现==比较能力时不要实现Equatable或者对于属性特别多的类型也可以考虑重写Equatable协议，只针对部分属性进行比较，这样可以生成更少的代码减少包体积。\n提示：对于属性特别多的类型也可以考虑重写Equatable协议，只针对部分属性进行比较，同时也可以提升性能。\n总结 个人从Swift3.0开始将Swift作为第一语言使用。编写Swift代码并不只是简单对于ObjC代码的翻译/重写，需要对于Swift特性更多的理解才能更好的利用这些特性带来更多的收益。同时我们需要关注每个版本Swift的优化/改进和新特性。在这过程中也会提高我们的编码能力，加深对于一些通用编程概念/思想的理解，包括空安全、值类型、协程、不共享数据的Actor并发模型、函数式编程、面向协议编程、内存所有权等。对于新的现代编程语言例如Swift/Dart/TS/Kotlin/Rust等，很多特性/思想都是相互借鉴，当我们理解这些概念/思想以后对于理解其他语言也会更容易。\n这里推荐有兴趣可以关注Swift Evolution，每个特性加入都会有一个提案，里面会详细介绍动机/使用场景/实现方式/未来方向。\n扩展链接 The Swift Programming Language\nSwift 进阶\nSwiftLint Rules\nOptimizationTips\n深入剖析Swift性能优化\nGoogle Swift Style Guide\nSwift Evolution\nDictionary\nArray\nString\nstruct`\n标签: Swift , 代码质量\n好文要顶 关注我 收藏该文 微信分享\n京东云开发者\n粉丝 - 375 关注 - 1\n+加关注\n0\n0\n升级成为会员\ncurrentDiggType = 0;\n« 上一篇： 从原理到应用，人人都懂的ChatGPT指南\n» 下一篇： Webpack5构建性能优化：构建耗时从150s到60s再到10s\n","date":"2024-05-16T14:29:25+08:00","permalink":"https://fanmain.github.io/post/ios/2024/04_swifttip/","title":"04_swiftTip"},{"content":"UnityShader数学基础篇 Mathf Mathf和Math 1、Math是C#中封装好的用于数学计算的工具类，位于System命名空间中。\n2、Mathf是Unity中封装好的用于数学计算的工具结构体，位于UnityEngine命名空间中。\nMathf中的常用方法 1.π - PI\nprint(Mathf.PI);\n2.取绝对值 - Abs\nprint(Mathf.Abs(-10.5f));//10.5 print(Mathf.Abs(-86));//86 3.向上取整 - CeilToInt\nprint(Mathf.CeilToInt(1.001f));//2 print(Mathf.CeilToInt(5.6f));//6 4.向下取整 - FloorToInt\nprint(Mathf.FloorToInt(2.999f));//2 print(Mathf.FloorToInt(1.04f));//1 5.钳制函数 - Clamp (传入的数据 ，数据传出最小值 ，数据传出最大值)\nint num = 18； print(Mathf.Clamp(num, 13, 32));//13 print(Mathf.Clamp(num, 13, 32));//32 print(Mathf.Clamp(num, 13, 32));//18 6.获取最大值 - Max\nint[] ints = new int[5] {5,9,78,65,23}; print(Mathf.Max(1, 5, 6, 8, 9, 45));//45 print(Mathf.Max(ints));//78 7.获取最小值 - Min\nint[] ints2 = new int[5] {-1,5,86,411,20}; print(Mathf.Min(ints2));//-1 print(Mathf.Min(1.2f,5,65,0.86f));//0.86 8.一个数的n次幂 - Pow\nprint(\u0026#34;2的6次方\u0026#34; + Mathf.Pow(2, 6));//64 print(\u0026#34;3的4次方\u0026#34; + Mathf.Pow(3, 4));//81 9.四舍五入 - RoundToInt\nprint(\u0026#34;四舍五入\u0026#34; + Mathf.RoundToInt(4.6f));//5 print(\u0026#34;四舍五入\u0026#34; + Mathf.RoundToInt(4.3f));//4 10.返回一个数的平方根 - Sqrt\nprint(\u0026#34;平方根\u0026#34; + Mathf.Sqrt(4));//2 print(\u0026#34;平方根\u0026#34; + Mathf.Sqrt(9));//3 11.判断一个数是否是2的n次方 - IsPowerOfTwo\nprint(\u0026#34;11:\u0026#34; + Mathf.IsPowerOfTwo(8));//ture print(\u0026#34;11:\u0026#34; + Mathf.IsPowerOfTwo(9));//false 12.判断正负数 - Sign\nprint(\u0026#34;判断正负数\u0026#34; + Mathf.Sign(1));//1 print(\u0026#34;判断正负数\u0026#34; + Mathf.Sign(-2));//-1 13.插值运算 - Lerp\n1、Lerp函数公式：result = Mathf.Lerp(start, end, t);\n2、t为插值系数,取值范围为0~1：result = start + (end - start)*t\nfloat start = 0; float result = 0; float time = 0; void Update() { //插值运算用法一 //每帧改变start的值一变化速度先快后慢,位置无限接近,但是不会得到end位置 start = Mathf.Lerp(start,10,Time.deltaTime); //插值运算用法二 //每帧改变t的值一变化速度匀速,位置每帧result接近end,当t\u0026gt;=1时,得到结果 time += Time.deltaTime; result = Mathf.Lerp(start,10,time); } 三角函数 Unity中都是弧度值，让物体曲线移动。\n弧度(radian)、角度相互转化 1、1 rad = (180/π)°=\u0026gt; 1 rad = (180/3.14)°= 57.3°\n2、弧度转角度：弧度 * 57.3 = 对应的角度\n3、Mathf.Rad2Deg\nfloat rad = 1; float anger = rad * Mathf.Rad2Deg; print(anger);//57.3 1、1°= (π/180)rad =\u0026gt; 1°= (3.14/180)rad = 0.01745 rad\n2、角度转弧度：角度 * 0.01745 = 对应的弧度\n3、Mathf.Deg2Rad\nanger = 1; rad = anger * Mathf.Deg2Rad; print(rad);//0.01745 三角函数 **注意:**Mathf中的三角函数相关函数,传入的参数需要弧度值\nSin() Cos()\nprint(Mathf.Sin(30 * Mathf.Deg2Rad));//1/2 print(Mathf.Cos(30 * Mathf.Deg2Rad));//sqrt3/2 print(Mathf.Sin(30f));//1/2 反三角函数 **注意:**反三角函数得到的结果是正弦或者余弦值对应的弧度值\nAsin() Acos()\nprint(Mathf.Asin(0.5f) * Mathf.Rad2Deg);//30 print(Mathf.Acos(0.5f) * Mathf.Rad2Deg);//60 Unity坐标系 世界坐标系 transform.position transform.rotation transform.eulerAngles transform.lossyScale 物体坐标系 1、相对父对象的物体坐标系的位置 本地坐标 相对坐标\n2、修改他们会是相对父对象物体坐标系的变化\ntransform.localPosition; transform.localRotation; transform.localEulerAngles; transform.localScale; 屏幕坐标系 Input.mousePosition; Screen.width; Screen.height; 坐标转换 //世界转本地 transform.InverseTransformDirection(Direction); //不受缩放影响（向量） transform.InverseTransformVector(Vector); //受缩放影响 transform.InverseTransformPoint(pos); //本地转世界 transform.TransformDirection(localDirection); transform.TransformVector(localVector); transform.TransformPoint(localPos); //世界转屏幕 Camera.main.WorldToScreenPoint(pos); //屏幕转世界 Camera.main.ScreenToWorldPoint(ScreenPos); //世界转视口 Camera.main.WorldToViewportPoint(pos); //视口转世界 Camera.main.ViewportToWorldPoint(ViewportPos); //视口转屏幕 Camera.main.ViewportToScreenPoint(ViewportPos); //屏幕转视口 Camera.main.ScreenToViewportPoint(ScreenPos); 向量 1、Vector3这边变量 可以表示一个点 也可以表示一个向量 具体表示什么 是根据我们的具体需求和逻辑决定。\n2、如何在Unity里面得到向量，终点减起点，就可以得到向量。点C也可以代表向量，代表的就是oc向量，o是坐标系原点。\n3、得到了向量就可以利用vector3中提供的成员属性，得到模长和单位向量。\n4、模长相当于可以得到两点之间的距离，单位向量主要是用来进行移动计算的它不会影响我们想要的移动效果。\nVector3 A = new Vector3(1, 2, 3); Vector3 B = new Vector3(5, 4, 7); //两点向量 Vector3 AB = B - A; Vector3 BA = A - B; //两个物体之间的向量 Vector3 Vec = Object .position - transform.position; //magnitude 向量的模长 print(Vec.magnitude); print(Vector3.Distance(Object.position, transform.position)); //单位向量 normalized print(Vec.normalized); print(Vec / Vec.magnitude); 向量加减乘除运算 #region 知识点一 向量加法 transform.position += new Vector3(1, 2, 3); #endregion #region 知识点二 向量减法 transform.position -= new Vector3(1,2,3); #endregion #region 知识点三 向量乘除标量 放大缩小n倍 transform.localScale *= 2; transform.localScale /= 2; #endregion 向量点乘(dot product) **公式一：**A•B = (a1,b1,c1)•(a2,b2,c2) = a1a2 + b1b2 +c1c3\n**公式二：**A•B = |A||B|cosβ\n几何意义：投影，判断前后\n求角度：\n#region 知识点一 通过点乘判断对象的方位 //Vector3 提供了计算点乘的方法 Debug.DrawRay(transform.position, transform.forward, Color.blue); Debug.DrawRay(transform.position, Target.position - transform.position, Color.green); if (Vector3.Dot(transform.forward, Target.position - transform.position) \u0026gt;= 0) { print(\u0026#34;目标在前方\u0026#34;); } else print(\u0026#34;目标在后方\u0026#34;); #endregion #region 知识点二 通过点乘推导公式算出夹角 //公式: 角度 = Acos（单位向量 • 单位向量） //1、用单位向量算出点乘结果 float DotResult = Vector3.Dot(transform.forward, (Target.position - transform.position).normalized); //2、用反三角函数得出弧度,然后转为角度 print(\u0026#34;角度：\u0026#34; + Mathf.Acos(DotResult) * Mathf.Rad2Deg); //Vector3中提供了 得到两个向量之间夹角的方法 print(\u0026#34;角度：\u0026#34; + Vector3.Angle(transform.forward, Target.position - transform.position)); //作用 //怪物范围检测 角度范围内检测 #endregion 向量叉乘(cross product) 公式：\n模计算：|a×b|=|a||b|sinθ，平行四边形面积计算\n几何意义：判断左右、法向量，三角形面片朝向\n#region 知识点一 叉乘计算 print(Vector3.Cross(A.position, B.position).normalized); #endregion if (Vector3.Cross(A.position, B.position).y \u0026gt; 0) print(\u0026#34;B在A的左边\u0026#34;); else print(\u0026#34;B在A的右边\u0026#34;); 矩阵乘法 矩阵概念 矩阵的结构是由 m x n 个标量组成。\n在程序中，我们用于存储矩阵结构的容器类型有很多选择，最常见的的为：\n1、数组（一维、二维都可以）\n2、嵌套列表（两个List嵌套）\n3、开发工具提供的类或结构体（Unity中的Matrix4x4、Matrix3x2结构体）\n矩阵和标量的乘法 矩阵(M)中的每一个标量和标量(k)相乘即可\n矩阵和矩阵的乘法 1、首先需要判断两个矩阵是否能够相乘\n**判断条件：**左列右行要相等\n2、A和B两个矩阵，AB两个矩阵相乘的结果是C矩阵。\n那么C(11) = A(1n).B(n1)、C(12) = A(1n).B(n2)、C(13) = A(1n).B(n3)\n**解读：**C矩阵中的第一行第一列的值等于A中第一行点乘B中第一列。\n矩阵之间的乘法 1、不满足交换律\nAB ≠ BA\n2、满足结合律\n(AB)C = A(BC)\nABCDE = (AB)(CD)E = A((BC)D)E\n特殊矩阵 方块矩阵 —— 行列数相等的矩阵。 对角矩阵 —— 只有主对角线有值，其余元素全为零的方阵。 单位矩阵 —— 主对角线上的元素均为1 的对角矩阵。 数量矩阵 —— 主对角线上的元素为同一值的对角矩阵。 转置矩阵 —— 将原始矩阵的行和列互换得到的新矩阵。 矩阵转置的转置等于原矩阵 (MT)T = M 矩阵串接的转置，等于反向串接各个矩阵的转置 (AB)T =BTAT 逆矩阵 逆矩阵必须是一个方阵，并且不是所有矩阵都有逆矩阵。 假设一个方阵 M ，它的逆矩阵用 M-1 表示。 那么存在 MM-1 = M-1M = E（单位矩阵） 如果一个矩阵存在对应的逆矩阵，我们就说该矩阵是可逆的（或称非奇异的）。 如果不存在，那么该矩阵为不可逆的（或称奇异的）。 判断方式:行列式不为0，那么可逆。 行列式的计算方式 假设矩阵为M，|M| 表示M矩阵的行列式，行列式是一个标量（数值）\n计算方法：\n1、左下左上画对角，线上数值都相乘，数值数量为行列，数量不够对岸取\n2、左下分组加，左上分组减\n代数余子式矩阵 标准伴随矩阵 标准伴随矩阵为原矩阵的代数余子式矩阵的转置矩阵。\n逆矩阵的计算 1、逆矩阵 = 标准伴随矩阵 / 行列式\nM-1 = CT / |M|\n2、初等变换\n(A E)-\u0026gt;(E A-1)\n逆矩阵的重要性质 1.逆矩阵的逆矩阵是原矩阵本身 (M-1)-1 = M\n2.矩阵乘以自己的逆矩阵等于单位矩阵 MM-1 = M-1M = E\n3.单位矩阵的逆矩阵是它本身 E-1 = E\n4.转置矩阵的逆矩阵是逆矩阵的转置 (MT)-1 = (M-1)T\n5.矩阵串接相乘后的逆矩阵 等于 反向串接各个矩阵的逆矩阵 相乘 (AB)-1 = B-1A-1\n6.逆矩阵可以计算矩阵变换的反向变换（M为矩阵，v为一个矢量）\nM-1(Mv) = (M-1M)v = Ev = v\n正交矩阵 正交矩阵是一种特殊的方阵，正交的意思是垂直\n它的特点是：\n1、一个方阵和它的转置矩阵相乘为单位矩阵，那么它就是正交矩阵\nMMT = MTM = E\n2、通过正交矩阵的这一性质，再根据上节课学习的逆矩阵的一个重要性质\nMM-1 = M-1M = E\n3、我们可以推导出：如果一个矩阵是正交的，那么它的逆矩阵等于其转置矩阵\nMT = M-1\n4、如果一个矩阵是正交矩阵，那么它的转置矩阵也是正交矩阵\n判断是否为正交矩阵 根据正交矩阵的基本概念，我们可以总结出判断一个矩阵是否是正交矩阵的方式有：\n判断MMT = MTM = E ，满足则为正交矩阵 判断矩阵的每一行（列）是否是单位向量 判断矩阵的行（列）向量是否彼此正交（垂直） 行列矩阵 一、列矩阵和行矩阵的基本概念\n1、列矩阵就是只有一列的矩阵；行矩阵就是只有一行的矩阵。他们一般用于表示向量\n2、把向量作为列矩阵和行矩阵与矩阵进行乘法运算时，计算顺序（列在后，行在前）和结果是不同的\n二、列矩阵和行矩阵在Unity中的使用规则\n1、在Unity的Shader开发中，我们采用列矩阵的形式进行向量计算，利用结合律，我们可以从右往左阅读\nCBAv = C(B(Av))\n2、如果想要使用行矩阵计算出和列矩阵相同的结果，我们可以乘以变换矩阵的转置矩阵\nvATBTCT = (((vAT)BT)CT)\n矩阵的几何意义 点和向量能在图像中画出来，那么矩阵可以吗？ **矩阵的可视化结果就是：**变换\n在游戏开发中，如果你看到了一个矩阵，那么基本上你可以认为你看到的是一个变换，这些变换一般包含：平移、旋转、缩放。\n**比如：**我们想要将一个点、一个向量进行一种变换（平移、旋转、缩放）。那么我们可以利用矩阵来进行数学计算，从而达到变换的目的。\n我们可以利用矩阵相关知识做什么？ 对三维空间中的向量进行平移、旋转、缩放、坐标变换、投影等等计算，这样我们就可以对Shader中的数据进行处理，让其最终在屏幕上的效果是按照我们的需求来呈现的。\n什么是变换？ **线性变换：**指可以保留矢量加和标量乘的变换。缩放、旋转、错切、镜像、正交投影等。\n**仿射变换：**指合并线性变换和平移变换的变换类型。齐次坐标。\n持续更新中\n分类: UnityShader\n","date":"2024-05-16T13:42:37+08:00","permalink":"https://fanmain.github.io/post/unity/2022/01_unity_math/","title":"01_unity_math"},{"content":"API 翻译 - Easydict SwiftUI swiftui 照片编辑 照片关键词AI检索 相册 HXPhotoPicker 音频 一步一步教你实现iOS音频频谱动画\n","date":"2024-05-07T10:20:22+08:00","permalink":"https://fanmain.github.io/post/ios/2024/ios_projects_collection/","title":"ios 开源项目收集"},{"content":"issues iphone14 iOS16.6 保存相册是设置originalFilename 后读取不一致 代码 // 设置 let option = PHAssetResourceCreationOptions() option.originalFilename = \u0026#34;2024-04-23_08-36-02_1.jpg\u0026#34; // 读取 let resources = PHAssetResource.assetResources(for: self) if let resource = resources.first { fileName = resource.originalFilename } name = \u0026#34;2024-04-23_16-36-02_1.jpg\u0026#34; 字符串时间被莫名其妙+8了 关闭iCloud相册同步 开启时间市区自动同步 虫害手机后恢复\n","date":"2024-04-23T17:53:56+08:00","permalink":"https://fanmain.github.io/post/ios/2024/02_arglass_issues/","title":"02_ARGlass_issues"},{"content":" 录屏 ffmpeg -video_size 1280x720 -framerate 30 -f avfoundation -pixel_format uyvy422 -i \u0026ldquo;0:0\u0026rdquo; -f flv output.flv\n录屏-\u0026gt;推流 ffmpeg -video_size 1280x720 -framerate 30 -f avfoundation -pixel_format uyvy422 -i \u0026ldquo;0:0\u0026rdquo; -ar 44100 -f flv rtmp://127.0.0.1:1935/live\n","date":"2024-04-17T10:50:37+08:00","permalink":"https://fanmain.github.io/post/media/2019/01_ffmpeg_cmd/","title":"FFmpeg 常用命令"},{"content":"Mac搭建nginx+rtmp服务 后台搭建直播服务时，安装nginx：\n下载 $ brew tap denji/homebrew-nginx *安装\n$ brew install nginx-full --with-rtmp-module 注意⚠️\n--with-rtmp-module，一定要加上rtmp模块，不然添加rtmp服务时就会报错误：unknown directive \u0026quot;rtmp\u0026quot; in /usr/local/etc/nginx/nginx.conf:117\n如果遇到这种错误，只能是卸载重装了，下面是卸载命令\n$ brew uninstall nginx-full 然后重新安装。\n打开文件/usr/local/etc/nginx/nginx.conf，编辑文件，在最下边添加如下rtmp配置：\nrtmp { server { listen 1935; ping 30s; notify_method get; application live { live on; record off; max_connections 1024; } } } 更新配置：(版本号替换为自己的)\n/usr/local/Cellar/nginx-full/1.19.0/bin/nginx -s reload 然后就可以启动服务了。 nginx 在浏览器里打开http://localhost:8080\n如果看到如下页面，说明配置成功了！\n想要停止服务，命令：（stop是强制退出，quit是执行完任务后退出）\n$ nginx -s quit 或者 $ nginx -s stop 可以用ffmpeg推流，来测试直播服务。 安装ffmpeg $ brew install ffmpeg 安装成功后，就可以推流本地视频，如下命令：\nffmpeg -re -i 本地视频路径 -vcodec libx264 -acodec aac -strict -2 -f flv rtmp://localhost:1935/live/room 开启推流后，用VLC播放器播放下面直播地址视频：\nrtmp://localhost:1935/live/room 这样一个简单的本地直播服务就搭建好了！\niOS集成LFLiveKit直播库，替换ffmpeg推流，就可以测试直播功能了！\n","date":"2024-04-17T09:47:14+08:00","permalink":"https://fanmain.github.io/post/ios/2023/01_rtmp/","title":"01_rtmp"},{"content":"基础 控件一览 旧项目使用 UIKit 打开 swiftui页面 UIHostingController(rootView: SwiftUIView()) 版本兼容 swiftUI 自iOS13问世以来，每个版本都不兼容，每个版本都有新的Api，适配不同版本工作量巨大🤣； iOS目前（截止2023低） iOS15之下的设备只占3%，这3%中还包含iOS14， 因此最低版本建议iOS14。 多平台适配（iOS、mac、ipad） 最低版本只能使用iOS14以上 LIST SwiftUI 实战二、List 的使用\u0026amp;交互\n遇到的问题: SPM加载过慢 通过终端打开xcode,终端开启全局代理。 export ALL_PROXY=http://127.0.0.1:7890 open -a Xcode.app ","date":"2024-04-12T10:01:10+08:00","permalink":"https://fanmain.github.io/post/ios/2024/01_swiftuitips/","title":"01_swiftuiTips"},{"content":"参考文档：\ntvm_phone/tvm-cmake-ios.md at master · zhaowd2001/tvm_phone · GitHub\nhttps://blog.csdn.net/qq_38743313/article/details/101601778/\n参考了前面几个文档，发现都不是最好的解决办法，准确的说就没起作用，哈哈哈。\n我的测试目录结构如下：\n根目录/\nassets/test.txt interface/test/somefile.h\nsrc/somefile.cpp\nCMakeLists.txt\nios.toolchain.cmake\nbuild.sh\nassets是我想直接复制到framework中去的资源\nCMakeLists.txt内容如下\ncmake_minimum_required(VERSION 3.10.2) project(CMakeTestLib) enable_language(CXX) set(LIBRARY_OUTPUT_PATH ${CMAKE_SOURCE_DIR}/lib/${OUTPUT_PATH}) file(GLOB_RECURSE SOURCE_FILES ${CMAKE_SOURCE_DIR}/src/*.cpp)file(GLOB_RECURSE INCLUDE_FILES ${CMAKE_SOURCE_DIR}/interface/*.h)file(GLOB_RECURSE ASSETS_FILES ${CMAKE_SOURCE_DIR}/assets/*.txt) MESSAGE( STATUS \u0026#34;SOURCE_FILES: \u0026#34; ${SOURCE_FILES} )MESSAGE( STATUS \u0026#34;INCLUDE_FILES: \u0026#34; ${INCLUDE_FILES} )MESSAGE( STATUS \u0026#34;ASSETS_FILES: \u0026#34; ${ASSETS_FILES} ) set(RESOURCE_FILES\t${CMAKE_SOURCE_DIR}/assets/note.txt\t) include_directories(${PROJECT_NAME} ${CMAKE_SOURCE_DIR}/interface)\tadd_library(${PROJECT_NAME}\tSHARED ${SOURCE_FILES}\t${CMAKE_SOURCE_DIR}/interface\t${CMAKE_SOURCE_DIR}/assets) # Debug symbols set in XCode project# set_xcode_property(${PROJECT_NAME} GCC_GENERATE_DEBUGGING_SYMBOLS YES \u0026#34;All\u0026#34;) set_target_properties(${PROJECT_NAME} PROPERTIES\tFRAMEWORK TRUE\tFRAMEWORK_VERSION A\tMACOSX_FRAMEWORK_IDENTIFIER com.test.${PROJECT_NAME}\t# MACOSX_FRAMEWORK_INFO_PLIST Info.plist\t# \u0026#34;current version\u0026#34; in semantic format in Mach-O binary file\tVERSION 1.0.1\t# \u0026#34;compatibility version\u0026#34; in semantic format in Mach-O binary file\tSOVERSION 1.0.1\tPUBLIC_HEADER ${CMAKE_SOURCE_DIR}/interface\tRESOURCE ${CMAKE_SOURCE_DIR}/assets\t#XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY \u0026#34;iPhone Developer\u0026#34;) target_include_directories(${PROJECT_NAME} PRIVATE ${CMAKE_SOURCE_DIR}/interface) 注意事项：\n1、无论是headers还是assets，都要先在add_library中添加了才有用。\n2、PUBLIC_HEADER和RESOURCE 后面都可以直接写目录，而非文件列表。\n","date":"2024-04-10T16:16:18+08:00","permalink":"https://fanmain.github.io/post/others/cmake_ios/","title":"Cmake_ios"},{"content":"文章目录 前言 一、HTTP-FLV 简介 1、市场上使用 http-flv 的商家 2、http-flv、rtmp 和 hls 直播的优缺点 3、http-flv 技术实现 二、Nginx 配置 http-flv 1、Windows 安装 nginx，已经集成 nginx-http-flv-module 2、nginx.conf 配置文件 3、运行 nginx 服务器 4、ffmpeg 推流 5、VLC 播放 6、flv.js 网页播放 三、FLV 格式简介 1、简介 2、FLV 格式解析 ①、header ②、body 四、FLV Adobe 官方标准 1、单位说明 2、FLV 文件头和文件体 (E.2, E.3) 3、FLV Tag (E.4) 4、AudioTag (E.4.2) 5、VideoTag (E.4.3) 6、SCRIPTDATA (E.4.4) 7、onMetadata (E.5) 8、keyframes 索引信息 五、FlvAnalyzer 分析 flv 文件 前言 传统的直播协议要么使用 Adobe 的基于 TCP 的 RTMP 协议， 要么使用 Apple 的基于 HTTP 的 HLS 协议。本文介绍另外一种结合了 RTMP 的低延时， 以及可以复用现有 HTTP 分发资源的流式协议 HTTP-FLV。\n一、HTTP-FLV 简介 HTTP-FLV，即将音视频数据封装成 FLV，然后通过 HTTP 协议传输给客户端。\nHLS 其实是一个 “文本协议” ，而并非流媒体协议，(ts0,ts1,…)。 那么，什么样的协议才能称之为流媒体协议呢？\n答：流（stream）：数据在网络上按时间先后次序传输和播放的连续音/视频数据流。之所以可以按照顺序传输和播放连续是因为在类似 RTMP、FLV 协议中，每一个音视频数据都被封装成了包含时间戳信息头的数据包。而当播放器拿到这些数据包解包的时候能够根据时间戳信息把这些音视频数据和之前到达的音视频数据连续起来播放。\nMP4、MKV 等等类似这种封装，必须拿到完整的音视频文件才能播放，因为里面的单个音视频数据块不带有时间戳信息，播放器不能将这些没有时间戳信息数据块连续起来，所以就不能实时的解码播放。\n1、市场上使用 http-flv 的商家 优酷的 pc 网页直播，斗鱼、 熊猫 tv、 虎牙 pc 网页上也使用了 http-flv\n2、http-flv、rtmp 和 hls 直播的优缺点 三者的延迟性 http-flv：低延迟，内容延迟可以做到 2-5 秒； Rtmp：低延迟，内容延迟可以做到 2-5 秒。 Hls：延迟较高（ts0，segment-time：5，10s）。 三者的易用性 rtmp 和 http-flv：播放端安装率高。只要浏览器支持 FlashPlayer 就能非常简易的播放。 hls：最大的优点：HTML5 可以直接打开播放；这个意味着可以把一个直播链接通过微信等转发分享，不需要安装任何独立的 APP，有浏览器即可。 rtmp 和 http-flv 比较 穿墙：很多防火墙会墙掉 RTMP，但是不会墙 HTTP，因此 HTTP FLV 出现奇怪问题的概率很小。 调度：RTMP 也有个 302，可惜是播放器 as 中支持的，HTTP FLV 流就支持 302 方便 CDN 纠正 DNS 的错误。 容错：SRS 的 HTTP FLV 回源时可以回多个，和 RTMP 一样，可以支持多级热备。 简单：FLV 是最简单的流媒体封装，HTTP 是最广泛的协议，这两个组合在一起维护性更高，比 RTMP 简单多了。 3、http-flv 技术实现 HTTP 协议中有个约定：content-length 字段，http 的 body 部分的长度。\n服务器回复 http 请求的时候如果有这个字段，客户端就接收这个长度的数据然后就认为数据传输完成了。 如果服务器回复 http 请求中没有这个字段，客户端就一直接收数据，直到服务器跟客户端的 socket 连接断开。 (流式传输） http-flv 直播就是利用第二个原理，服务器回复客户端请求的时候不加 content-length 字段，在回复了 http 内容之后，紧接着发送 flv 数据，客户端就一直接收数据了。\n二、Nginx 配置 http-flv 1、Windows 安装 nginx，已经集成 nginx-http-flv-module RTMP 服务器：Nginx+rtmp（windows）的环境搭建如有需要可自取：\n链接：https://pan.baidu.com/s/1AcIVERWUPbJL1zu8yCcAzw\n提取码：mtdf\n2、nginx.conf 配置文件 nginx.conf 配置文件如下：\nworker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #error_log logs/error.log debug; #pid logs/nginx.pid; events { worker_connections 1024; } # 添加RTMP服务 rtmp { server { listen 1935; # 监听端口 chunk_size 4000; application live { live on; gop_cache on; hls on; hls_path html/hls; } } } # HTTP服务 http { include mime.types; default_type application/octet-stream; #access_log logs/access.log main; server { listen 8080; # 监听端口 location /flv { flv_live on; chunked_transfer_encoding on;\tadd_header \u0026#39;Access-Control-Allow-Origin\u0026#39; \u0026#39;*\u0026#39;; add_header \u0026#34;Access-Control-Allow-Credentials\u0026#34; \u0026#34;true\u0026#34;; add_header \u0026#34;Access-Control-Allow-Methods\u0026#34; \u0026#34;*\u0026#34;; add_header \u0026#34;Access-Control-Allow-Headers\u0026#34; \u0026#34;Content-Type,Access-Token\u0026#34;; add_header \u0026#34;Access-Control-Expose-Headers\u0026#34; \u0026#34;*\u0026#34;;\t} location /stat.xsl { root html; } location /stat { rtmp_stat all; rtmp_stat_stylesheet stat.xsl; } location / { root html; } } } 其中涉及到跨域问题：#http-flv\nlocation /flv { flv_live on; chunked_transfer_encoding on;\tadd_header \u0026#39;Access-Control-Allow-Origin\u0026#39; \u0026#39;*\u0026#39;; add_header \u0026#34;Access-Control-Allow-Credentials\u0026#34; \u0026#34;true\u0026#34;; add_header \u0026#34;Access-Control-Allow-Methods\u0026#34; \u0026#34;*\u0026#34;; add_header \u0026#34;Access-Control-Allow-Headers\u0026#34; \u0026#34;Content-Type,Access-Token\u0026#34;; add_header \u0026#34;Access-Control-Expose-Headers\u0026#34; \u0026#34;*\u0026#34;;\t} 3、运行 nginx 服务器 双击 nginx8080.exe\n在任务管理器可以看到目前 nginx 已开始工作\n4、ffmpeg 推流 ffmpeg -re -i SampleVideo_1280x720_20mb.mp4 -vcodec libx264 -acodec aac -f flv -y rtmp://127.0.0.1:1935/live/test1 这个命令使用 FFmpeg 工具来将输入视频文件 SampleVideo_1280x720_20mb.mp4 转换为 FLV 格式并通过 RTMP 协议流式传输到指定的 URL 地址 rtmp://127.0.0.1:1935/live/test1；\n-re：以实时模式（real-time）读取输入文件，模拟实时流传输的速度。 -i SampleVideo_1280x720_20mb.mp4：指定输入文件名为 SampleVideo_1280x720_20mb.mp4。 -vcodec libx264：选择 H.264 编码器作为视频编码器； -acodec aac：选择 AAC 编码器作为音频编码器； -f flv：指定输出格式为FLV（Flash Video）； -y：自动覆盖输出文件，如果存在同名文件则会被替换； rtmp://127.0.0.1:1935/live/test1：指定输出的 URL 地址，以 RTMP 协议传输到 192.168.36.176 服务器的 1935 端口的 live 应用程序中的 test1 流 5、VLC 播放 http-flv：http://localhost:8080/flv?port=1935\u0026amp;app=live\u0026amp;stream=test1\n对应关系如下：\nVLC 进行拉流\nrtmp：rtmp://127.0.0.1:1935/live/test1\nHls：http://localhost:8080/hls/test1.m3u8\n此外，视频和音频内容分割为小的 TS 文件，并生成相应的 M3U8 文件，以便客户端能够获取和播放这些文件。M3U8 文件可以通过 HTTP 服务器提供给客户端，并使用流媒体播放器（如VLC、HLS播放器等）进行解析和播放。\n这个目录是由 nginx.conf 配置文件决定的：\n6、flv.js 网页播放 前面我们已经解决了跨域问题\nhtml.flv 文件内容如下：\nworker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #error_log logs/error.log debug; #pid logs/nginx.pid; events { worker_connections 1024; } # 添加RTMP服务 rtmp { server { listen 1935; # 监听端口 chunk_size 4000; application live { live on; gop_cache on; hls on; hls_path html/hls; } } } # HTTP服务 http { include mime.types; default_type application/octet-stream; #access_log logs/access.log main; server { listen 8080; # 监听端口 location /flv { flv_live on; chunked_transfer_encoding on;\tadd_header \u0026#39;Access-Control-Allow-Origin\u0026#39; \u0026#39;*\u0026#39;; add_header \u0026#34;Access-Control-Allow-Credentials\u0026#34; \u0026#34;true\u0026#34;; add_header \u0026#34;Access-Control-Allow-Methods\u0026#34; \u0026#34;*\u0026#34;; add_header \u0026#34;Access-Control-Allow-Headers\u0026#34; \u0026#34;Content-Type,Access-Token\u0026#34;; add_header \u0026#34;Access-Control-Expose-Headers\u0026#34; \u0026#34;*\u0026#34;;\t} location /stat.xsl { root html; } location /stat { rtmp_stat all; rtmp_stat_stylesheet stat.xsl; } location / { root html; } } } 因此双击 flv.html 文件，可以看到网页播放成功\n三、FLV 格式简介 1、简介 FLV（Flash Video）是现在非常流行的流媒体格式，由于其视频文件体积轻巧、封装播放简单等特点，使其很适合在网络上进行应用，目前主流的视频网站无一例外地使用了 FLV 格式。另外由于当前浏览器与 Flash Player 紧密的结合，使得网页播放 FLV 视频轻而易举，也是 FLV 流行的原因之一。\nFLV 是流媒体封装格式，我们可以将其数据看为二进制字节流。总体上看，FLV 包括文件头（File Header：9 字节）和文件体（File Body）两部分，其中文件体由一系列的 Tag 及 Tag Size 对组成。\n注意这个大小关系：PreviosTagSize = TagDataSize + 11;\n2、FLV 格式解析 先来一张图，这是上面我们播放的视频文转换为 FLV 文件\n使用 Notepad++ 进行查看二进制数据（注：这里要求 Notepad++ 安装了 HexEditor 插件）\n可以参考我以前的博客：notepad++安装HexEditor插件查看二进制文件\nSampleVideo_1280x720_20mb.flv 文件二进制内容如下：\n①、header 头部分由以下几部分组成：Signature（3 Byte）+Version（1 Byte）+Flags（1 Bypte）+DataOffset（4 Byte）\nsignature 占 3 个字节：固定 FLV 三个字符作为标示。一般发现前三个字符为 FLV 时就认为他是 flv 文件。 Version 占 1 个字节：标示 FLV 的版本号。 这里我们看到是 1 Flags 占 1 个字节：内容标示。第 0 位和第 2 位，分别表示 video 与 audio 存在的情况。(1 表示存在，0 表示不存在)。截图看到是 0x05，也就是 00000101，代表既有视频，也有音频。 DataOffset 4 个字节：表示 FLV 的 header 长度。 这里可以看到固定是 9 ②、body FLV 的 body 部分是由一系列的 back-pointers（ 后向指针） + tag 构成\nback-pointers 固定 4 个字节，表示前一个 tag 的 size。 从上图可以看到前一个 tag 的 size 为 0 tag 分三种类型：video、audio、scripts。 tag 组成：tag type[1B]+tag data size[3B]+Timestamp[3B]+TimestampExtended[1B]+stream id[3B]+ tag data type 1 个字节。8 为 Audio，9 为 Video，18 为 scripts 从上图可以看到 type 为 0x123 = 18 --\u0026gt; scripts tag data size 3 个字节。表示 tag data 的长度：从 streamd id 后算起。 从上图可以看到 tag data size 为 0x123 = 297 Timestreamp 3 个字节。 时间戳 从上图可以看到 Timestreamp 为 0x000000 = 0 TimestampExtended 1 个字节。 时间戳扩展字段 从上图可以看到 TimestampExtended 为 0x00 = 0 stream id 3 个字节。 总是 0 tag data 数据部分 tag 头伪代码：\n四、FLV Adobe 官方标准 FLV 文件格式标准是写在 F4V/FLV file format spec v10.1 的附录 E 里面的 FLV File Format。\n1、单位说明 2、FLV 文件头和文件体 (E.2, E.3) 从整个文件上看，FLV = FLV File Header + FLV File Body。\n通常，FLV 的前 13 个字节（flv header + PreviousTagSize0）完全相同，所以，程序中会单独定义一个常量来指定。特殊，比如有的视频文件没有视频流或没有音频流。\n3、FLV Tag (E.4) Timestamp 和 TimestampExtended 组成了这个 TAG 包数据的 PTS 信息，PTS =Timestamp | TimestampExtended \u0026lt;\u0026lt; 24。\n4、AudioTag (E.4.2) 由于 AAC 编码的特殊性， 这里着重说明了 AAC 编码的 Tag 格式。\nAudioTagHeader 的第一个字节，也就是接跟着 StreamID 的 1 个字节包含了音频类型，采样率等的基本信息。\nAudioTagHeader 之后跟着的就是 AUDIODATA 部分了。但是，这里有个特例，如果音频格式（SoundFormat）是 AAC，AudioTagHeader 中会多出 1 个字节的数据 AACPacketType，这个字段来表示 AACAUDIODATA 的类型：0 = AAC sequence header，1 = AAC raw。\nAudioSpecificConfig 结构描述非常复杂，在标准文档中是用伪代码描述的，这里先假定要编码的音频格式，做一下简化。\n音频编码为：AAC-LC，音频采样率为 44100。\n在 FLV 的文件中，一般情况下 AAC sequence header 这种包只出现 1 次，而且是第一个 audio tag，为什么需要这种 tag，因为在做 FLV demux 的时候，如果是 AAC 的音频，需要在每帧 AAC ES 流前边添加 7 个字节 ADST 头， ADST 是解码器通用的格式，也就是说 AAC 的纯 ES 流要打包成 ADST 格式的 AAC 文件，解码器才能正常播放。 就是在打包 ADST 的时候，需要 samplingFrequencyIndex 这个信息，samplingFrequencyIndex 最准确的信息是在 AudioSpecificConfig 中，这样，你就完全可以把 FLV 文件中的音频信息及数据提取出来， 送给音频解码器正常播放了。\n5、VideoTag (E.4.3) 由于 AVC(H.264) 编码的特殊性， 这里着重说明了 AVC(H.264) 编码的 Tag 格式。\nVideoTagHeader 的第一个字节，也就是接跟着 StreamID 的 1 个字节包含着视频帧类型及视频 CodecID 等最基本信息。\nVideoTagHeader 之后跟着的就是 VIDEODATA 部分了。但是，这里有个特例，如果视频格式（CodecID）是 AVC， VideoTagHeader 会多出 4 个字节的信息。\nAVCDecoderConfigurationRecord 包含着是 H.264 解码相关比较重要的 SPS 和 PPS 信息，在给 AVC 解码器送数据流之前一定要把 SPS 和 PPS 信息送出，否则的话，解码器不能正常解码。而且在解码器 stop 之后再次 start 之前， 如 seek，快进快退状态切换等，都需要重新送一遍 SPS 和 PPS 的信息。AVCDecoderConfigurationRecord 在 FLV 文件中一般情况也只出现 1 次，也就是第一个 video tag。\nAVCDecoderConfigurationRecord 长度为 sizeof(UI8) * (11 + sps_size + pps_size)。\n6、SCRIPTDATA (E.4.4) ScriptTagBody 内容用 AMF 编码\n一个 SCRIPTDATAVALUE 记录包含一个有类型的 ActionScript 值。\n7、onMetadata (E.5) FLV metadata object 保存在 SCRIPTDATA 中，叫 onMetaData。不同的软件生成的 FLV 的 properties 不同。\n8、keyframes 索引信息 官方的文档中并没有对 keyframes index 做描述，但是，flv 的这种结构每个 tag 又不像 TS 有同步头，如果没有 keyframes index 的话，需要按顺序读取每一个 tag，seek 及快进快退的效果会非常差。后来在做 flv 文件合成的时候，发现网上有的 flv 文件将 keyframes 信息隐藏在 Script Tag 中。\nkeyframes 几乎是一个非官方的标准，也就是民间标准。两个常用的操作 metadata 的工具是 flvtool2 和 FLVMDI， 都是把 keyframes 作为一个默认的元信息项目。在 FLVMDI 的主页上有描述：\n也就是说 keyframes 中包含着 2 个内容 “filepositions” 和 “times”分别指的是关键帧的文件位置和关键帧的 PTS。通过 keyframes 可以建立起自己的 Index，然后在 seek 和快进快退的操作中，快速有效地跳转到你想要找的关键帧位置进行处理。\n五、FlvAnalyzer 分析 flv 文件 参考我之前的博客：音视频开发常用工具\n查看其中第三章的内容：\n我的qq：2442391036，欢迎交流！\n原文\n","date":"2024-04-07T10:42:23+08:00","permalink":"https://fanmain.github.io/post/media/02_http-flv/02_http-flv/","title":"02_http Flv"},{"content":"入职当前公司，接手App时遇到的问题和解决方案 Object-c Swift 音视频 1.iOS录制h265无法保存到相册 if (videoStream-\u0026gt;codec-\u0026gt;codec_id == AV_CODEC_ID_H265) { avformat_alloc_output_context2(\u0026amp;mOutFormatContext, NULL, \u0026#34;mov\u0026#34;, [fileName UTF8String]); videoStream-\u0026gt;codec-\u0026gt;codec_tag = MKTAG(\u0026#39;h\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;1\u0026#39;); } 参考：\n文件输出指定mov hev和hvc tag兼容测试 ","date":"2024-04-01T16:53:24+08:00","permalink":"https://fanmain.github.io/post/ios/2019/01_cameraissues/","title":"摄像头项目中遇到的问题"},{"content":"起因： 目前这家公司项目中用到的mp4v2还是19年之前的版本，不支持h265，bugly崩溃率 \u0026lt; 0.01%。\n检查更新 github上新版本\n编译\u0026amp;xcode打包 下载代码 git clone https://github.com/TechSmith/mp4v2.git 配置静态、动态 CMakeLists.txt\n//动态链接 add_library(mp4v2 SHARED ${HEADER_FILES} ${SOURCE_FILES}) //静态链接 add_library(mp4v2 STATIC ${HEADER_FILES} ${SOURCE_FILES}) 使用cmake生成xcode工程 cd mp4v2 cmake -G \u0026#34;Xcode\u0026#34; . xcode 打开,选择对应target 配置打包 ","date":"2024-03-29T10:08:59+08:00","permalink":"https://fanmain.github.io/post/media/libmp4v2_update/libmp4v2_update/","title":"老项目mp4v2简单升级"},{"content":"前言 vscode调试C/C++教程很多，操作麻烦，这里试图找到一个最简单的使用vscode调试C/C++代码的方法。这里是使用Makefile的多文件方式。\n测试文件 tree . ├── func.c ├── func.h ├── main.c └── Makefile fun.c\n#include \u0026lt;stdio.h\u0026gt; #include \u0026#34;func.h\u0026#34; int foo1(int a) { int b = ++a; printf(\u0026#34;This is foo1 %d\\n\u0026#34;,b); } fun.h\nint foo1(int a); main.c\n#include \u0026lt;stdio.h\u0026gt; #include \u0026#34;func.h\u0026#34; int main() { int a = 1; printf(\u0026#34;Hello, I am coming %d\\n\u0026#34;, a); foo1(a); return 0; } Makefile\nCC = gcc CFLAGS = -g LDFLAGS = TARGET = test SRCS = $(wildcard *.c) OBJS = $(SRCS:.c=.o) all: $(TARGET) $(TARGET): $(OBJS) $(CC) $(CFLAGS) $(OBJS) -o $(TARGET) $(LDFLAGS) %.o: %.c $(CC) $(CFLAGS) -c $\u0026lt; -o $@ clean: rm -f $(OBJS) $(TARGET) 关键配置文件 在.vscode路径下\nlauch.json\n{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;(gdb) 启动\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/test\u0026#34;, //编译后可执行文件路径 \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;为 gdb 启用整齐打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true }, { \u0026#34;description\u0026#34;: \u0026#34;将反汇编风格设置为 Intel\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-gdb-set disassembly-flavor intel\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34; :\u0026#34;C/C++: gcc 生成活动文件\u0026#34;, // 与task中label一致 \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;/usr/bin/gdb\u0026#34; } ] } tasks.json\n{ \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++: gcc 生成活动文件\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;make\u0026#34;, // 使用Mafile编译 \u0026#34;args\u0026#34;: [ //\u0026#34;-fdiagnostics-color=always\u0026#34;, //\u0026#34;-g\u0026#34;, //\u0026#34;${file}\u0026#34;, //\u0026#34;-o\u0026#34;, //\u0026#34;${fileDirname}/${fileBasenameNoExtension}\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34; //项目所在目录 }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;detail\u0026#34;: \u0026#34;调试器生成的任务。\u0026#34; } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } 最终调试时文件\n/ws/example$ tree -a . ├── func.c ├── func.h ├── func.o ├── main.c ├── main.o ├── Makefile ├── test └── .vscode ├── launch.json ├── settings.json └── tasks.json 成功调试 ","date":"2024-03-27T17:04:23+08:00","permalink":"https://fanmain.github.io/post/code/2024/01_makefile/01_makefile/","title":"vscode调试C/C++代码的方法。这里是使用Makefile的多文件方式【转】"},{"content":"1、创建目录 os.makedirs可以递归的创建目录结构\nimport osos.makedirs(\u0026#39;dirname\u0026#39;, exist_ok=True) exist_ok = True指定了，如果某个要创建的目录已经存在，也不报错。\n2、删除文件或目录 os.remove可以删除一个文件\nos.remove(\u0026#39;xx.py\u0026#39;) shutil.rmtree() 可以递归的删除某个目录所有的子目录和子文件\nimport shutilshutil.rmtree(\u0026#39;tmp\u0026#39;, ignore_errors=True) 参数ignore_errors = True 保证如果目录不为空，不会抛出异常。\n3、拷贝目录 要拷贝一个目录里面所有的内容（包括子目录和文件、子目录里面的子目录和文件）到另一个目录中，可以使用shutil的copytree函数\nform shutil import copytreecopytree(\u0026#39;d:/tools/aaa\u0026#39;, \u0026#39;e:/new/bbb\u0026#39;) 拷贝前，目标目录必须不存在，否则会报错。\n拷贝前，如果e:/new这个目录不存在，执行时会创建e:/new目录，再创建e:/new/bbb目录，再拷贝\n拷贝前，如果e:/new存在，但是e:/new/bbb不存在，就只会创建e:/new/bbb，再拷贝\n4、修改文件名、目录名 os.rename(\u0026#39;d:/tools/aaa\u0026#39;, \u0026#39;d:/tools/bbb\u0026#39;)os.rename(\u0026#39;d:/tools/first.py\u0026#39;, \u0026#39;d:/tools/second.py\u0026#39;) linux系统上，如果重命名之前d:/tools/second.py已存在，则会覆盖。\n5、对文件路径的操作 import ospath = \u0026#39;/user/beazley/data/data.csv\u0026#39;# 获取路径中的文件名部分os.path.basename(pat)\t# \u0026#39;data.csv\u0026#39;# 获取路径中的目录部分os.path.dirname(path)\t# \u0026#39;/user/beazley/data\u0026#39;# 文件路径的拼接os.path.join(\u0026#39;tmp\u0026#39;, \u0026#39;data\u0026#39;, os.path.basename(path))# \u0026#39;tmp/data/data.csv\u0026#39; 6、判断文件、目录是否存在 os.path.exists(\u0026#39;d:/systems/cmd.exe\u0026#39;)os.paht.exists(\u0026#39;d:/systems\u0026#39;) 7、判断是否是文件或目录 os.path.isfile(\u0026#39;d:/systems/cmd.exe\u0026#39;)os.path.isdir(\u0026#39;d:systems\u0026#39;) 8、文件大小和修改日期 # 返回文件大小os.path.getsize(\u0026#39;file\u0026#39;)# 返回文件的最后修改日期，是秒时间os.path.getmtime(\u0026#39;file\u0026#39;)# 把秒时间转化为日期时间time.ctime(os.path.getmtime(\u0026#39;/etc/passwd\u0026#39;)) 9、取当前工作目录 cwd = os.getcwd()# 切抽当前工作目录到另外的路径os.chdir(path) 10、遍历目录下文件 # 目标目录targetDir = r\u0026#39;d:/tmp/util/dist/check\u0026#39;files = []dirs = [] # dirpath:当前遍历到的目录名# dirnames:存放当前dirpath中的所有子目录名# filenames:存放当前dirpath中的所有文件名for(dirpath, dirnames, filenames) in os.walk(targetDir): files += filenames dirs += dirnamesprint(files)print(dirs) 获取目录下所有文件的全路径：\ntargetDir = r\u0026#39;d:/tmp/util/dist/check\u0026#39;for(dirpath, dirnames, filenames) in os.walk(targetDir): for fn in filenames: # 把dirpath和每个文件名拼接起来 fpath = os.path.join(dirpath, fn) 取目录中所有的文件和子目录名：\ntargetDir = r\u0026#39;d:/tmp/util/dist/check\u0026#39;files = os.listdir(targetDir)print(files) 如果只需要获取目录中所有的文件，或只需要子目录：\nimport osfrom os.path import isfile, join, isdirtargetDir = r\u0026#39;d:/tmp/util/dist/check\u0026#39;# 所有的文件print([f for f in os.listdir(targetDir) if isfile(join(targetDir, f))])# 所有的目录print([f for f in os.listdir(targetDir) if isdir(join(targetDir, f))]) 11、取目录中指定扩展名的文件和子目录 import globexes = glob.glob(r\u0026#39;d:/tmp/*.txt\u0026#39;)print(exes) 注意 python 运行的相对路径 vscode 运行、调试时路径 ","date":"2022-03-28T15:52:17+08:00","permalink":"https://fanmain.github.io/post/python/2022/01_file/","title":"01_file"},{"content":"win10 本地时间为UTC时间 Reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1\nedge缓存修改 2021-12-01更新：经过测试最新版Edge不再需要2种方法结合才能生效，2种方法单独都可以使用(谷歌Chrome同理)\n方法一(一劳永逸)：\n①创建新的缓存文件夹，以E:\\Cache\\Edge为例，必须在第3步之前创建；\n②关闭Edge浏览器，删除 C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Edge\\User Data\\Default路径下的Cache文件夹(加粗字体修改成当前计算机登陆的用户名，Win10用户通过“设置-账户-账户信息”、Win7用户通过“控制面板-用户帐户-用户帐户”查看，用户名必须核实)；\n③以管理员身份运行cmd命令行输入mklink /D \u0026ldquo;C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Edge\\User Data\\Default\\Cache\u0026rdquo; \u0026ldquo;E:\\Cache\\Edge\u0026quot;并运行(加粗字体修改成当前登陆用户名，第二个引号内容修改成新路径)；\n方法二(简单)：\n①右键Edge图标 -\u0026gt; 属性 -\u0026gt; 目标 -\u0026gt; 最末尾加上 \u0026ndash;disk-cache-dir=\u0026ldquo;E:\\Cache\\Edge\u0026rdquo;(注意\u0026ndash;前面有个空格，引号里面内容修改成新路径)，点击确定。此方法虽然简单但是必须通过这个图标打开浏览器才能正常缓存到新路径。\n","date":"2021-06-08T00:00:00Z","permalink":"https://fanmain.github.io/post/others/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","title":"日常小技巧【未分类】"},{"content":"原文地址 blog.csdn.net\n编解码协议 H264（视频）和 AAC（音频）有软编解码和硬编解码。\n网络传输都是用的大端序（高地址低字节），H264 网络传输的 startcode 是数据的 length，不是 0x00000001。NALU 有两种格式：Annex B 和 AVCC。Annex B 格式 startcode 以 0x 00 00 01 或 0x 00 00 00 01 开头， AVCC 格式以 NALU 的长度开头。\nAAC 也有两种传输格式：ADTS 和 ADIF\nADIF：Audio Data Interchange Format 音频数据交换格式。这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，即它的解码必须在明确定义的开始处进行。故这种格式常用在磁盘文件中。 ADTS：Audio Data Transport Stream 音频数据传输流。这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于 mp3 数据流格式。 软编码：使用 CPU 进行编码。编码框架 ffmpeg+x264。\nhttps://www.jianshu.com/p/e631b041e96d https://www.jianshu.com/p/3de01105d735 硬编码：不使用 CPU 进行编码，使用显卡（GPU）进行硬件加速。 专用的 DSP、FPGA、ASIC 芯片等硬件进行编码。ios 上硬编码框架 Video ToolBox 和 AudioToolbox。\nIntel 硬编码使用 Intel 处理器内部集成的显卡进行硬件加速，qsv 加速方法便对应着 Intel 硬编码。Intel 硬编码对 H.264 加速效果明显，且不需要安装额外库（仅使用相应的 ffmpeg 命令）。 NVIDIA 硬编码使用英伟达的显卡对视频编码进行加速。CUDA 加速方法对应着 NVIDIA 硬编码。使用英伟达硬编码之前需要安装 CUDA 与英伟达的必要驱动。安装好两个环境后就可以使用 NVIDIA 的硬编码了。英伟达关于视频的编解码提供了两个相关的 SDK：NVENC（硬编码）和 NVCUVID（硬解码），前者负责硬件编码，二后者负责硬件解码。CUDA 支持 Windows、Linux、MacOS 三种主流操作系统。https://blog.csdn.net/qq_29350001/article/details/75144665（CUDA 详解） FFmpeg 中也支持了硬编码，集成了显示视频处理模块。在命令行中使用 ffmpeg -hwaccels 可以查看 ffmpeg 支持的硬件加速方法。\nFFMPEG 目前存在一个编码器 nvenc 是对于 NVIDIA 的 NVENC 的封装，通过使用它可以和 FFMPEG 无缝的整合起来。不过 FFMPEG 只存在 NVENC 的接口，不存在 NVCUVID（解码器） 的封装。如果需要实现相关的解码器可能需要自己实现 FFMPEG 接口。FFMPEG 实现了对于 Intel QSV 的封装。 DXVA 是微软定制的视频加速规范、在 Linux 平台上则是由 NVIDIA 提供的 VDPAU 和 Intel 提供的 VAAPI 加速规范。 在不同平台上可通过不同 API 使用 Intel GPU 的硬件加速能力。目前主要由两套 API：VAAPI 以及 libmfx。VAAPI (视频加速 API，Video Acceleration API) 包含一套开源的库 (LibVA) 以及 API 规范, 用于硬件加速下的视频编解码以及处理，只有 Linux 上的驱动提供支持。libmfx。Intel Media SDK 中的 API 规范，支持视频编解码以及媒体处理。支持 Windows 以及 Linux。除了 Intel 自己的 API，在 Windows 系统上还有其他 API 可使用 Intel GPU 的硬件加速能力，这些 API 属于 Windows 标准，由 Intel 显卡驱动实现。DXVA2 / D3D11VA。标准 Windows API，支持通过 Intel 显卡驱动进行视频编解码，FFmpeg 有对应实现。Media Foundation。标准 Windows API，支持通过 Intel 显卡驱动进行视频编解码，FFmpeg 不支持该 API。https://blog.jianchihu.net/intel-gpu-hw-video-codec-develop.html\n目前的主流 GPU 加速平台：\nINTEL、AMD、NVIDIA 目前主流的 GPU 平台开发框架：\nCUDA：NVIDIA 的封闭编程框架，通过框架可以调用 GPU 计算资源 AMD APP：AMD 为自己的 GPU 提出的一套通用并行编程框架，标准开放，通过在 CPU、GPU 同时支持 OpenCL 框架，进行计算力融合。 OpenCL：开放计算语言，为异构平台编写程序的该框架，异构平台可包含 CPU、GPU 以及其他计算处理器，目标是使相同的运算能支持不同平台硬件加速。 Inel QuickSync：集成于 Intel 显卡中的专用视频编解码模块。 https://www.jianshu.com/p/8423724dffc1\nhttps://blog.csdn.net/haowei0926/article/details/56012139\nios 中的硬编码文档\nios 上硬编码框架 Video ToolBox 和 AudioToolbox。Video ToolBox 是一个底层框架，可以直接访问硬件编码器和解码器。 它提供视频压缩和解压缩服务，并在 CoreVideo 像素缓冲区中存储的光栅 raster 图像格式之间进行转换。 这些服务以会话对象（压缩，解压缩和像素传输）的形式提供，它们以 Core Foundation（CF）类型呈现。 不需要直接访问硬件编码器和解码器的应用程序 App 就不需要直接使用 VideoToolbox。iOS 8.0 及以上苹果开放了 VideoToolbox 框架来实现 H264 硬编码（H264 是一种编解码协议，有多种编解码器能编解码 H264，这里是利用硬件进行编解码，FFmpeg 中可以利用硬编解码和软编解码）。\nCVPixelBufferRef/CVImageBufferRef：存放编码前和解码后的图像数据（未压缩的数据），这两个是相同的对象。 CMTime：时间戳相关，时间以 64-bit/32-bit 的形式出现 CMBlockBufferRef：编码后输出的数据（压缩后的数据） CMFormatDescriptionRef/CMVideoFormatDescriptionRef：图像存储方式，编解码器等格式描述。这两个是相同的对象。 CMSampleBufferRef：存放编解码前后的视频图像的容器数据，iOS 中表示一帧音频 / 视频数据 CMSampleBuffer 可能是一个压缩的数据，也可能是一个未压缩的数据。取决于 CMSampleBuffer 里面是 CMBlockBuffer（压缩后） 还是 CVPixelBuffer（未压缩）。 硬编码的步骤 ：从相机或读取视频文件输出的 CVPixelBuffer（也是以 CMSampleBufferRef 封装形式存在）—\u0026gt;Encoder—\u0026gt;CMSampleBufferRef（编码后得到的数据封装）—\u0026gt; 重新组装 NALUs。\n通过 VTCompressionSessionCreate 创建编码器\nVTCompressionSessionCreate( CM_NULLABLE CFAllocatorRef allocator, int32_t width, int32_t height, CMVideoCodecType codecType, CM_NULLABLE CFDictionaryRef encoderSpecification, CM_NULLABLE CFDictionaryRef sourceImageBufferAttributes, CM_NULLABLE CFAllocatorRef compressedDataAllocator, CM_NULLABLE VTCompressionOutputCallback outputCallback, void * CM_NULLABLE outputCallbackRefCon, CM_RETURNS_RETAINED_PARAMETER CM_NULLABLE VTCompressionSessionRef * CM_NONNULL compressionSessionOut) allocator：内存分配器，填NULL为默认分配器 width、height：视频帧像素的宽高，如果编码器不支持这个宽高的话可能会改变 codecType：编码类型，枚举 encoderSpecification：指定特定的编码器，填NULL的话由VideoToolBox自动选择 sourceImageBufferAttributes：源像素缓冲区的属性，如果这个参数有值的话，VideoToolBox会创建一个缓冲池，不需要缓冲池可以设置为NULL compressedDataAllocator：压缩后数据的内存分配器，填NULL使用默认分配器 outputCallback：视频编码后输出数据回调函数 outputCallbackRefCon：回调函数中的自定义指针，我们通常传self，因为我们需要在C函数中调用self的方法，而C函数无法直接调self, compressionSessionOut：编码器句柄，传入编码器的指针 通过 VTSessionSetProperty 设置编码器属性，是否实时编码输出、是否产生 B 帧、设置关键帧、设置期望帧率、设置码率、最大码率值等等。\nVTSessionSetProperty( // 解码会话 CM_NONNULL VTSessionRef session, // 属性 KEY CM_NONNULL CFStringRef propertyKey, // 设置的属性值 CM_NULLABLE CFTypeRef propertyValue ) kVTCompressionPropertyKey_AverageBitRate：设置编码的平均码率，单位是bps，这不是一个硬性指标，设置的码率会上下浮动。VideoToolBox框架只支持ABR模式。H264有4种码率控制方法： CBR（Constant Bit Rate）是以恒定比特率方式进行编码，有Motion发生时，由于码率恒定，只能通过增大QP来减少码字大小，图像质量变差，当场景静止时，图像质量又变好，因此图像质量不稳定。这种算法优先考虑码率(带宽)。 VBR（Variable Bit Rate）动态比特率，其码率可以随着图像的复杂程度的不同而变化，因此其编码效率比较高，Motion发生时，马赛克很少。码率控制算法根据图像内容确定使用的比特率，图像内容比较简单则分配较少的码率(似乎码字更合适)，图像内容复杂则分配较多的码字，这样既保证了质量，又兼顾带宽限制。这种算法优先考虑图像质量。 *CVBR（Constrained VariableBit Rate）,这样翻译成中文就比较难听了，它是VBR的一种改进方法。但是Constrained又体现在什么地方呢？这种算法对应的Maximum bitRate恒定或者Average BitRate恒定。这种方法的兼顾了以上两种方法的优点：在图像内容静止时，节省带宽，有Motion发生时，利用前期节省的带宽来尽可能的提高图像质量，达到同时兼顾带宽和图像质量的目的。 ABR (Average Bit Rate) 在一定的时间范围内达到设定的码率，但是局部码率峰值可以超过设定的码率，平均码率恒定。可以作为VBR和CBR的一种折中选择。 kVTCompressionPropertyKey_ProfileLevel：设置H264编码的画质，H264有4种Profile：BP、EP、MP、HP BP(Baseline Profile)：基本画质。支持I/P 帧，只支持无交错（Progressive）和CAVLC；主要应用：可视电话，会议电视，和无线通讯等实时视频通讯领域 EP(Extended profile)：进阶画质。支持I/P/B/SP/SI 帧，只支持无交错（Progressive）和CAVLC； MP(Main profile)：主流画质。提供I/P/B 帧，支持无交错（Progressive）和交错（Interlaced），也支持CAVLC 和CABAC 的支持；主要应用：数字广播电视和数字视频存储 HP(High profile)：高级画质。在main Profile 的基础上增加了8×8内部预测、自定义量化、 无损视频编码和更多的YUV 格式；应用于广电和存储领域 Level就多了，这里不一一列举，可参考h264 profile \u0026amp; level，iPhone上常用的方案如下： 实时直播： 低清Baseline Level 1.3 标清Baseline Level 3 半高清Baseline Level 3.1 全高清Baseline Level 4.1 存储媒体： 低清 Main Level 1.3 标清 Main Level 3 半高清 Main Level 3.1 全高清 Main Level 4.1 高清存储： 半高清 High Level 3.1 全高清 High Level 4.1 kVTCompressionPropertyKey_RealTime：设置是否实时编码输出 kVTCompressionPropertyKey_AllowFrameReordering：配置是否产生B帧，High profile 支持 B 帧 kVTCompressionPropertyKey_MaxKeyFrameInterval、kVTCompressionPropertyKey_MaxKeyFrameIntervalDuration：配置I帧间隔 调用 VTCompressionSessionPrepareToEncodeFrames 准备编码\nVTCompressionSessionPrepareToEncodeFrames( CM_NONNULL VTCompressionSessionRef session ) session：编码器句柄，传入编码器的指针 输入采集到的视频数据 CVImageBufferRef /CVPixelBufferRef，调用 VTCompressionSessionEncodeFrame 进行编码\nVTCompressionSessionEncodeFrame( CM_NONNULL VTCompressionSessionRef session, CM_NONNULL CVImageBufferRef imageBuffer, CMTime presentationTimeStamp, CMTime duration, // may be kCMTimeInvalid CM_NULLABLE CFDictionaryRef frameProperties, void * CM_NULLABLE sourceFrameRefCon, VTEncodeInfoFlags * CM_NULLABLE infoFlagsOut ) session：创建编码器时的句柄 imageBuffer：YUV数据，iOS通过摄像头采集出来的视频流数据类型是CMSampleBufferRef，我们要从里面拿到CVImageBufferRef来进行编码。通过CMSampleBufferGetImageBuffer方法可以从sampleBuffer中获得imageBuffer。 presentationTimeStamp：这一帧的时间戳，单位是毫秒 duration：这一帧的持续时间，如果没有持续时间，填kCMTimeInvalid frameProperties：指定这一帧的属性，这里我们可以用来指定产生I帧 encodeParams：自定义指针 infoFlagsOut：用于接收编码操作的信息，不需要就置为NULL 获取到编码后的数据并进行处理并组装 NALU，添加起始码 \u0026ldquo;\\x00\\x00\\x00\\x01\u0026rdquo;，如果这一帧是个关键帧，需要添加 sps pps** 等。将硬编码成功的 CMSampleBuffer 转换成 H264 码流，解析出参数集 SPS \u0026amp; PPS，加上开始码组装成 NALU。提取出视频数据，将长度码转换为开始码，组成 NALU，将 NALU 写入到文件中。NALU 只要有两种格式：Annex B 和 AVCC。Annex B 格式以 0x 00 00 01 或 0x 00 00 00 01 开头， AVCC 格式以所在 NALU 的长度开头。\n编码后的数据通过步骤一 VTCompressionSessionCreate 方法中参数的回调函数 encodeOutputDataCallback 返回。编码后的数据以及这一帧的基本信息都在 CMSampleBufferRef 中。\nvoid encodeOutputDataCallback(void * CM_NULLABLE outputCallbackRefCon, void * CM_NULLABLE sourceFrameRefCon, OSStatus status, VTEncodeInfoFlags infoFlags, CM_NULLABLE CMSampleBufferRef sampleBuffer){ }。 调用 VTCompressionSessionCompleteFrames 停止编码器\nVT_EXPORT OSStatus VTCompressionSessionCompleteFrames( CM_NONNULL VTCompressionSessionRef\tsession,//编码器句柄 CMTime\tcompleteUntilPresentationTimeStamp//kCMTimeInvalid等 ) 调用 VTCompressionSessionInvalidate 销毁编码器\nVTCompressionSessionInvalidate(编码器句柄compressionSessionRef); CFRelease(编码器句柄compressionSessionRef); _compressionSessionRef = NULL; 代码示范：\n#import \u0026lt;VideoToolbox/VideoToolbox.h\u0026gt; @interface Nextvc () { NSInteger frameID; VTCompressionSessionRef cEncodeingSession;//编码器上下文 dispatch_queue_t cEncodeQueue; } //videoToolbox硬编码 -(void)videoToolboxHardEncode{ frameID = 0; int width = 480,height = 640; //创建编码session OSStatus status = VTCompressionSessionCreate(NULL, width, height, kCMVideoCodecType_H264, NULL, NULL, NULL, didCompressH264, (__bridge void *)(self), \u0026amp;cEncodeingSession); NSLog(@\u0026#34;H264:VTCompressionSessionCreate:%d\u0026#34;,(int)status); if (status != 0) { NSLog(@\u0026#34;H264:Unable to create a H264 session\u0026#34;); return ; } /** 设置编码器属性 */ //设置实时编码输出（避免延迟） VTSessionSetProperty(cEncodeingSession, kVTCompressionPropertyKey_RealTime, kCFBooleanTrue); VTSessionSetProperty(cEncodeingSession, kVTCompressionPropertyKey_ProfileLevel,kVTProfileLevel_H264_Baseline_AutoLevel); //是否产生B帧(因为B帧在解码时并不是必要的,是可以抛弃B帧的) VTSessionSetProperty(cEncodeingSession, kVTCompressionPropertyKey_AllowFrameReordering, kCFBooleanFalse); //设置关键帧（GOPsize）间隔，GOP太小的话图像会模糊 int frameInterval = 10; CFNumberRef frameIntervalRaf = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, \u0026amp;frameInterval); VTSessionSetProperty(cEncodeingSession, kVTCompressionPropertyKey_MaxKeyFrameInterval, frameIntervalRaf); //设置期望帧率，不是实际帧率 int fps = 10; CFNumberRef fpsRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, \u0026amp;fps); VTSessionSetProperty(cEncodeingSession, kVTCompressionPropertyKey_ExpectedFrameRate, fpsRef); //码率的理解：码率大了话就会非常清晰，但同时文件也会比较大。码率小的话，图像有时会模糊，但也勉强能看 //码率计算公式，参考印象笔记 //设置码率、上限、单位是bps int bitRate = width * height * 3 * 4 * 8; CFNumberRef bitRateRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, \u0026amp;bitRate); VTSessionSetProperty(cEncodeingSession, kVTCompressionPropertyKey_AverageBitRate, bitRateRef); //设置码率，均值，单位是byte int bigRateLimit = width * height * 3 * 4; CFNumberRef bitRateLimitRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, \u0026amp;bigRateLimit); VTSessionSetProperty(cEncodeingSession, kVTCompressionPropertyKey_DataRateLimits, bitRateLimitRef); //准备编码 VTCompressionSessionPrepareToEncodeFrames(cEncodeingSession); } /** 输入待编码数据CMSampleBufferRef，开始编码 @param sampleBuffer 待编码数据，可以是从摄像头获取的数据，也可以是从视频文件中获取的数据 @param forceKeyFrame 是否强制I帧 @return 结果 */ - (BOOL)videoEncodeInputData:(CMSampleBufferRef)sampleBuffer forceKeyFrame:(BOOL)forceKeyFrame { if (NULL == cEncodeingSession) { return NO; } if (nil == sampleBuffer) { return NO; } CMTime presentationTimeStamp = CMTimeMake(frameID++, 1000); // CMTimeMake(分子，分母)；分子/分母 = 时间(秒) CVImageBufferRef pixelBuffer = (CVImageBufferRef)CMSampleBufferGetImageBuffer(sampleBuffer); NSDictionary *frameProperties = @{(__bridge NSString *)kVTEncodeFrameOptionKey_ForceKeyFrame: @(forceKeyFrame)}; OSStatus status = VTCompressionSessionEncodeFrame(cEncodeingSession, pixelBuffer, kCMTimeInvalid, kCMTimeInvalid, (__bridge CFDictionaryRef)frameProperties, NULL, NULL);//第三个参数可以换成presentationTimeStamp if (noErr != status) { NSLog(@\u0026#34;VEVideoEncoder::VTCompressionSessionEncodeFrame failed! status:%d\u0026#34;, (int)status); return NO; } return YES; } //VideoToolBox硬编码回调 void didCompressH264(void *outputCallbackRefCon, void *sourceFrameRefCon, OSStatus status, VTEncodeInfoFlags infoFlags, CMSampleBufferRef sampleBuffer) { if (noErr != status || nil == sampleBuffer) { NSLog(@\u0026#34;VEVideoEncoder::encodeOutputCallback Error : %d!\u0026#34;, (int)status); return; } if (nil == outputCallbackRefCon) { return; } if (!CMSampleBufferDataIsReady(sampleBuffer)) { return; } if (infoFlags \u0026amp; kVTEncodeInfo_FrameDropped) { NSLog(@\u0026#34;VEVideoEncoder::H264 encode dropped frame.\u0026#34;); return; } Nextvc *encoder = (__bridge Nextvc *)outputCallbackRefCon; const char header[] = \u0026#34;\\x00\\x00\\x00\\x01\u0026#34;; size_t headerLen = (sizeof header) - 1; // 最后一位是\\0结束符，要减掉 NSData *headerData = [NSData dataWithBytes:header length:headerLen]; // // 判断是否是关键帧 // bool isKeyFrame = !CFDictionaryContainsKey((CFDictionaryRef)CFArrayGetValueAtIndex(CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, true), 0), (const void *)kCMSampleAttachmentKey_NotSync); //判断当前帧是否为关键帧 CFArrayRef array = CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, true); CFDictionaryRef dic = CFArrayGetValueAtIndex(array, 0); bool isKeyFrame = !CFDictionaryContainsKey(dic, kCMSampleAttachmentKey_NotSync); if (isKeyFrame) { NSLog(@\u0026#34;VEVideoEncoder::编码了一个关键帧\u0026#34;); //图像的存储方式，编解码器等格式描述 CMFormatDescriptionRef formatDescriptionRef = CMSampleBufferGetFormatDescription(sampleBuffer); /*关键帧需要加上SPS、PPS信息 获取sps \u0026amp; pps 数据 只获取1次，保存在h264文件开头的第一帧中 sps(sample per second 采样次数/s),是衡量模数转换（ADC）时采样速率的单位 CMVideoFormatDescriptionGetH264ParameterSetAtIndex获取sps和pps信息，并转换为二进制写入文件或者进行上传 */ size_t sParameterSetSize;//参数集合占的字节大小 size_t sParameterSetCount;//参数集合元素个数 const uint8_t *sParameterSet;//参数集合 OSStatus spsStatus = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(formatDescriptionRef, 0, \u0026amp;sParameterSet, \u0026amp;sParameterSetSize, \u0026amp;sParameterSetCount, 0);//index为0的位置是sps； size_t pParameterSetSize, pParameterSetCount; const uint8_t *pParameterSet; OSStatus ppsStatus = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(formatDescriptionRef, 1, \u0026amp;pParameterSet, \u0026amp;pParameterSetSize, \u0026amp;pParameterSetCount, 0);//index为1的位置是pps； if (noErr == spsStatus \u0026amp;\u0026amp; noErr == ppsStatus) { //把sps和pps参数集合转换成二进制数据，组装成sps帧和pps帧； NSData *sps = [NSData dataWithBytes:sParameterSet length:sParameterSetSize]; NSData *pps = [NSData dataWithBytes:pParameterSet length:pParameterSetSize]; NSMutableData *spsData = [NSMutableData data]; [spsData appendData:headerData]; [spsData appendData:sps]; NSMutableData *ppsData = [NSMutableData data]; [ppsData appendData:headerData]; [ppsData appendData:pps]; } } //获取编码后的h264流数据 CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(sampleBuffer); size_t length;//单个NALU长度 size_t totalLength;//所有NALU总长度 char *dataPointer;//指针偏移 // 通过 首地址blockBuffer 、单个长度length、 总长度totalLength通过dataPointer指针偏移做遍历 status = CMBlockBufferGetDataPointer(blockBuffer, 0, \u0026amp;length, \u0026amp;totalLength, \u0026amp;dataPointer); if (noErr != status) { NSLog(@\u0026#34;VEVideoEncoder::CMBlockBufferGetDataPointer Error : %d!\u0026#34;, (int)status); return; } size_t bufferOffset = 0;//Nalu的开始位置，每次增加加一个stratcode+nalu的长度 static const int avcHeaderLength = 4;//返回的nalu数据前4个字节不是0x00000001的startcode,而是大端模式的帧长度length,读取数据时有个大小端模式：网络传输一般都是大端模式 while (bufferOffset \u0026lt; totalLength - avcHeaderLength) { // 读取 一单元长度的nalu数据 uint32_t nalUnitLength = 0; memcpy(\u0026amp;nalUnitLength, dataPointer + bufferOffset, avcHeaderLength);//目标地址，源地址，字节数，（从源地址拷贝n个字节到目标地址），这里其实是设置每个nalUnitLength的值，即各个Nalu的长度 // 大端转小端(系统端是小端序) nalUnitLength = CFSwapInt32BigToHost(nalUnitLength); //获取nalu数据 NSData *frameData = [[NSData alloc] initWithBytes:(dataPointer + bufferOffset + avcHeaderLength) length:nalUnitLength]; //Nalu头+NALU数据 NSMutableData *outputFrameData = [NSMutableData data]; [outputFrameData appendData:headerData]; [outputFrameData appendData:frameData]; //可以把outputFrameData写入文件，然后就得到了H264编码的文件。 //读取下一个nalu 一次回调可能包含多个nalu数据， bufferOffset += avcHeaderLength + nalUnitLength; } } audioToolBox 硬编码\n编码步骤：\n配置编码参数、获取编码器描述 description、获取编码器 设置缓冲列表 AudioBufferList 开始编码，将数据写入编码器 AudioConverterFillComplexBuffer， 在回调函数中，将数据写入缓冲区 编码完成后，获取缓冲区列表数据 outAudioBUfferList，添加 ADTS 头 将数据写入文件 代码示例：\n{ AudioConverterRef _audioConverter;//音频编码上下文 size_t _pcmBufferSize; char *_pcmBuffer; size_t _aacBufferSize; char *_aacBuffer; } @property(nonatomic,strong)NSFileHandle *audioFileHandle; @property(nonatomic,strong)dispatch_queue_t encoderQueue;) //创建存储音频的文件，先移除以前的文件，再重新创建 - (NSFileHandle *)audioFileHandle { if (!_audioFileHandle) { NSString *documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject; NSString * filePath = [documentPath stringByAppendingPathComponent:@\u0026#34;demo01.aac\u0026#34;]; [[NSFileManager defaultManager] removeItemAtPath:filePath error:nil]; BOOL createFile = [[NSFileManager defaultManager] createFileAtPath:filePath contents:nil attributes:nil]; NSAssert(createFile, @\u0026#34;create audio path error\u0026#34;); _audioFileHandle = [NSFileHandle fileHandleForWritingAtPath:filePath]; } return _audioFileHandle; } - (id)init { if (self = [super init]) { _encoderQueue = dispatch_queue_create(\u0026#34;aac encode queue\u0026#34;, DISPATCH_QUEUE_SERIAL); _audioConverter = NULL; _pcmBufferSize = 0; _pcmBuffer = NULL; _aacBufferSize = 1024; _aacBuffer = malloc(_aacBufferSize * sizeof(uint8_t)); memset(_aacBuffer, 0, _aacBufferSize); } return self; } //停止编码 - (void)stopEncodeAudio { [self.audioFileHandle closeFile]; self.audioFileHandle = NULL; } // 配置编码参数 - (void)setupEncoderFromSampleBuffer:(CMSampleBufferRef)sampleBuffer { NSLog(@\u0026#34;开始配置编码参数。。。。\u0026#34;); /* AudioStreamBasicDescription是输入输出流的结构体描述， */ // 获取原音频声音格式设置 AudioStreamBasicDescription inAudioStreamBasicDescription = *CMAudioFormatDescriptionGetStreamBasicDescription((CMAudioFormatDescriptionRef)CMSampleBufferGetFormatDescription(sampleBuffer)); AudioStreamBasicDescription outAudioStreamBasicDescription = {0}; /* 设置输出格式参数 */ // 采样率，音频流，在正常播放情况下的帧率。如果是压缩的格式，这个属性表示解压缩后的帧率。帧率不能为0。 outAudioStreamBasicDescription.mSampleRate = inAudioStreamBasicDescription.mSampleRate; // 格式 kAudioFormatMPEG4AAC = \u0026#39;aac\u0026#39; , outAudioStreamBasicDescription.mFormatID = kAudioFormatMPEG4AAC; // 标签格式 无损编码 ， 无损编码 ，0表示没有 outAudioStreamBasicDescription.mFormatFlags = kMPEG4Object_AAC_LC; // 每一个packet的音频数据大小。如果的动态大小，设置为0。动态大小的格式，需要用AudioStreamPacketDescription 来确定每个packet的大小。 outAudioStreamBasicDescription.mBytesPerPacket = 0; // 每个packet的帧数。如果是未压缩的音频数据，值是1。动态帧率格式，这个值是一个较大的固定数字，比如说AAC的1024。如果是动态大小帧数（比如Ogg格式）设置为0。 outAudioStreamBasicDescription.mFramesPerPacket = 1024; // 每帧的大小。每一帧的起始点到下一帧的起始点。如果是压缩格式，设置为0 。 outAudioStreamBasicDescription.mBytesPerFrame = 0; // 声道数：1 单声道 2 立体声 outAudioStreamBasicDescription.mChannelsPerFrame = 1; // 每采样点占用位数 outAudioStreamBasicDescription.mBitsPerChannel = 0; // 保留参数（对齐当时）8字节对齐，填0. outAudioStreamBasicDescription.mReserved = 0; // 获取编码器描述 AudioClassDescription * description = [self getAudioClassDescriptionWithType:kAudioFormatMPEG4AAC fromManufacturer:kAppleSoftwareAudioCodecManufacturer]; // 创建编码器 /* inAudioStreamBasicDescription 传入源音频格式 outAudioStreamBasicDescription 目标音频格式 第三个参数：传入音频编码器的个数 description 传入音频编码器的描述 */ OSStatus status = AudioConverterNewSpecific(\u0026amp;inAudioStreamBasicDescription, \u0026amp;outAudioStreamBasicDescription, 1, description, \u0026amp;_audioConverter); if (status != 0) { NSLog(@\u0026#34;创建编码器失败\u0026#34;); } } // 获取编码器描述 /*type 编码格式 manufacturer 软/硬编 kAppleHardwareAudioCodecManufacturer、kAppleSoftwareAudioCodecManufacturer */ - (AudioClassDescription *)getAudioClassDescriptionWithType:(UInt32)type fromManufacturer:(UInt32)manufacturer { NSLog(@\u0026#34;开始获取编码器。。。。\u0026#34;); // 选择aac编码 /*AudioClassDescription结构体包含以下成员 OSType mType; OSType mSubType; OSType mManufacturer; */ static AudioClassDescription desc; UInt32 encoderS = type; OSStatus status; UInt32 size; /*获取所用有的编码器属性信息 kAudioFormatProperty_Encoders 编码ID 编码说明大小 编码类型 属性当前值的大小 */ status = AudioFormatGetPropertyInfo(kAudioFormatProperty_Encoders, sizeof(encoderS), \u0026amp;encoderS, \u0026amp;size); if (status) { NSLog(@\u0026#34;编码aac错误\u0026#34;); return nil; } // 计算编码器的个数 unsigned int count = size / sizeof(AudioClassDescription); // 定义编码器数组 AudioClassDescription description[count]; //分配编码器属性信息到数组 status = AudioFormatGetProperty(kAudioFormatProperty_Encoders, sizeof(encoderS), \u0026amp;encoderS, \u0026amp;size, description); for (unsigned int i = 0; i \u0026lt; count; i++) { if (type == description[i].mSubType \u0026amp;\u0026amp; manufacturer == description[i].mManufacturer) { // 拷贝编码器到desc memcpy(\u0026amp;desc, \u0026amp;description[i], sizeof(desc)); NSLog(@\u0026#34;找到aac编码器\u0026#34;); return \u0026amp;desc; } } return nil; } // 编码数据 - (void)encodeAudioSampleBuffer:(CMSampleBufferRef)sampleBuffer { CFRetain(sampleBuffer); dispatch_sync(_encoderQueue, ^{ if (!_audioConverter) { // 配置编码参数 [self setupEncoderFromSampleBuffer:sampleBuffer]; } // 获取CMBlockBufferRef CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(sampleBuffer); CFRetain(blockBuffer); // 获取_pcmBufferSize 和 _pcmBuffer OSStatus status = CMBlockBufferGetDataPointer(blockBuffer, 0, NULL, \u0026amp;self-\u0026gt;_pcmBufferSize, \u0026amp;self-\u0026gt;_pcmBuffer); if (status != kCMBlockBufferNoErr) { NSLog(@\u0026#34;获取 pcmBuffer 数据错误\u0026#34;); return ; } // 清空 memset(self-\u0026gt;_aacBuffer, 0, self-\u0026gt;_aacBufferSize); // 初始化缓冲列表 AudioBufferList outAudioBufferList = {0}; // 结构体 // 缓冲区个数 outAudioBufferList.mNumberBuffers = 1; // 渠道个数 outAudioBufferList.mBuffers[0].mNumberChannels = 1; // 缓存区大小 outAudioBufferList.mBuffers[0].mDataByteSize = (int)self-\u0026gt;_aacBufferSize; // 缓冲区内容 outAudioBufferList.mBuffers[0].mData = self-\u0026gt;_aacBuffer; // 编码 AudioStreamPacketDescription * outPD = NULL; UInt32 inPutSize = 1; /* _audioConverter 音频编码上下文 inInputDataProc 自己实现的编码数据的callback引用 self 获取的数据 inPutSize 输出数据的长度 outAudioBUfferList 输出的缓冲区列表数据 outPD 输出数据的描述 */ status = AudioConverterFillComplexBuffer(self-\u0026gt;_audioConverter, inInputDataProc, (__bridge void*)self, \u0026amp;inPutSize, \u0026amp;outAudioBufferList, outPD ); // 编码后完成,AudioConverterFillComplexBuffer方法返回的是AAC原始码流，需要在AAC每帧添加ADTS头 NSData * data = nil; if (status == noErr) { // 获取缓冲区的原始数据acc数据 NSData * rawAAC = [NSData dataWithBytes:outAudioBufferList.mBuffers[0].mData length:outAudioBufferList.mBuffers[0].mDataByteSize]; // 加头ADTS NSData * adtsHeader = [self adtsDataForPacketLength:rawAAC.length]; NSMutableData * fullData = [NSMutableData dataWithData:adtsHeader]; [fullData appendData:rawAAC]; data = fullData; } else { NSLog(@\u0026#34;数据错误\u0026#34;); return; } // 写入数据 [self.audioFileHandle writeData:data]; CFRelease(sampleBuffer); CFRelease(blockBuffer); }); } // audioToolBox回调函数，将数据写入缓冲区 OSStatus inInputDataProc(AudioConverterRef inAudioConverter, UInt32 *ioNumberDataPackets, AudioBufferList *ioData, AudioStreamPacketDescription **outDataPacketDescription, void *inUserData) { // 编码器 Nextvc *encoder = (__bridge Nextvc *) inUserData; // 编码包的数据 UInt32 requestPackes = *ioNumberDataPackets; // 将ioData填充到缓冲区 size_t cp = [encoder copyPCMSamplesIntoBuffer:ioData]; if (cp \u0026lt; requestPackes) { //PCM 缓冲区还没满 *ioNumberDataPackets = 0; // 清空 return -1; } *ioNumberDataPackets = 1; return noErr; } // pcm -\u0026gt; 缓冲区 - (size_t)copyPCMSamplesIntoBuffer:(AudioBufferList*)ioData { // 获取pcm大小 size_t os = _pcmBufferSize; if (!_pcmBufferSize) { return 0; } ioData-\u0026gt;mBuffers[0].mData = _pcmBuffer; ioData-\u0026gt;mBuffers[0].mDataByteSize = (int)_pcmBufferSize; // 清空 _pcmBuffer = NULL; _pcmBufferSize = 0; return os; } /** * Add ADTS header at the beginning of each and every AAC packet. * This is needed as MediaCodec encoder generates a packet of raw * AAC data. * * Note the packetLen must count in the ADTS header itself. 注意：packetLen 必须在ADTS头身计算 **/ - (NSData*)adtsDataForPacketLength:(NSUInteger)packetLength { int adtsLength = 7; char *packet = malloc(sizeof(char) * adtsLength); int profile = 2; int freqIdx = 4; int chanCfg = 1; NSUInteger fullLength = adtsLength + packetLength; packet[0] = (char)0xFF; packet[1] = (char)0xF9; packet[2] = (char)(((profile-1)\u0026lt;\u0026lt;6) + (freqIdx\u0026lt;\u0026lt;2) +(chanCfg\u0026gt;\u0026gt;2)); packet[3] = (char)(((chanCfg\u0026amp;3)\u0026lt;\u0026lt;6) + (fullLength\u0026gt;\u0026gt;11)); packet[4] = (char)((fullLength\u0026amp;0x7FF) \u0026gt;\u0026gt; 3); packet[5] = (char)(((fullLength\u0026amp;7)\u0026lt;\u0026lt;5) + 0x1F); packet[6] = (char)0xFC; NSData *data = [NSData dataWithBytesNoCopy:packet length:adtsLength freeWhenDone:YES]; return data; } FFmpeg 中的硬编码：\nFFmpeg 中的硬编码有 videotoolbox（苹果的 ios 和 MACos）、mediacodec（安卓的）、qsv（Intel 的 LIBMFX api）、DXVA（是微软定制的视频加速规范，如 DXVA2 / D3D11VA）、VDPAU（在 Linux 平台上由 NVIDIA 指定的加速规范）、VAAPI（在 Linux 平台上由 Intel 提供的加速规范） Intel 支持的硬编码：\nwindows：libmfx（Intel 自己的 api，FFmpeg 中 qsv 技术对外接口就是 LIBMF）、DXVA2 / D3D11VA（微软出的对 Intel 支持的 api，FFmpeg 中有封装）、Media Foundation（微软出的对 Intel 支持的 api） linux：VAAPI（Intel 自己的 api，FFmpeg 中有封装）、libmfx（Intel 自己的 api，FFmpeg 中 qsv 技术对外接口就是 LIBMF） NVIDIA 支持的硬编码：\nwindows：CUDA（NVIDIA 自己的 api，FFmpeg 中封装包含 NVENC（硬编码）和 NVCUVID（硬解码）） linux：CUDA（NVIDIA 自己的 api，FFmpeg 中封装包含 NVENC（硬编码）和 NVCUVID（硬解码））、VDPAU（FFmpeg 中有封装） 硬解码：\n问题和优化方案：https://www.jianshu.com/p/57581485717b\n硬编解码图示：https://www.cnblogs.com/edisongz/p/7062098.html\nvideoToolBox 硬解码\nNALU + SPS,PPS—\u0026gt;CMBlockBuffer—\u0026gt;CMSampleBufferRef，再将CMSampleBufferRef包装的帧数据输入到 VTDecompressionSessionDecodeFrame，通过回调中CVImageBufferRef 直接上传OpenGL ES 显示。 序列参数集SPS（sequence Parameter Set）：作用于一系列连续的编码图像 图像参数集PPS(Picture Parameter Set)：作用于编码视频序列中一个或多个独立的图像； 硬解码流程：\n1、解析 H264 数据\n解码前的 CMSampleBuffer = CMTime + FormatDesc + CMBlockBuffer。需要从 H264 的码流里面提取出以上的三个信息。最后组合成 CMSampleBuffer，提供给硬解码接口来进行解码工作。\nNALU 单元包含视频图像数据和 H264 的参数信息。其中视频图像数据就是 CMBlockBuffer，而 H264 的参数信息则可以组合成 FormatDesc。\n2、初始化解码器（VTDecompressionSessionCreate）\n3、将解析后的 H264 数据送入解码器（VTDecompressionSessionDecodeFrame）\n4、解码器回调输出解码后的数据（CVImageBufferRef）\n代码示例：\n/** sps数据 */ @property (nonatomic, assign) uint8_t *sps; /** sps数据长度 */ @property (nonatomic, assign) NSInteger spsSize; /** pps数据 */ @property (nonatomic, assign) uint8_t *pps; /** pps数据长度 */ @property (nonatomic, assign) NSInteger ppsSize; /** 解码器句柄 */ @property (nonatomic, assign) VTDecompressionSessionRef deocderSession; /** 视频解码信息句柄 */ @property (nonatomic, assign) CMVideoFormatDescriptionRef decoderFormatDescription; /* *读取本地视频文件 */ /** 解码NALU数据 @param naluData NALU数据 */ -(void)decodeNaluData:(NSData *)naluData { uint8_t *frame = (uint8_t *)naluData.bytes; uint32_t frameSize = (uint32_t)naluData.length; // frame的前4位是NALU数据的开始码，也就是00 00 00 01，第5个字节是表示数据类型，转为10进制后，7是sps,8是pps,5是IDR（I帧）信息 int nalu_type = (frame[4] \u0026amp; 0x1F); /* 将NALU的开始码替换成NALU的长度信息 方法一： */ // uint32_t nalSize = (uint32_t)(frameSize - 4); // uint8_t *pNalSize = (uint8_t*)(\u0026amp;nalSize); // frame[0] = *(pNalSize + 3); // frame[1] = *(pNalSize + 2); // frame[2] = *(pNalSize + 1); // frame[3] = *(pNalSize); //方法二： uint32_t nalSize = (uint32_t)(frameSize - 4); uint32_t *pNalSize = (uint32_t *)frame; *pNalSize = CFSwapInt32HostToBig(nalSize); switch (nalu_type) { case 0x05: // I帧 NSLog(@\u0026#34;NALU type is IDR frame\u0026#34;); if([self initH264Decoder]) { [self decode:frame withSize:frameSize]; } break; case 0x07: // SPS NSLog(@\u0026#34;NALU type is SPS frame\u0026#34;); _spsSize = frameSize - 4; _sps = malloc(_spsSize); memcpy(_sps, \u0026amp;frame[4], _spsSize); break; case 0x08: // PPS NSLog(@\u0026#34;NALU type is PPS frame\u0026#34;); _ppsSize = frameSize - 4; _pps = malloc(_ppsSize); memcpy(_pps, \u0026amp;frame[4], _ppsSize); break; default: // B帧或P帧 NSLog(@\u0026#34;NALU type is B/P frame\u0026#34;); if([self initH264Decoder]) { [self decode:frame withSize:frameSize]; } break; } } /** 初始化解码器 @return 结果 */ -(BOOL)initH264Decoder { if(_deocderSession) { return YES; } const uint8_t* const parameterSetPointers[2] = {_sps, _pps}; const size_t parameterSetSizes[2] = {_spsSize, _ppsSize}; // 根据sps pps创建解码视频参数 OSStatus status = CMVideoFormatDescriptionCreateFromH264ParameterSets(kCFAllocatorDefault, 2, parameterSetPointers, parameterSetSizes, 4, \u0026amp;_decoderFormatDescription); if(status != noErr) { NSLog(@\u0026#34;H264Decoder::CMVideoFormatDescriptionCreateFromH264ParameterSets failed status = %d\u0026#34;, (int)status); } // 从sps pps中获取解码视频的宽高信息 CMVideoDimensions dimensions = CMVideoFormatDescriptionGetDimensions(_decoderFormatDescription); // kCVPixelBufferPixelFormatTypeKey 解码图像的采样格式 // kCVPixelBufferWidthKey、kCVPixelBufferHeightKey 解码图像的宽高 // kCVPixelBufferOpenGLCompatibilityKey制定支持OpenGL渲染，经测试有没有这个参数好像没什么差别 NSDictionary* destinationPixelBufferAttributes = @{(id)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange), (id)kCVPixelBufferWidthKey : @(dimensions.width), (id)kCVPixelBufferHeightKey : @(dimensions.height), (id)kCVPixelBufferOpenGLCompatibilityKey : @(YES)}; // 设置解码输出数据回调 VTDecompressionOutputCallbackRecord callBackRecord; callBackRecord.decompressionOutputCallback = decodeOutputDataCallback; callBackRecord.decompressionOutputRefCon = (__bridge void *)self; // 创建解码器 status = VTDecompressionSessionCreate(kCFAllocatorDefault, _decoderFormatDescription, NULL, (__bridge CFDictionaryRef)destinationPixelBufferAttributes, \u0026amp;callBackRecord, \u0026amp;_deocderSession); // 解码线程数量 VTSessionSetProperty(_deocderSession, kVTDecompressionPropertyKey_ThreadCount, (__bridge CFTypeRef)@(1)); // 是否实时解码 VTSessionSetProperty(_deocderSession, kVTDecompressionPropertyKey_RealTime, kCFBooleanTrue); return YES; } /** 解码数据 @param frame 数据 @param frameSize 数据长度 */ -(void)decode:(uint8_t *)frame withSize:(uint32_t)frameSize { CMBlockBufferRef blockBuffer = NULL; // 创建 CMBlockBufferRef OSStatus status = CMBlockBufferCreateWithMemoryBlock(NULL, (void *)frame, frameSize, kCFAllocatorNull, NULL, 0, frameSize, FALSE, \u0026amp;blockBuffer); if(status != kCMBlockBufferNoErr) { return; } CMSampleBufferRef sampleBuffer = NULL; const size_t sampleSizeArray[] = {frameSize}; // 创建 CMSampleBufferRef status = CMSampleBufferCreateReady(kCFAllocatorDefault, blockBuffer, _decoderFormatDescription , 1, 0, NULL, 1, sampleSizeArray, \u0026amp;sampleBuffer); if (status != kCMBlockBufferNoErr || sampleBuffer == NULL) { return; } // VTDecodeFrameFlags 0为允许多线程解码 VTDecodeFrameFlags flags = 0; VTDecodeInfoFlags flagOut = 0; // 解码 这里第四个参数会传到解码的callback里的sourceFrameRefCon，可为空 OSStatus decodeStatus = VTDecompressionSessionDecodeFrame(_deocderSession, sampleBuffer, flags, NULL, \u0026amp;flagOut); if(decodeStatus == kVTInvalidSessionErr) { NSLog(@\u0026#34;H264Decoder::Invalid session, reset decoder session\u0026#34;); } else if(decodeStatus == kVTVideoDecoderBadDataErr) { NSLog(@\u0026#34;H264Decoder::decode failed status = %d(Bad data)\u0026#34;, (int)decodeStatus); } else if(decodeStatus != noErr) { NSLog(@\u0026#34;H264Decoder::decode failed status = %d\u0026#34;, (int)decodeStatus); } // Create了就得Release CFRelease(sampleBuffer); CFRelease(blockBuffer); return; } //解码回调函数 static void decodeOutputDataCallback(void *decompressionOutputRefCon, void *sourceFrameRefCon, OSStatus status, VTDecodeInfoFlags infoFlags, CVImageBufferRef pixelBuffer, CMTime presentationTimeStamp, CMTime presentationDuration) { // retain再输出，外层去release；pixelBuffer就是解码后的数据 CVPixelBufferRetain(pixelBuffer); Nextvc *decoder = (__bridge Nextvc *)decompressionOutputRefCon; } CMSampleBufferRef转换成YUV数据、YUV数据类型的变换： /* 1. CMSampleBufferRef 中提取yuv数据(Byte) 2. 处理yuv数据 3. yuv数据 转CVPixelBufferRef ，继续进行编码 */ -(CVPixelBufferRef)processYUV422ToYUV420WithSampleBuffer:(CMSampleBufferRef)sampleBuffer { // 1. 从CMSampleBufferRef中提取yuv数据 // 获取yuv数据 // 通过CMSampleBufferGetImageBuffer方法，获得CVImageBufferRef。 // 这里面就包含了yuv420数据的指针 CVImageBufferRef pixelBuffer_Before = CMSampleBufferGetImageBuffer(sampleBuffer); //表示开始操作数据 CVPixelBufferLockBaseAddress(pixelBuffer_Before, 0); //图像宽度（像素） size_t pixelWidth = CVPixelBufferGetWidth(pixelBuffer_Before); //图像高度（像素） size_t pixelHeight = CVPixelBufferGetHeight(pixelBuffer_Before); //yuv中的y所占字节数 size_t y_size = pixelWidth * pixelHeight; // 2. yuv中的u和v分别所占的字节数 size_t uv_size = y_size / 4; uint8_t *yuv_frame = malloc(uv_size * 2 + y_size); //获取CVImageBufferRef中的y数据 uint8_t *y_frame = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer_Before, 0); memcpy(yuv_frame, y_frame, y_size); //获取CMVImageBufferRef中的uv数据 uint8_t *uv_frame = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer_Before, 1); memcpy(yuv_frame + y_size, uv_frame, uv_size * 2); CVPixelBufferUnlockBaseAddress(pixelBuffer_Before, 0); NSData *yuvData = [NSData dataWithBytesNoCopy:yuv_frame length:y_size + uv_size * 2]; // 3. yuv 变成 转CVPixelBufferRef //现在要把NV12数据放入 CVPixelBufferRef中，因为 硬编码主要调用VTCompressionSessionEncodeFrame函数，此函数不接受yuv数据，但是接受CVPixelBufferRef类型。 CVPixelBufferRef pixelBuf_After = NULL; //初始化pixelBuf，数据类型是kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange，此类型数据格式同NV12格式相同。 CVPixelBufferCreate(NULL, pixelWidth, pixelHeight, kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange, NULL, \u0026amp;pixelBuf_After); // Lock address，锁定数据，应该是多线程防止重入操作。 if(CVPixelBufferLockBaseAddress(pixelBuf_After, 0) != kCVReturnSuccess){ NSLog(@\u0026#34;encode video lock base address failed\u0026#34;); return NULL; } //将yuv数据填充到CVPixelBufferRef中 uint8_t *yuv_frame_2 = (uint8_t *)yuvData.bytes; //处理y frame uint8_t *y_frame_2 = CVPixelBufferGetBaseAddressOfPlane(pixelBuf_After, 0); memcpy(y_frame_2, yuv_frame_2, y_size); uint8_t *uv_frame_2 = CVPixelBufferGetBaseAddressOfPlane(pixelBuf_After, 1); memcpy(uv_frame_2, yuv_frame_2 + y_size, uv_size * 2); CVPixelBufferUnlockBaseAddress(pixelBuf_After, 0); return pixelBuf_After; } 软硬编码对比：\n软编码：实现直接、简单，参数调整方便，升级易，但 CPU 负载重，性能较硬编码低，低码率下质量通常比硬编码要好一点。 硬编码：性能高，低码率下通常质量低于软编码器，但部分产品在 GPU 硬件平台移植了优秀的软编码算法（如 X264）的，质量基本等同于软编码。 苹果在 iOS 8.0 系统之前，没有开放系统的硬件编码解码功能，不过 Mac OS 系统一直有，被称为 Video ToolBox 的框架来处理硬件的编码和解码，终于在 iOS 8.0 后，苹果将该框架引入 iOS 系统。\n.H265 优点\n压缩比高，在相同图片质量情况下，比 JPEG 高两倍 能增加如图片的深度信息，透明通道等辅助图片。 支持存放多张图片，类似相册和集合。(实现多重曝光的效果) 支持多张图片实现 GIF 和 livePhoto 的动画效果。 无类似 JPEG 的最大像素限制 支持透明像素 分块加载机制 支持缩略图 在 iOS 平台上做视频的解码，一般有三种方案：\n软解码方案：ffmpeg\n缺点：消耗 CPU 太大 硬解码方案 1：采用私有接口 VideoToolBox\n优点：CPU 消耗极低，解码效率极高\n缺点：要使用私有接口 VideoToolBox 硬解码方案 2：采用 AVPlayer＋httpserver＋HttpLiveStream 的组合方案\n优点：CPU 消耗极低，解码效率极高\n缺点：视频有延迟，不适合实时视频通讯 ","date":"2020-03-09T00:00:00Z","permalink":"https://fanmain.github.io/post/media/01_ios-%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81/","title":"iOS 音视频编解码"},{"content":"目录\n一、冒泡排序：\n二、插入排序：\n三、选择排序：\n四、希尔排序：\n五、堆排序：\n六、快速排序：\n6.1挖坑法：\n6.2左右指针法\n6.3前后指针法：\n七、归并排序：\n八、桶排序：\n九、计数排序：\n9.1绝对映射：\n9.2现对映射：\n十、基数排序： 一、冒泡排序： **1、思路：**通过对待排序序列从前向后（从下标较小的元素开始）,依次对相邻两个元素的值进行两两比较，若发现前一个数大于后一个数则交换，使值较大的元素逐渐从前移向后部，就如果水底下的气泡一样逐渐向上冒。\n2、先以一个数组讲解一下，然后再写代码：\n待排序数组：3，9，-1，10，20\n第一轮排序：\n（1）3，9，-1，10，20 \u0026mdash;-3跟9比较，不交换\n（2）3，-1，9，10，20 \u0026mdash;-9比 -1大，所以9跟 -1交换\n（3）3，-1，9，10，20 \u0026mdash;-9跟10比较，不交换\n（4）3，-1，9，10，20 \u0026mdash;-10跟20比较，不交换\n第一轮过后，将20这个最大的元素固定到了最后的位置。\n在第二轮的时候20不参与冒泡。\n第二轮排序：\n因为20的位置已经固定，所以只对前4个进行排序即可：\n（1）-1，3，9，10，20 \u0026mdash;-3比 -1大，进行交换\n（2）-1，3，9，10，20 \u0026mdash;-3跟9比较，不交换\n（3）-1，3，9，10，20 \u0026mdash;-9跟10比较，不交换\n第二轮过后，将第二大的元素固定到了倒数第二个位置\n第三轮排序：\n10和20的位置已经确定，只需对前三个进行排序\n（1）-1，3，9，10，20 \u0026mdash;-3和-1比较，不交换\n（2）-1，3，9，10，20 \u0026mdash;-3和9比较，不交换\n第三轮过后，将第三大的元素位置确定\n第四轮排序：\n只对前两个元素进行排序\n（1）-1，3，9，10，20 \u0026mdash;-3和-1比较，不交换\n第四轮过后，将第四大的元素位置确定，此时总共5个元素，已经排序好4个，从而最后一个自然而然就是排好序的了\n小结：\n设总的元素个数为n，那么由上边的排序过程可以看出：\n（1）总计需要进行（n-1）轮排序，也就是（n-1）次大循环\n（2）每轮排序比较的次数逐轮减少\n（3）如果发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序\n（4）时间复杂度是O(N^2) 在有序的时候，很快，因为有exchange变量优化了代码\n在乱序的时候很慢很慢。\n#include\u0026lt;stdio.h\u0026gt; void swap(int* a, int* b){ int tmp = *a; *a = *b; *b = tmp; } //冒泡排序 void BubbleSort(int* a, int n) { int end = n - 1;//不能是n，不然会越界 while(end) { int exchange = 0;//优化，比较之后没有交换，说明已经排好了，就break循环 for (int i = 0; i \u0026lt; end; i++) { if (a[i] \u0026lt; a[i + 1]) { swap(\u0026amp;a[i], \u0026amp;a[i + 1]); exchange++; } } if (exchange == 0) break; end--; } } 二、插入排序： 1、思路：\n在待排序的元素中，假设前n-1个元素已有序，现将第n个元素插入到前面已经排好的序列中，使得前n个元素有序。按照此法对所有元素进行插入，直到整个序列有序。\n但我们并不能确定待排元素中究竟哪一部分是有序的，所以我们一开始只能认为第一个元素是有序的，依次将其后面的元素插入到这个有序序列中来，直到整个序列有序为止。\n2、举例：\n如下图的插入扑克牌，当摸到7的时候，会不自觉的与前面的数比较，如果比7大，把大的数向后挪动（swap），然后在第一个小于7的后面插入7\n//插入排序 void InsertSort(int* a, int n) { for (int i = 1; i \u0026lt; n; i++) { if (a[i] \u0026lt; a[i - 1])//先判断，如果i下标的值大于前面的数，就不进入 { int tmp = a[i]; int j; for (j = i - 1; j \u0026gt;= 0 \u0026amp;\u0026amp; a[j] \u0026gt;tmp; j--) { a[j+1] = a[j]; } a[j+1] = tmp; } } } //两次循环就可以实现 //内部循环完成一趟的插入 //外层循环完成插入排序 三、选择排序： 思路：\n1.内层循环一趟找出最小值的下标，与第一个数交换。重复找小，交换的两个操作。\n2.实际上，我们可以一趟选出两个值，一个最大值一个最小值，然后将其放在序列开头和末尾，这样可以使选择排序的效率快一倍。\n但时间复杂度还是O（N^2），效率还是不高\n//选择排序 void SelectSort(int* a, int n) { for (int i = 0; i \u0026lt; n-1; i++)//i\u0026lt;n-1当它是最后一个数的时候不需要进行交换排序 { int min = i; int j; for (j = i; j \u0026lt; n; j++) { if (a[j] \u0026lt; a[min]) { min=j; } } swap(\u0026amp;a[i], \u0026amp;a[min]);//交换函数，前面的代码中有出现，我就不重复写了 } } 四、希尔排序： 思路：\n1.插入排序的优化版，有一个预排序的过程。让大的数快速的跳到后面，小的数快速的跳到前面。\n2.使待排序列接近有序，然后再对该序列进行一次插入排序。\n3.相当于把直接插入排序中的1换成gap而已。 //希尔排序 /*步骤： 1.先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再gap--，重复上述操作。 2.当gap==1时就是直接插入排序，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。*/ void ShellSort(int* a, int n) { //这里相当于把插入排序的1换成gap int gap = n; while (gap\u0026gt;1) { gap = gap / 3 + 1; for (int i = gap; i \u0026lt; n; i++) { if (a[i] \u0026lt; a[i - gap]) { int tmp = a[i]; int j; for (j = i - gap; j \u0026gt;= 0 \u0026amp;\u0026amp; a[j] \u0026gt; tmp; j-=gap)//这里是j-=gap { a[j + gap] = a[j]; } a[j + gap] = tmp; } } } } 五、堆排序： 先来认识堆：\n1.什么是堆？\n大堆：父亲大于儿子 小堆：父亲小于儿子（父亲，儿子是二叉树的概念）\n2.堆的物理结构和逻辑结构？\n物理结构：数组 逻辑结构：完全二叉树\n堆排序包括建堆（向下调整+循环） 堆排序（交换+向下调整）\n1.建堆：\n要建大堆，堆顶的元素和最后一个数交换，然后把size\u0026ndash;，就不会破坏堆的结构\n2.向下调整算法：\n比较两个孩子的大小，选出大的孩子，与父亲比较，如果孩子大于父亲，交换。然后把parent=child，child=parent*2+1；向下调整算法一共会调整h-1次\n//向下调整算法（要满足它下面的都满足堆，才能用） void AdjustDown(int* a, int n, int root) { int parent = root; int child = parent * 2 + 1; while (child \u0026lt; n) { if (child + 1 \u0026lt; n \u0026amp;\u0026amp; a[child] \u0026lt; a[child + 1]) child+=1;//把他移到右孩子那里 if (a[child] \u0026gt; a[parent]) { swap(\u0026amp;a[child], \u0026amp;a[parent]); parent = child; child = parent * 2 + 1; } else break; } } 堆排序 void HeapSort(int* arr, int n) { //建大堆 //从最后一个根开始，就相当于它下面的都满足堆，就可以用向下调整算法 for (int i = (n-1-1)/2; i \u0026gt;= 0; i--)//n-1-1是因为数组的最后一个元素下标是n-1 { AdjustDown(arr, n, i); } //排序 for (int i = n; i \u0026gt; 1; i--) { swap(\u0026amp;arr[0],\u0026amp;arr[i - 1]); AdjustDown(arr, i-1, 0); } } 六、快速排序： 三种快排方法：（一定要自己尝试着去写，会有一些坑，自己写才可以体会）\n1.挖坑法\n2.左右指针法\n3.前后指针法\n6.1挖坑法： 1.思想：\n记第一个数为key，要调整key的位置，使得左边的都要比key的小，右边的数都比key的大。\n2.步骤：\n选出一个数据（一般是最左边或是最右边的）存放在key变量中，在该数据位置形成一个坑\n还是定义一个left和一个right，left从左向右走（当遇到大于key的值时停下来）。right从右向左走（当遇到小于key的值时停下来）。（若在最左边挖坑，则需要right先走；若在最右边挖坑，则需要left先走） 把right的那个小的数放在坑中，在把left那个位置的值放在right那个位置中\n重复操作，直到left\u0026gt;right时结束，完成一趟，把key放在了正确的位置\n最后用分治思想，分成左边和右边，递归。\n//1.挖坑法的快速排序 void QuickSort(int* a,int left,int right) { if (left \u0026gt;= right)//不能写成pivot==left，pivot-1与left不匹配，会报错 { return; } int begin = left,end = right; int key = a[begin];//挖了一个关键字 int pivot = begin;//挖了一个坑 while (begin \u0026lt; end) { //右边找小，一定要先右边找小,放在pivot while (begin \u0026lt; end\u0026amp;\u0026amp;a[end] \u0026gt;= key)//在这里也要判断begin \u0026lt; end,因为这里面end-- { end--; } //小的放在左边的坑里，然后形成新的坑位 a[pivot] = a[end]; pivot = end; //左边找大 while (begin \u0026lt; end \u0026amp;\u0026amp; a[begin] \u0026lt;= key) { begin++; } a[pivot] = a[begin]; pivot = begin; } //begin==end a[pivot] = key; //[left,right] //[left,pivot-1] pivot [pivot+1,right] //如果左子区间和右子区间都有序，就全部有序。那就分治递归。 QuickSort(a, left, pivot - 1); QuickSort(a, pivot+1, right); } 6.2左右指针法 思路：\n1、选出一个key，一般是最左边或是最右边的。\n2、定义一个begin和一个end，begin从左向右走，end从右向左走。（需要注意的是：若选择最左边的数据作为key，则需要end先走；若选择最右边的数据作为key，则需要bengin先走）（考虑到最后的时候相遇点的和key交换）。\n3、在走的过程中，若end遇到小于key的数，则停下，begin开始走，直到begin遇到一个大于key的数时，将begin和right的内容交换，end再次开始走，如此进行下去，直到begin和end最终相遇，此时将相遇点的内容与key交换即可。（选取最左边的值作为key）\n4.此时key的左边都是小于key的数，key的右边都是大于key的数\n5.将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去，直到左右序列只有一个数据，或是左右序列不存在时\nvoid QuickSort(int* a, int left, int right) { if (left \u0026gt;= right) { return; } int begin = left, end = right; int key = begin;//这里与挖坑法不同的地方，因为要交换key的那个数组中那个位置的数，而不是值 while (begin \u0026lt; end) { while (begin \u0026lt; end \u0026amp;\u0026amp; a[end] \u0026gt;= a[key]) { end--; } while (begin \u0026lt; end \u0026amp;\u0026amp; a[begin] \u0026lt;= a[key]) { begin++; } Swap(\u0026amp;a[begin], \u0026amp;a[end]); } Swap(\u0026amp;a[begin], \u0026amp;a[key]); QuickSort(a, left, begin - 1); QuickSort(a, begin + 1, right); } 6.3前后指针法： 思路：\n1、选出一个key，一般是最左边。\n2、起始时，prev指针指向序列开头，cur指针指向prev+1。\n3、让cur一直向前走，当遇到小于a[key]时，让prev向前走一格（这个值一定大于a[key]，因为是cur走过的），然后a[cur]和a[prev]交换。\n经过一次单趟排序，最终也能使得key左边的数据全部都小于key，key右边的数据全部都大于key。\n然后也还是将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去\n用if(left\u0026gt;right)\n{\nreurn;\n}//跳出递归\nvoid QuickSort(int* a, int left,int right) { if (left \u0026gt;= right) { return; } int index=GetMidIndex(a,left, right); swap(\u0026amp;a[left], \u0026amp;a[index]); int key = left; int prev = left; int cur = left+1; while (cur \u0026lt;= right) { if (a[cur] \u0026lt; a[key]) { prev++; swap(\u0026amp;a[cur], \u0026amp;a[prev]); } /*可以简写成cur++， 但是当时一定要注意不要放在if语句的前面，因为if语句里面有让cur与prev交换的，cur==right跳出循环，但是a[cur]超过数组的范围，会越界范围。 while (cur\u0026lt;=right\u0026amp;\u0026amp;a[cur] \u0026gt;= a[key]) { cur++; }*/ cur++; } swap(\u0026amp;a[prev], \u0026amp;a[key]); QuickSort(a, left, prev - 1); QuickSort(a, prev+1,right); } 6.4优化快排 三数取中法：取左端、中间、右端三个数，然后进行比较，将中值数当做key\n否则有序时时间复杂度为O(N^2)\n三数取中法可以套入三种方法中，这里我就写一种\n//三数取中 int GetMidIndex(int* a, int left, int right) { int mid = (left + right) / 2; if (a[mid] \u0026gt;= a[left]) { if (a[mid] \u0026lt;= a[right]) { return mid; } else { if (a[right] \u0026gt;= a[left]) { return right; } else { return left; } } } else//a[left]\u0026gt;a[mid] { if (a[right] \u0026gt;= a[left]) { return left; } else { if (a[right] \u0026gt;= a[mid]) { return right; } else { return mid; } } } } //交换 void swap(int* a, int* b) { int tmp = *a; *a = *b; *b = tmp; } //前后指针法 void QuickSort(int* a, int left,int right) { if (left \u0026gt;= right) { return; } int index=GetMidIndex(a,left, right); swap(\u0026amp;a[left], \u0026amp;a[index]); int key = left; int prev = left; int cur = left+1; while (cur \u0026lt;= right) { if (a[cur] \u0026lt; a[key]) { prev++; swap(\u0026amp;a[cur], \u0026amp;a[prev]); } cur++; } swap(\u0026amp;a[prev], \u0026amp;a[key]); QuickSort(a, left, prev - 1); QuickSort(a, prev+1,right); } 七、归并排序： 思路：\n1.不断的分割数据，让数据的每一段都有序（一个数据相当于有序）\n2.当所有子序列有序的时候，在把子序列归并，形成更大的子序列，最终整个数组有序。\n！！！需要开一个_MergeSort,而不是直接在MergeSort中直接递归，是因为MergeSort中有一个malloc\n归并排序很像二叉树中的后序思想，先递归，递归到最后的时候再合并。！！！\n//归并排序 void _MergeSort(int* a, int left, int right, int* tmp)//在这个函数中调用递归{ if (left \u0026gt;= right) { return; } int mid = (left + right) \u0026gt;\u0026gt; 1; _MergeSort(a, left, mid, tmp); _MergeSort(a, mid+1, right, tmp); //合并 int begin1 = left, end1 = mid; int begin2 = mid + 1, end2 = right; int i = left; while (begin1 \u0026lt;= end1 \u0026amp;\u0026amp; begin2 \u0026lt;= end2) { if (a[begin1] \u0026lt;= a[begin2]) { tmp[i++] = a[begin1++]; } else { tmp[i++] = a[begin2++]; } } while (begin1 \u0026lt;= end1) { tmp[i++] = a[begin1++]; } while (begin2 \u0026lt;= end2) { tmp[i++] = a[begin2++]; } for (int j = left; j \u0026lt;= right; j++) { a[j] = tmp[j]; } } void MergeSort(int* a, int n) { int* tmp = (int*)malloc(sizeof(int) * n); _MergeSort(a, 0, n - 1, tmp); free(tmp); } 八、桶排序： **思路：**大问题化小\n桶排序 (Bucket sort)或所谓的箱排序，是一种分块的排序算法，工作的原理是将数组分到有限数量的桶里，每个桶的大小都相等。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）\n把待排序序列（数组）中的数据根据函数映射方法分配到若干个桶中，在分别对各个桶进行排序，最后依次按顺序取出桶中的数据。\n适用于数据分配均匀，数据比较大，相对集中的情况。\n//桶排序 void bucket_sort(int a[],int size,int bucket_size) { int i,j; //数组，数组长度，桶的大小 //定义动态的指针数组 KeyNode **bucket_num = (KeyNode **)malloc(bucket_size * sizeof(KeyNode*)); for(i = 0;i \u0026lt; bucket_size;i++) { bucket_num[i] = (KeyNode*)malloc(sizeof(KeyNode));//为每个链表定义头结点 bucket_num[i]-\u0026gt;num = 0; bucket_num[i]-\u0026gt;next = NULL; //指针变量初始化为空 } for(j = 0;j \u0026lt; size;j++) //准备插入 { KeyNode *node = (KeyNode *)malloc(sizeof(KeyNode));//定义一个节点 node-\u0026gt;num = a[j]; //数据域存数据 node-\u0026gt;next = NULL; //指向空 int index = a[j]/100; //映射函数 计算桶号 KeyNode *p = bucket_num[index];//p指向链表的头 //链表结构的插入排序 while(p-\u0026gt;next != NULL \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;num \u0026lt;= node-\u0026gt;num) { p = p-\u0026gt;next; //1.链表为空，p-\u0026gt;next==NULL，进入不了循环 } //2.链表不为空，因为链表从无开始按顺序插入，数据为有序的， //可以找到 前一个节点 \u0026lt;= node \u0026lt;=后一个节点 //节点插入链表 node-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next = node; (bucket_num[index]-\u0026gt;num)++; //记录一下该链表中有几个有效节点 } //打印结果 KeyNode * k = NULL; //定义一个空的结构体指针用于储存输出结果 for(i = 0;i \u0026lt; bucket_size;i++) { //for(k = bucket_num[i]-\u0026gt;next;k!=NULL;k=k-\u0026gt;next)//通过最后一个指针指向空 k = bucket_num[i]-\u0026gt;next; for(int m=0;m\u0026lt;bucket_num[i]-\u0026gt;num;m++) //通过头指针记录节点数 { printf(\u0026#34;%d \u0026#34;,k-\u0026gt;num); k=k-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } 九、计数排序： 一种特殊的排序，唯一种没有比较的排序（指没有前后比较，还是有交换的）\n以数组的下标当做数值，有这个数的时候a[i]++;\n局限：适用于整数。数要求集中（否则空间的浪费大）\n9.1绝对映射： int index = 0; int *tmpArr = (int *)malloc(max*sizeof(int)); int *result = (int *)malloc(max*sizeof(int)); for(int k = 0;k\u0026lt;max;k++) { tmpArr[k] = 0; } for (int i = 0; i\u0026lt;count; i++) { tmpArr[arr[i]]++; } for (int j = 0; j\u0026lt;max; j++) { while (tmpArr[j]) { result[index++] = j; tmpArr[j]--; } } free(tmpArr); tmpArr = NULL; return result; } 9.2现对映射： void CountSort(int* a, int n) { int max = a[0], min = a[0]; for (int i = 0; i \u0026lt; n; i++) { if (a[i] \u0026gt; max) max = a[i]; if (a[i] \u0026lt; min) min = a[i]; } int range = max - min + 1; int* count = (int*)malloc(sizeof(int) * range); memset(count, 0, sizeof(int) * range); for (int i = 0; i \u0026lt; n; i++) { count[a[i] - min]++; } int i = 0; for (int j = 0; j \u0026lt; range; j++) { while (count[j]--) { a[i++] = j + min; } } free(count); } 十、基数排序： 原理：是将整数按位数切割成不同的数字，然后按每个位数分别比较。\n#include\u0026lt;math.h\u0026gt; testBS() { inta[] = {2, 343, 342, 1, 123, 43, 4343, 433, 687, 654, 3}; int *a_p = a; //计算数组长度 intsize = sizeof(a) / sizeof(int); //基数排序 bucketSort3(a_p, size); //打印排序后结果 inti; for(i = 0; i \u0026lt; size; i++) { printf(\u0026#34;%d\\n\u0026#34;, a[i]); } intt; scanf(\u0026#34;%d\u0026#34;, t); } //基数排序 voidbucketSort3(int *p, intn) { //获取数组中的最大数 intmaxNum = findMaxNum(p, n); //获取最大数的位数，次数也是再分配的次数。 intloopTimes = getLoopTimes(maxNum); inti; //对每一位进行桶分配 for(i = 1; i \u0026lt;= loopTimes; i++) { sort2(p, n, i); } } //获取数字的位数 intgetLoopTimes(intnum) { intcount = 1; inttemp = num / 10; while(temp != 0) { count++; temp = temp / 10; } returncount; } //查询数组中的最大数 intfindMaxNum(int *p, intn) { inti; intmax = 0; for(i = 0; i \u0026lt; n; i++) { if(*(p + i) \u0026gt; max) { max = *(p + i); } } returnmax; } //将数字分配到各自的桶中，然后按照桶的顺序输出排序结果 voidsort2(int *p, intn, intloop) { //建立一组桶此处的20是预设的根据实际数情况修改 intbuckets[10][20] = {}; //求桶的index的除数 //如798个位桶index=(798/1)%10=8 //十位桶index=(798/10)%10=9 //百位桶index=(798/100)%10=7 //tempNum为上式中的1、10、100 inttempNum = (int)pow(10, loop - 1); inti, j; for(i = 0; i \u0026lt; n; i++) { introw_index = (*(p + i) / tempNum) % 10; for(j = 0; j \u0026lt; 20; j++) { if(buckets[row_index][j] == NULL) { buckets[row_index][j] = *(p + i); break; } } } //将桶中的数，倒回到原有数组中 intk = 0; for(i = 0; i \u0026lt; 10; i++) { for(j = 0; j \u0026lt; 20; j++) { if(buckets[i][j] != NULL) { *(p + k) = buckets[i][j]; buckets[i][j] = NULL; k++; } } } } ","date":"2019-03-08T00:00:00Z","permalink":"https://fanmain.github.io/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","title":"十大排序算法【转载】"},{"content":" 本文由 简悦 SimpRead 转码， 原文地址 www.jianshu.com\nflutter SDK 提供的默认标签样式不太吸引人。 但这并不意味着您无法自定义标签的外观。 在 Flutter 中自定义Tab指示器的样式可以通过简单的代码行完成，而无需实现我们自己的窗口小部件。\n在本文中，我将向您展示如何为下一个 Flutter 项目添加 5 种不同的标签样式。\n首先，您需要使用DefaultTabController类创建一个基本选项卡。 将DefaultTabController分配给MaterialApp小部件的home属性。 作为DefaultTabController的子级，可以将Scaffold与 Appbar和主体一起使用。 将Appbar小部件分配到Scaffold的Appbar属性，以使选项卡的标题部分。 对于脚手架的body属性，可以为TabBarView小部件分配 3 个子小部件，以在单击时显示Tab内容项。\nimage\n检查完整的代码以获取默认Tab。\nreturn DefaultTabController( length: 3, child: Scaffold( appBar: AppBar( elevation: 0, bottom: TabBar( indicatorSize: TabBarIndicatorSize.label, tabs: [ Tab( child: Align( alignment: Alignment.center, child: Text(\u0026#34;APPS\u0026#34;), ), ), Tab( child: Align( alignment: Alignment.center, child: Text(\u0026#34;MOVIES\u0026#34;), ), ), Tab( child: Align( alignment: Alignment.center, child: Text(\u0026#34;GAMES\u0026#34;), ), ), ], ), ), body: TabBarView( children: [ Icon(Icons.apps), Icon(Icons.movie), Icon(Icons.games), ], ), ), ); 1. 圆角 Tab 风格 作为第一种样式，我们将向选项卡指示器添加圆角样式。 首先，我将简要介绍我们将要修改的参数。\n1. unselectedLabelColor –不存在指示符的标签颜色。 基本上，尚未选择的指标。 2. indicatorSize –选定的指标大小。 我们可以添加两个值以使指标为标签宽度或标签宽度。 3. Indicator –这是我们要为指标分配自定义样式的地方 Tab–这将包含Tab标题的列表。 在这里，我们可以为每个Tab标题添加额外的样式。\n可以通过添加带有borderRadius 50的BoxDecoration来实现圆角样式。在这里，我们向每个Tab```标题添加红色边框。 当有人选择Tab`` 时，它将用红色填充。 如果您对边框不感兴趣，可以删除边框并保持简单。\nimage\nreturn DefaultTabController( length: 3, child: Scaffold( appBar: AppBar( backgroundColor:Colors.white, elevation: 0, bottom: TabBar( unselectedLabelColor:Colors.redAccent, indicatorSize: TabBarIndicatorSize.label, indicator:BoxDecoration( color:Colors.redAccent, borderRadius:BorderRadius.circular(50), ), tabs: [ Tab( child:Container( decoration:BoxDecoration( borderRadius:BorderRadius.circular(50), border:Border.all(color:Colors.redAccent, width:1, ), ), child:Align( alignment:Alignment.center, child:Text(\u0026#34;APPS\u0026#34;), ), ), ), Tab( child:Container( decoration:BoxDecoration( borderRadius:BorderRadius.circular(50), border:Border.all(color:Colors.redAccent, width:1, ), ), child:Align( alignment:Alignment.center, child:Text(\u0026#34;MOVIES\u0026#34;), ), ), ), Tab( child:Container( decoration:BoxDecoration( borderRadius:BorderRadius.circular(50), border:Border.all(color:Colors.redAccent, width:1, ), ), child:Align( alignment:Alignment.center, child:Text(\u0026#34;GASMES\u0026#34;), ), ), ), ], ), ), body: TabBarView( children: [ Icon(Icons.apps), Icon(Icons.movie), Icon(Icons.games), ], ), ), ); 2. 圆角带有渐变色 Tab 风格 我们将删除以前方法中添加到每个Tab的样式。 删除后，向BoxDecoration添加渐变。 您可以使用带有两种颜色的LinearGradient小部件来获得渐变效果。 您可以根据自己的喜好更改渐变。\nimage\nreturn DefaultTabController( length: 3, child: Scaffold( appBar: AppBar( backgroundColor:Colors.white, elevation: 0, bottom: TabBar( unselectedLabelColor:Colors.redAccent, indicatorSize: TabBarIndicatorSize.tab, indicator:BoxDecoration( gradient:LinearGradient( colors:[ Colors.redAccent, Colors.orangeAccent, ], ), color:Colors.redAccent, borderRadius:BorderRadius.circular(50), ), tabs: [ Tab( child:Align( alignment:Alignment.center, child:Text(\u0026#34;APPS\u0026#34;), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\u0026#34;MOVIES\u0026#34;), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\u0026#34;GASMES\u0026#34;), ), ), ], ), ), body: TabBarView( children: [ Icon(Icons.apps), Icon(Icons.movie), Icon(Icons.games), ], ), ), ); 3. 矩形 Tab 风格 矩形样式可以通过更改上一个中的小代码来完成。 可以通过为leftTop和rightTop都添加10来更改boxDecoration的BorderRadius。 然后，我将appbar backgroundColor更改为红色，以使其看起来更好。\nimage\nreturn DefaultTabController( length: 3, child: Scaffold( appBar: AppBar( backgroundColor:Colors.redAccent, elevation: 0, bottom: TabBar( labelColor:Colors.redAccent, unselectedLabelColor:Colors.white, indicatorSize: TabBarIndicatorSize.label, indicator:BoxDecoration( color:Colors.white, borderRadius:BorderRadius.only( topLeft:Radius.circular(10), topRight:Radius.circular(10), ), ), tabs: [ Tab( child:Align( alignment:Alignment.center, child:Text(\u0026#34;APPS\u0026#34;), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\u0026#34;MOVIES\u0026#34;), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\u0026#34;GASMES\u0026#34;), ), ), ], ), ), body: TabBarView( children: [ Icon(Icons.apps), Icon(Icons.movie), Icon(Icons.games), ], ), ), ); 4. 菱形 Tab 样式 您可以通过为ShapeDecoration小部件的shape参数添加带有 BeveledRectangleBorder 的ShapeDecoration来获得Diamond选项卡样式。 BeveledRectangleBorder将允许您添加展平角而不是圆角。\n在这里，我们使用 borderRadius 作为 10 使其看起来像这样。\nimage\nreturn DefaultTabController( length: 3, child: Scaffold( appBar: AppBar( backgroundColor:Colors.white, elevation: 0, bottom: TabBar( unselectedLabelColor:Colors.redAccent, indicatorPadding:EdgeInsets.only(left:30,right:30), indicator:ShapeDecoration( color:Colors.redAccent, shape:BeveledRectangleBorder( side:BorderSide( color:Colors.redAccent, ), borderRadius:BorderRadius.circular(10), ), ), tabs: [ Tab( child:Align( alignment:Alignment.center, child:Text(\u0026#34;APPS\u0026#34;), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\u0026#34;MOVIES\u0026#34;), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\u0026#34;GASMES\u0026#34;), ), ), ], ), ), body: TabBarView( children: [ Icon(Icons.apps), Icon(Icons.movie), Icon(Icons.games), ], ), ), ); 5. 菱形 Tab 样式（2） 同样，通过更改BeveledRectangleBorder的borderRadius，可以实现不同的形状。 您可以将borderRadius更改为 20，以获得其他形状。 您可以通过更改 borderRadius 值尝试不同的样式。\nimage\nreturn DefaultTabController( length: 3, child: Scaffold( appBar: AppBar( backgroundColor:Colors.white, elevation: 0, bottom: TabBar( unselectedLabelColor:Colors.redAccent, indicatorPadding:EdgeInsets.only(left:30,right:30), indicator:ShapeDecoration( color:Colors.redAccent, shape:BeveledRectangleBorder( side:BorderSide( color:Colors.redAccent, ), borderRadius:BorderRadius.circular(20), ), ), tabs: [ Tab( child:Align( alignment:Alignment.center, child:Text(\u0026#34;APPS\u0026#34;), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\u0026#34;MOVIES\u0026#34;), ), ), Tab( child:Align( alignment:Alignment.center, child:Text(\u0026#34;GASMES\u0026#34;), ), ), ], ), ), body: TabBarView( children: [ Icon(Icons.apps), Icon(Icons.movie), Icon(Icons.games), ], ), ), ); 我希望您能通过几行代码更好地了解如何更改选项卡样式。 如果您想观看此视频，请观看以下视频。\nhttps://www.youtube.com/watch?v=Vnd0yvCkdNA\u0026amp;feature=youtu.be\n","date":"0001-01-01T00:00:00Z","permalink":"https://fanmain.github.io/post/flutter/2024/%E5%9C%A8-flutter-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BA%94%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84-tab/","title":""}]