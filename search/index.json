[{"content":"win10 本地时间为UTC时间 Reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1\nedge缓存修改 2021-12-01更新：经过测试最新版Edge不再需要2种方法结合才能生效，2种方法单独都可以使用(谷歌Chrome同理)\n方法一(一劳永逸)：\n①创建新的缓存文件夹，以E:\\Cache\\Edge为例，必须在第3步之前创建；\n②关闭Edge浏览器，删除 C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Edge\\User Data\\Default路径下的Cache文件夹(加粗字体修改成当前计算机登陆的用户名，Win10用户通过“设置-账户-账户信息”、Win7用户通过“控制面板-用户帐户-用户帐户”查看，用户名必须核实)；\n③以管理员身份运行cmd命令行输入mklink /D \u0026ldquo;C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Edge\\User Data\\Default\\Cache\u0026rdquo; \u0026ldquo;E:\\Cache\\Edge\u0026quot;并运行(加粗字体修改成当前登陆用户名，第二个引号内容修改成新路径)；\n方法二(简单)：\n①右键Edge图标 -\u0026gt; 属性 -\u0026gt; 目标 -\u0026gt; 最末尾加上 \u0026ndash;disk-cache-dir=\u0026ldquo;E:\\Cache\\Edge\u0026rdquo;(注意\u0026ndash;前面有个空格，引号里面内容修改成新路径)，点击确定。此方法虽然简单但是必须通过这个图标打开浏览器才能正常缓存到新路径。\n","date":"2021-06-08T00:00:00Z","permalink":"https://example.com/post/others/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","title":"日常小技巧【未分类】"},{"content":"原文地址 blog.csdn.net\n编解码协议 H264（视频）和 AAC（音频）有软编解码和硬编解码。\n网络传输都是用的大端序（高地址低字节），H264 网络传输的 startcode 是数据的 length，不是 0x00000001。NALU 有两种格式：Annex B 和 AVCC。Annex B 格式 startcode 以 0x 00 00 01 或 0x 00 00 00 01 开头， AVCC 格式以 NALU 的长度开头。\nAAC 也有两种传输格式：ADTS 和 ADIF\nADIF：Audio Data Interchange Format 音频数据交换格式。这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，即它的解码必须在明确定义的开始处进行。故这种格式常用在磁盘文件中。 ADTS：Audio Data Transport Stream 音频数据传输流。这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于 mp3 数据流格式。 软编码：使用 CPU 进行编码。编码框架 ffmpeg+x264。\nhttps://www.jianshu.com/p/e631b041e96d https://www.jianshu.com/p/3de01105d735 硬编码：不使用 CPU 进行编码，使用显卡（GPU）进行硬件加速。 专用的 DSP、FPGA、ASIC 芯片等硬件进行编码。ios 上硬编码框架 Video ToolBox 和 AudioToolbox。\nIntel 硬编码使用 Intel 处理器内部集成的显卡进行硬件加速，qsv 加速方法便对应着 Intel 硬编码。Intel 硬编码对 H.264 加速效果明显，且不需要安装额外库（仅使用相应的 ffmpeg 命令）。 NVIDIA 硬编码使用英伟达的显卡对视频编码进行加速。CUDA 加速方法对应着 NVIDIA 硬编码。使用英伟达硬编码之前需要安装 CUDA 与英伟达的必要驱动。安装好两个环境后就可以使用 NVIDIA 的硬编码了。英伟达关于视频的编解码提供了两个相关的 SDK：NVENC（硬编码）和 NVCUVID（硬解码），前者负责硬件编码，二后者负责硬件解码。CUDA 支持 Windows、Linux、MacOS 三种主流操作系统。https://blog.csdn.net/qq_29350001/article/details/75144665（CUDA 详解） FFmpeg 中也支持了硬编码，集成了显示视频处理模块。在命令行中使用 ffmpeg -hwaccels 可以查看 ffmpeg 支持的硬件加速方法。\nFFMPEG 目前存在一个编码器 nvenc 是对于 NVIDIA 的 NVENC 的封装，通过使用它可以和 FFMPEG 无缝的整合起来。不过 FFMPEG 只存在 NVENC 的接口，不存在 NVCUVID（解码器） 的封装。如果需要实现相关的解码器可能需要自己实现 FFMPEG 接口。FFMPEG 实现了对于 Intel QSV 的封装。 DXVA 是微软定制的视频加速规范、在 Linux 平台上则是由 NVIDIA 提供的 VDPAU 和 Intel 提供的 VAAPI 加速规范。 在不同平台上可通过不同 API 使用 Intel GPU 的硬件加速能力。目前主要由两套 API：VAAPI 以及 libmfx。VAAPI (视频加速 API，Video Acceleration API) 包含一套开源的库 (LibVA) 以及 API 规范, 用于硬件加速下的视频编解码以及处理，只有 Linux 上的驱动提供支持。libmfx。Intel Media SDK 中的 API 规范，支持视频编解码以及媒体处理。支持 Windows 以及 Linux。除了 Intel 自己的 API，在 Windows 系统上还有其他 API 可使用 Intel GPU 的硬件加速能力，这些 API 属于 Windows 标准，由 Intel 显卡驱动实现。DXVA2 / D3D11VA。标准 Windows API，支持通过 Intel 显卡驱动进行视频编解码，FFmpeg 有对应实现。Media Foundation。标准 Windows API，支持通过 Intel 显卡驱动进行视频编解码，FFmpeg 不支持该 API。https://blog.jianchihu.net/intel-gpu-hw-video-codec-develop.html\n目前的主流 GPU 加速平台：\n1 INTEL、AMD、NVIDIA 目前主流的 GPU 平台开发框架：\nCUDA：NVIDIA 的封闭编程框架，通过框架可以调用 GPU 计算资源 AMD APP：AMD 为自己的 GPU 提出的一套通用并行编程框架，标准开放，通过在 CPU、GPU 同时支持 OpenCL 框架，进行计算力融合。 OpenCL：开放计算语言，为异构平台编写程序的该框架，异构平台可包含 CPU、GPU 以及其他计算处理器，目标是使相同的运算能支持不同平台硬件加速。 Inel QuickSync：集成于 Intel 显卡中的专用视频编解码模块。 https://www.jianshu.com/p/8423724dffc1\nhttps://blog.csdn.net/haowei0926/article/details/56012139\nios 中的硬编码文档\nios 上硬编码框架 Video ToolBox 和 AudioToolbox。Video ToolBox 是一个底层框架，可以直接访问硬件编码器和解码器。 它提供视频压缩和解压缩服务，并在 CoreVideo 像素缓冲区中存储的光栅 raster 图像格式之间进行转换。 这些服务以会话对象（压缩，解压缩和像素传输）的形式提供，它们以 Core Foundation（CF）类型呈现。 不需要直接访问硬件编码器和解码器的应用程序 App 就不需要直接使用 VideoToolbox。iOS 8.0 及以上苹果开放了 VideoToolbox 框架来实现 H264 硬编码（H264 是一种编解码协议，有多种编解码器能编解码 H264，这里是利用硬件进行编解码，FFmpeg 中可以利用硬编解码和软编解码）。\nCVPixelBufferRef/CVImageBufferRef：存放编码前和解码后的图像数据（未压缩的数据），这两个是相同的对象。 CMTime：时间戳相关，时间以 64-bit/32-bit 的形式出现 CMBlockBufferRef：编码后输出的数据（压缩后的数据） CMFormatDescriptionRef/CMVideoFormatDescriptionRef：图像存储方式，编解码器等格式描述。这两个是相同的对象。 CMSampleBufferRef：存放编解码前后的视频图像的容器数据，iOS 中表示一帧音频 / 视频数据 CMSampleBuffer 可能是一个压缩的数据，也可能是一个未压缩的数据。取决于 CMSampleBuffer 里面是 CMBlockBuffer（压缩后） 还是 CVPixelBuffer（未压缩）。 硬编码的步骤 ：从相机或读取视频文件输出的 CVPixelBuffer（也是以 CMSampleBufferRef 封装形式存在）—\u0026gt;Encoder—\u0026gt;CMSampleBufferRef（编码后得到的数据封装）—\u0026gt; 重新组装 NALUs。\n通过 VTCompressionSessionCreate 创建编码器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 VTCompressionSessionCreate( CM_NULLABLE CFAllocatorRef allocator, int32_t width, int32_t height, CMVideoCodecType codecType, CM_NULLABLE CFDictionaryRef encoderSpecification, CM_NULLABLE CFDictionaryRef sourceImageBufferAttributes, CM_NULLABLE CFAllocatorRef compressedDataAllocator, CM_NULLABLE VTCompressionOutputCallback outputCallback, void * CM_NULLABLE outputCallbackRefCon, CM_RETURNS_RETAINED_PARAMETER CM_NULLABLE VTCompressionSessionRef * CM_NONNULL compressionSessionOut) allocator：内存分配器，填NULL为默认分配器 width、height：视频帧像素的宽高，如果编码器不支持这个宽高的话可能会改变 codecType：编码类型，枚举 encoderSpecification：指定特定的编码器，填NULL的话由VideoToolBox自动选择 sourceImageBufferAttributes：源像素缓冲区的属性，如果这个参数有值的话，VideoToolBox会创建一个缓冲池，不需要缓冲池可以设置为NULL compressedDataAllocator：压缩后数据的内存分配器，填NULL使用默认分配器 outputCallback：视频编码后输出数据回调函数 outputCallbackRefCon：回调函数中的自定义指针，我们通常传self，因为我们需要在C函数中调用self的方法，而C函数无法直接调self, compressionSessionOut：编码器句柄，传入编码器的指针 通过 VTSessionSetProperty 设置编码器属性，是否实时编码输出、是否产生 B 帧、设置关键帧、设置期望帧率、设置码率、最大码率值等等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 VTSessionSetProperty( // 解码会话 CM_NONNULL VTSessionRef session, // 属性 KEY CM_NONNULL CFStringRef propertyKey, // 设置的属性值 CM_NULLABLE CFTypeRef propertyValue ) kVTCompressionPropertyKey_AverageBitRate：设置编码的平均码率，单位是bps，这不是一个硬性指标，设置的码率会上下浮动。VideoToolBox框架只支持ABR模式。H264有4种码率控制方法： CBR（Constant Bit Rate）是以恒定比特率方式进行编码，有Motion发生时，由于码率恒定，只能通过增大QP来减少码字大小，图像质量变差，当场景静止时，图像质量又变好，因此图像质量不稳定。这种算法优先考虑码率(带宽)。 VBR（Variable Bit Rate）动态比特率，其码率可以随着图像的复杂程度的不同而变化，因此其编码效率比较高，Motion发生时，马赛克很少。码率控制算法根据图像内容确定使用的比特率，图像内容比较简单则分配较少的码率(似乎码字更合适)，图像内容复杂则分配较多的码字，这样既保证了质量，又兼顾带宽限制。这种算法优先考虑图像质量。 *CVBR（Constrained VariableBit Rate）,这样翻译成中文就比较难听了，它是VBR的一种改进方法。但是Constrained又体现在什么地方呢？这种算法对应的Maximum bitRate恒定或者Average BitRate恒定。这种方法的兼顾了以上两种方法的优点：在图像内容静止时，节省带宽，有Motion发生时，利用前期节省的带宽来尽可能的提高图像质量，达到同时兼顾带宽和图像质量的目的。 ABR (Average Bit Rate) 在一定的时间范围内达到设定的码率，但是局部码率峰值可以超过设定的码率，平均码率恒定。可以作为VBR和CBR的一种折中选择。 kVTCompressionPropertyKey_ProfileLevel：设置H264编码的画质，H264有4种Profile：BP、EP、MP、HP BP(Baseline Profile)：基本画质。支持I/P 帧，只支持无交错（Progressive）和CAVLC；主要应用：可视电话，会议电视，和无线通讯等实时视频通讯领域 EP(Extended profile)：进阶画质。支持I/P/B/SP/SI 帧，只支持无交错（Progressive）和CAVLC； MP(Main profile)：主流画质。提供I/P/B 帧，支持无交错（Progressive）和交错（Interlaced），也支持CAVLC 和CABAC 的支持；主要应用：数字广播电视和数字视频存储 HP(High profile)：高级画质。在main Profile 的基础上增加了8×8内部预测、自定义量化、 无损视频编码和更多的YUV 格式；应用于广电和存储领域 Level就多了，这里不一一列举，可参考h264 profile \u0026amp; level，iPhone上常用的方案如下： 实时直播： 低清Baseline Level 1.3 标清Baseline Level 3 半高清Baseline Level 3.1 全高清Baseline Level 4.1 存储媒体： 低清 Main Level 1.3 标清 Main Level 3 半高清 Main Level 3.1 全高清 Main Level 4.1 高清存储： 半高清 High Level 3.1 全高清 High Level 4.1 kVTCompressionPropertyKey_RealTime：设置是否实时编码输出 kVTCompressionPropertyKey_AllowFrameReordering：配置是否产生B帧，High profile 支持 B 帧 kVTCompressionPropertyKey_MaxKeyFrameInterval、kVTCompressionPropertyKey_MaxKeyFrameIntervalDuration：配置I帧间隔 调用 VTCompressionSessionPrepareToEncodeFrames 准备编码\n1 2 3 VTCompressionSessionPrepareToEncodeFrames( CM_NONNULL VTCompressionSessionRef session ) session：编码器句柄，传入编码器的指针 输入采集到的视频数据 CVImageBufferRef /CVPixelBufferRef，调用 VTCompressionSessionEncodeFrame 进行编码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 VTCompressionSessionEncodeFrame( CM_NONNULL VTCompressionSessionRef session, CM_NONNULL CVImageBufferRef imageBuffer, CMTime presentationTimeStamp, CMTime duration, // may be kCMTimeInvalid CM_NULLABLE CFDictionaryRef frameProperties, void * CM_NULLABLE sourceFrameRefCon, VTEncodeInfoFlags * CM_NULLABLE infoFlagsOut ) session：创建编码器时的句柄 imageBuffer：YUV数据，iOS通过摄像头采集出来的视频流数据类型是CMSampleBufferRef，我们要从里面拿到CVImageBufferRef来进行编码。通过CMSampleBufferGetImageBuffer方法可以从sampleBuffer中获得imageBuffer。 presentationTimeStamp：这一帧的时间戳，单位是毫秒 duration：这一帧的持续时间，如果没有持续时间，填kCMTimeInvalid frameProperties：指定这一帧的属性，这里我们可以用来指定产生I帧 encodeParams：自定义指针 infoFlagsOut：用于接收编码操作的信息，不需要就置为NULL 获取到编码后的数据并进行处理并组装 NALU，添加起始码 \u0026ldquo;\\x00\\x00\\x00\\x01\u0026rdquo;，如果这一帧是个关键帧，需要添加 sps pps** 等。将硬编码成功的 CMSampleBuffer 转换成 H264 码流，解析出参数集 SPS \u0026amp; PPS，加上开始码组装成 NALU。提取出视频数据，将长度码转换为开始码，组成 NALU，将 NALU 写入到文件中。NALU 只要有两种格式：Annex B 和 AVCC。Annex B 格式以 0x 00 00 01 或 0x 00 00 00 01 开头， AVCC 格式以所在 NALU 的长度开头。\n编码后的数据通过步骤一 VTCompressionSessionCreate 方法中参数的回调函数 encodeOutputDataCallback 返回。编码后的数据以及这一帧的基本信息都在 CMSampleBufferRef 中。\n1 void encodeOutputDataCallback(void * CM_NULLABLE outputCallbackRefCon, void * CM_NULLABLE sourceFrameRefCon, OSStatus status, VTEncodeInfoFlags infoFlags, CM_NULLABLE CMSampleBufferRef sampleBuffer){ }。 调用 VTCompressionSessionCompleteFrames 停止编码器\n1 2 3 4 5 VT_EXPORT OSStatus VTCompressionSessionCompleteFrames( CM_NONNULL VTCompressionSessionRef\tsession,//编码器句柄 CMTime\tcompleteUntilPresentationTimeStamp//kCMTimeInvalid等 ) 调用 VTCompressionSessionInvalidate 销毁编码器\n1 2 3 VTCompressionSessionInvalidate(编码器句柄compressionSessionRef); CFRelease(编码器句柄compressionSessionRef); _compressionSessionRef = NULL; 代码示范：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 #import \u0026lt;VideoToolbox/VideoToolbox.h\u0026gt; @interface Nextvc () { NSInteger frameID; VTCompressionSessionRef cEncodeingSession;//编码器上下文 dispatch_queue_t cEncodeQueue; } //videoToolbox硬编码 -(void)videoToolboxHardEncode{ frameID = 0; int width = 480,height = 640; //创建编码session OSStatus status = VTCompressionSessionCreate(NULL, width, height, kCMVideoCodecType_H264, NULL, NULL, NULL, didCompressH264, (__bridge void *)(self), \u0026amp;cEncodeingSession); NSLog(@\u0026#34;H264:VTCompressionSessionCreate:%d\u0026#34;,(int)status); if (status != 0) { NSLog(@\u0026#34;H264:Unable to create a H264 session\u0026#34;); return ; } /** 设置编码器属性 */ //设置实时编码输出（避免延迟） VTSessionSetProperty(cEncodeingSession, kVTCompressionPropertyKey_RealTime, kCFBooleanTrue); VTSessionSetProperty(cEncodeingSession, kVTCompressionPropertyKey_ProfileLevel,kVTProfileLevel_H264_Baseline_AutoLevel); //是否产生B帧(因为B帧在解码时并不是必要的,是可以抛弃B帧的) VTSessionSetProperty(cEncodeingSession, kVTCompressionPropertyKey_AllowFrameReordering, kCFBooleanFalse); //设置关键帧（GOPsize）间隔，GOP太小的话图像会模糊 int frameInterval = 10; CFNumberRef frameIntervalRaf = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, \u0026amp;frameInterval); VTSessionSetProperty(cEncodeingSession, kVTCompressionPropertyKey_MaxKeyFrameInterval, frameIntervalRaf); //设置期望帧率，不是实际帧率 int fps = 10; CFNumberRef fpsRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, \u0026amp;fps); VTSessionSetProperty(cEncodeingSession, kVTCompressionPropertyKey_ExpectedFrameRate, fpsRef); //码率的理解：码率大了话就会非常清晰，但同时文件也会比较大。码率小的话，图像有时会模糊，但也勉强能看 //码率计算公式，参考印象笔记 //设置码率、上限、单位是bps int bitRate = width * height * 3 * 4 * 8; CFNumberRef bitRateRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, \u0026amp;bitRate); VTSessionSetProperty(cEncodeingSession, kVTCompressionPropertyKey_AverageBitRate, bitRateRef); //设置码率，均值，单位是byte int bigRateLimit = width * height * 3 * 4; CFNumberRef bitRateLimitRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, \u0026amp;bigRateLimit); VTSessionSetProperty(cEncodeingSession, kVTCompressionPropertyKey_DataRateLimits, bitRateLimitRef); //准备编码 VTCompressionSessionPrepareToEncodeFrames(cEncodeingSession); } /** 输入待编码数据CMSampleBufferRef，开始编码 @param sampleBuffer 待编码数据，可以是从摄像头获取的数据，也可以是从视频文件中获取的数据 @param forceKeyFrame 是否强制I帧 @return 结果 */ - (BOOL)videoEncodeInputData:(CMSampleBufferRef)sampleBuffer forceKeyFrame:(BOOL)forceKeyFrame { if (NULL == cEncodeingSession) { return NO; } if (nil == sampleBuffer) { return NO; } CMTime presentationTimeStamp = CMTimeMake(frameID++, 1000); // CMTimeMake(分子，分母)；分子/分母 = 时间(秒) CVImageBufferRef pixelBuffer = (CVImageBufferRef)CMSampleBufferGetImageBuffer(sampleBuffer); NSDictionary *frameProperties = @{(__bridge NSString *)kVTEncodeFrameOptionKey_ForceKeyFrame: @(forceKeyFrame)}; OSStatus status = VTCompressionSessionEncodeFrame(cEncodeingSession, pixelBuffer, kCMTimeInvalid, kCMTimeInvalid, (__bridge CFDictionaryRef)frameProperties, NULL, NULL);//第三个参数可以换成presentationTimeStamp if (noErr != status) { NSLog(@\u0026#34;VEVideoEncoder::VTCompressionSessionEncodeFrame failed! status:%d\u0026#34;, (int)status); return NO; } return YES; } //VideoToolBox硬编码回调 void didCompressH264(void *outputCallbackRefCon, void *sourceFrameRefCon, OSStatus status, VTEncodeInfoFlags infoFlags, CMSampleBufferRef sampleBuffer) { if (noErr != status || nil == sampleBuffer) { NSLog(@\u0026#34;VEVideoEncoder::encodeOutputCallback Error : %d!\u0026#34;, (int)status); return; } if (nil == outputCallbackRefCon) { return; } if (!CMSampleBufferDataIsReady(sampleBuffer)) { return; } if (infoFlags \u0026amp; kVTEncodeInfo_FrameDropped) { NSLog(@\u0026#34;VEVideoEncoder::H264 encode dropped frame.\u0026#34;); return; } Nextvc *encoder = (__bridge Nextvc *)outputCallbackRefCon; const char header[] = \u0026#34;\\x00\\x00\\x00\\x01\u0026#34;; size_t headerLen = (sizeof header) - 1; // 最后一位是\\0结束符，要减掉 NSData *headerData = [NSData dataWithBytes:header length:headerLen]; // // 判断是否是关键帧 // bool isKeyFrame = !CFDictionaryContainsKey((CFDictionaryRef)CFArrayGetValueAtIndex(CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, true), 0), (const void *)kCMSampleAttachmentKey_NotSync); //判断当前帧是否为关键帧 CFArrayRef array = CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, true); CFDictionaryRef dic = CFArrayGetValueAtIndex(array, 0); bool isKeyFrame = !CFDictionaryContainsKey(dic, kCMSampleAttachmentKey_NotSync); if (isKeyFrame) { NSLog(@\u0026#34;VEVideoEncoder::编码了一个关键帧\u0026#34;); //图像的存储方式，编解码器等格式描述 CMFormatDescriptionRef formatDescriptionRef = CMSampleBufferGetFormatDescription(sampleBuffer); /*关键帧需要加上SPS、PPS信息 获取sps \u0026amp; pps 数据 只获取1次，保存在h264文件开头的第一帧中 sps(sample per second 采样次数/s),是衡量模数转换（ADC）时采样速率的单位 CMVideoFormatDescriptionGetH264ParameterSetAtIndex获取sps和pps信息，并转换为二进制写入文件或者进行上传 */ size_t sParameterSetSize;//参数集合占的字节大小 size_t sParameterSetCount;//参数集合元素个数 const uint8_t *sParameterSet;//参数集合 OSStatus spsStatus = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(formatDescriptionRef, 0, \u0026amp;sParameterSet, \u0026amp;sParameterSetSize, \u0026amp;sParameterSetCount, 0);//index为0的位置是sps； size_t pParameterSetSize, pParameterSetCount; const uint8_t *pParameterSet; OSStatus ppsStatus = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(formatDescriptionRef, 1, \u0026amp;pParameterSet, \u0026amp;pParameterSetSize, \u0026amp;pParameterSetCount, 0);//index为1的位置是pps； if (noErr == spsStatus \u0026amp;\u0026amp; noErr == ppsStatus) { //把sps和pps参数集合转换成二进制数据，组装成sps帧和pps帧； NSData *sps = [NSData dataWithBytes:sParameterSet length:sParameterSetSize]; NSData *pps = [NSData dataWithBytes:pParameterSet length:pParameterSetSize]; NSMutableData *spsData = [NSMutableData data]; [spsData appendData:headerData]; [spsData appendData:sps]; NSMutableData *ppsData = [NSMutableData data]; [ppsData appendData:headerData]; [ppsData appendData:pps]; } } //获取编码后的h264流数据 CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(sampleBuffer); size_t length;//单个NALU长度 size_t totalLength;//所有NALU总长度 char *dataPointer;//指针偏移 // 通过 首地址blockBuffer 、单个长度length、 总长度totalLength通过dataPointer指针偏移做遍历 status = CMBlockBufferGetDataPointer(blockBuffer, 0, \u0026amp;length, \u0026amp;totalLength, \u0026amp;dataPointer); if (noErr != status) { NSLog(@\u0026#34;VEVideoEncoder::CMBlockBufferGetDataPointer Error : %d!\u0026#34;, (int)status); return; } size_t bufferOffset = 0;//Nalu的开始位置，每次增加加一个stratcode+nalu的长度 static const int avcHeaderLength = 4;//返回的nalu数据前4个字节不是0x00000001的startcode,而是大端模式的帧长度length,读取数据时有个大小端模式：网络传输一般都是大端模式 while (bufferOffset \u0026lt; totalLength - avcHeaderLength) { // 读取 一单元长度的nalu数据 uint32_t nalUnitLength = 0; memcpy(\u0026amp;nalUnitLength, dataPointer + bufferOffset, avcHeaderLength);//目标地址，源地址，字节数，（从源地址拷贝n个字节到目标地址），这里其实是设置每个nalUnitLength的值，即各个Nalu的长度 // 大端转小端(系统端是小端序) nalUnitLength = CFSwapInt32BigToHost(nalUnitLength); //获取nalu数据 NSData *frameData = [[NSData alloc] initWithBytes:(dataPointer + bufferOffset + avcHeaderLength) length:nalUnitLength]; //Nalu头+NALU数据 NSMutableData *outputFrameData = [NSMutableData data]; [outputFrameData appendData:headerData]; [outputFrameData appendData:frameData]; //可以把outputFrameData写入文件，然后就得到了H264编码的文件。 //读取下一个nalu 一次回调可能包含多个nalu数据， bufferOffset += avcHeaderLength + nalUnitLength; } } audioToolBox 硬编码\n编码步骤：\n配置编码参数、获取编码器描述 description、获取编码器 设置缓冲列表 AudioBufferList 开始编码，将数据写入编码器 AudioConverterFillComplexBuffer， 在回调函数中，将数据写入缓冲区 编码完成后，获取缓冲区列表数据 outAudioBUfferList，添加 ADTS 头 将数据写入文件 代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 { AudioConverterRef _audioConverter;//音频编码上下文 size_t _pcmBufferSize; char *_pcmBuffer; size_t _aacBufferSize; char *_aacBuffer; } @property(nonatomic,strong)NSFileHandle *audioFileHandle; @property(nonatomic,strong)dispatch_queue_t encoderQueue;) //创建存储音频的文件，先移除以前的文件，再重新创建 - (NSFileHandle *)audioFileHandle { if (!_audioFileHandle) { NSString *documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject; NSString * filePath = [documentPath stringByAppendingPathComponent:@\u0026#34;demo01.aac\u0026#34;]; [[NSFileManager defaultManager] removeItemAtPath:filePath error:nil]; BOOL createFile = [[NSFileManager defaultManager] createFileAtPath:filePath contents:nil attributes:nil]; NSAssert(createFile, @\u0026#34;create audio path error\u0026#34;); _audioFileHandle = [NSFileHandle fileHandleForWritingAtPath:filePath]; } return _audioFileHandle; } - (id)init { if (self = [super init]) { _encoderQueue = dispatch_queue_create(\u0026#34;aac encode queue\u0026#34;, DISPATCH_QUEUE_SERIAL); _audioConverter = NULL; _pcmBufferSize = 0; _pcmBuffer = NULL; _aacBufferSize = 1024; _aacBuffer = malloc(_aacBufferSize * sizeof(uint8_t)); memset(_aacBuffer, 0, _aacBufferSize); } return self; } //停止编码 - (void)stopEncodeAudio { [self.audioFileHandle closeFile]; self.audioFileHandle = NULL; } // 配置编码参数 - (void)setupEncoderFromSampleBuffer:(CMSampleBufferRef)sampleBuffer { NSLog(@\u0026#34;开始配置编码参数。。。。\u0026#34;); /* AudioStreamBasicDescription是输入输出流的结构体描述， */ // 获取原音频声音格式设置 AudioStreamBasicDescription inAudioStreamBasicDescription = *CMAudioFormatDescriptionGetStreamBasicDescription((CMAudioFormatDescriptionRef)CMSampleBufferGetFormatDescription(sampleBuffer)); AudioStreamBasicDescription outAudioStreamBasicDescription = {0}; /* 设置输出格式参数 */ // 采样率，音频流，在正常播放情况下的帧率。如果是压缩的格式，这个属性表示解压缩后的帧率。帧率不能为0。 outAudioStreamBasicDescription.mSampleRate = inAudioStreamBasicDescription.mSampleRate; // 格式 kAudioFormatMPEG4AAC = \u0026#39;aac\u0026#39; , outAudioStreamBasicDescription.mFormatID = kAudioFormatMPEG4AAC; // 标签格式 无损编码 ， 无损编码 ，0表示没有 outAudioStreamBasicDescription.mFormatFlags = kMPEG4Object_AAC_LC; // 每一个packet的音频数据大小。如果的动态大小，设置为0。动态大小的格式，需要用AudioStreamPacketDescription 来确定每个packet的大小。 outAudioStreamBasicDescription.mBytesPerPacket = 0; // 每个packet的帧数。如果是未压缩的音频数据，值是1。动态帧率格式，这个值是一个较大的固定数字，比如说AAC的1024。如果是动态大小帧数（比如Ogg格式）设置为0。 outAudioStreamBasicDescription.mFramesPerPacket = 1024; // 每帧的大小。每一帧的起始点到下一帧的起始点。如果是压缩格式，设置为0 。 outAudioStreamBasicDescription.mBytesPerFrame = 0; // 声道数：1 单声道 2 立体声 outAudioStreamBasicDescription.mChannelsPerFrame = 1; // 每采样点占用位数 outAudioStreamBasicDescription.mBitsPerChannel = 0; // 保留参数（对齐当时）8字节对齐，填0. outAudioStreamBasicDescription.mReserved = 0; // 获取编码器描述 AudioClassDescription * description = [self getAudioClassDescriptionWithType:kAudioFormatMPEG4AAC fromManufacturer:kAppleSoftwareAudioCodecManufacturer]; // 创建编码器 /* inAudioStreamBasicDescription 传入源音频格式 outAudioStreamBasicDescription 目标音频格式 第三个参数：传入音频编码器的个数 description 传入音频编码器的描述 */ OSStatus status = AudioConverterNewSpecific(\u0026amp;inAudioStreamBasicDescription, \u0026amp;outAudioStreamBasicDescription, 1, description, \u0026amp;_audioConverter); if (status != 0) { NSLog(@\u0026#34;创建编码器失败\u0026#34;); } } // 获取编码器描述 /*type 编码格式 manufacturer 软/硬编 kAppleHardwareAudioCodecManufacturer、kAppleSoftwareAudioCodecManufacturer */ - (AudioClassDescription *)getAudioClassDescriptionWithType:(UInt32)type fromManufacturer:(UInt32)manufacturer { NSLog(@\u0026#34;开始获取编码器。。。。\u0026#34;); // 选择aac编码 /*AudioClassDescription结构体包含以下成员 OSType mType; OSType mSubType; OSType mManufacturer; */ static AudioClassDescription desc; UInt32 encoderS = type; OSStatus status; UInt32 size; /*获取所用有的编码器属性信息 kAudioFormatProperty_Encoders 编码ID 编码说明大小 编码类型 属性当前值的大小 */ status = AudioFormatGetPropertyInfo(kAudioFormatProperty_Encoders, sizeof(encoderS), \u0026amp;encoderS, \u0026amp;size); if (status) { NSLog(@\u0026#34;编码aac错误\u0026#34;); return nil; } // 计算编码器的个数 unsigned int count = size / sizeof(AudioClassDescription); // 定义编码器数组 AudioClassDescription description[count]; //分配编码器属性信息到数组 status = AudioFormatGetProperty(kAudioFormatProperty_Encoders, sizeof(encoderS), \u0026amp;encoderS, \u0026amp;size, description); for (unsigned int i = 0; i \u0026lt; count; i++) { if (type == description[i].mSubType \u0026amp;\u0026amp; manufacturer == description[i].mManufacturer) { // 拷贝编码器到desc memcpy(\u0026amp;desc, \u0026amp;description[i], sizeof(desc)); NSLog(@\u0026#34;找到aac编码器\u0026#34;); return \u0026amp;desc; } } return nil; } // 编码数据 - (void)encodeAudioSampleBuffer:(CMSampleBufferRef)sampleBuffer { CFRetain(sampleBuffer); dispatch_sync(_encoderQueue, ^{ if (!_audioConverter) { // 配置编码参数 [self setupEncoderFromSampleBuffer:sampleBuffer]; } // 获取CMBlockBufferRef CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(sampleBuffer); CFRetain(blockBuffer); // 获取_pcmBufferSize 和 _pcmBuffer OSStatus status = CMBlockBufferGetDataPointer(blockBuffer, 0, NULL, \u0026amp;self-\u0026gt;_pcmBufferSize, \u0026amp;self-\u0026gt;_pcmBuffer); if (status != kCMBlockBufferNoErr) { NSLog(@\u0026#34;获取 pcmBuffer 数据错误\u0026#34;); return ; } // 清空 memset(self-\u0026gt;_aacBuffer, 0, self-\u0026gt;_aacBufferSize); // 初始化缓冲列表 AudioBufferList outAudioBufferList = {0}; // 结构体 // 缓冲区个数 outAudioBufferList.mNumberBuffers = 1; // 渠道个数 outAudioBufferList.mBuffers[0].mNumberChannels = 1; // 缓存区大小 outAudioBufferList.mBuffers[0].mDataByteSize = (int)self-\u0026gt;_aacBufferSize; // 缓冲区内容 outAudioBufferList.mBuffers[0].mData = self-\u0026gt;_aacBuffer; // 编码 AudioStreamPacketDescription * outPD = NULL; UInt32 inPutSize = 1; /* _audioConverter 音频编码上下文 inInputDataProc 自己实现的编码数据的callback引用 self 获取的数据 inPutSize 输出数据的长度 outAudioBUfferList 输出的缓冲区列表数据 outPD 输出数据的描述 */ status = AudioConverterFillComplexBuffer(self-\u0026gt;_audioConverter, inInputDataProc, (__bridge void*)self, \u0026amp;inPutSize, \u0026amp;outAudioBufferList, outPD ); // 编码后完成,AudioConverterFillComplexBuffer方法返回的是AAC原始码流，需要在AAC每帧添加ADTS头 NSData * data = nil; if (status == noErr) { // 获取缓冲区的原始数据acc数据 NSData * rawAAC = [NSData dataWithBytes:outAudioBufferList.mBuffers[0].mData length:outAudioBufferList.mBuffers[0].mDataByteSize]; // 加头ADTS NSData * adtsHeader = [self adtsDataForPacketLength:rawAAC.length]; NSMutableData * fullData = [NSMutableData dataWithData:adtsHeader]; [fullData appendData:rawAAC]; data = fullData; } else { NSLog(@\u0026#34;数据错误\u0026#34;); return; } // 写入数据 [self.audioFileHandle writeData:data]; CFRelease(sampleBuffer); CFRelease(blockBuffer); }); } // audioToolBox回调函数，将数据写入缓冲区 OSStatus inInputDataProc(AudioConverterRef inAudioConverter, UInt32 *ioNumberDataPackets, AudioBufferList *ioData, AudioStreamPacketDescription **outDataPacketDescription, void *inUserData) { // 编码器 Nextvc *encoder = (__bridge Nextvc *) inUserData; // 编码包的数据 UInt32 requestPackes = *ioNumberDataPackets; // 将ioData填充到缓冲区 size_t cp = [encoder copyPCMSamplesIntoBuffer:ioData]; if (cp \u0026lt; requestPackes) { //PCM 缓冲区还没满 *ioNumberDataPackets = 0; // 清空 return -1; } *ioNumberDataPackets = 1; return noErr; } // pcm -\u0026gt; 缓冲区 - (size_t)copyPCMSamplesIntoBuffer:(AudioBufferList*)ioData { // 获取pcm大小 size_t os = _pcmBufferSize; if (!_pcmBufferSize) { return 0; } ioData-\u0026gt;mBuffers[0].mData = _pcmBuffer; ioData-\u0026gt;mBuffers[0].mDataByteSize = (int)_pcmBufferSize; // 清空 _pcmBuffer = NULL; _pcmBufferSize = 0; return os; } /** * Add ADTS header at the beginning of each and every AAC packet. * This is needed as MediaCodec encoder generates a packet of raw * AAC data. * * Note the packetLen must count in the ADTS header itself. 注意：packetLen 必须在ADTS头身计算 **/ - (NSData*)adtsDataForPacketLength:(NSUInteger)packetLength { int adtsLength = 7; char *packet = malloc(sizeof(char) * adtsLength); int profile = 2; int freqIdx = 4; int chanCfg = 1; NSUInteger fullLength = adtsLength + packetLength; packet[0] = (char)0xFF; packet[1] = (char)0xF9; packet[2] = (char)(((profile-1)\u0026lt;\u0026lt;6) + (freqIdx\u0026lt;\u0026lt;2) +(chanCfg\u0026gt;\u0026gt;2)); packet[3] = (char)(((chanCfg\u0026amp;3)\u0026lt;\u0026lt;6) + (fullLength\u0026gt;\u0026gt;11)); packet[4] = (char)((fullLength\u0026amp;0x7FF) \u0026gt;\u0026gt; 3); packet[5] = (char)(((fullLength\u0026amp;7)\u0026lt;\u0026lt;5) + 0x1F); packet[6] = (char)0xFC; NSData *data = [NSData dataWithBytesNoCopy:packet length:adtsLength freeWhenDone:YES]; return data; } FFmpeg 中的硬编码：\nFFmpeg 中的硬编码有 videotoolbox（苹果的 ios 和 MACos）、mediacodec（安卓的）、qsv（Intel 的 LIBMFX api）、DXVA（是微软定制的视频加速规范，如 DXVA2 / D3D11VA）、VDPAU（在 Linux 平台上由 NVIDIA 指定的加速规范）、VAAPI（在 Linux 平台上由 Intel 提供的加速规范） Intel 支持的硬编码：\nwindows：libmfx（Intel 自己的 api，FFmpeg 中 qsv 技术对外接口就是 LIBMF）、DXVA2 / D3D11VA（微软出的对 Intel 支持的 api，FFmpeg 中有封装）、Media Foundation（微软出的对 Intel 支持的 api） linux：VAAPI（Intel 自己的 api，FFmpeg 中有封装）、libmfx（Intel 自己的 api，FFmpeg 中 qsv 技术对外接口就是 LIBMF） NVIDIA 支持的硬编码：\nwindows：CUDA（NVIDIA 自己的 api，FFmpeg 中封装包含 NVENC（硬编码）和 NVCUVID（硬解码）） linux：CUDA（NVIDIA 自己的 api，FFmpeg 中封装包含 NVENC（硬编码）和 NVCUVID（硬解码））、VDPAU（FFmpeg 中有封装） 硬解码：\n问题和优化方案：https://www.jianshu.com/p/57581485717b\n硬编解码图示：https://www.cnblogs.com/edisongz/p/7062098.html\nvideoToolBox 硬解码\n1 2 3 4 5 NALU + SPS,PPS—\u0026gt;CMBlockBuffer—\u0026gt;CMSampleBufferRef，再将CMSampleBufferRef包装的帧数据输入到 VTDecompressionSessionDecodeFrame，通过回调中CVImageBufferRef 直接上传OpenGL ES 显示。 序列参数集SPS（sequence Parameter Set）：作用于一系列连续的编码图像 图像参数集PPS(Picture Parameter Set)：作用于编码视频序列中一个或多个独立的图像； 硬解码流程：\n1、解析 H264 数据\n解码前的 CMSampleBuffer = CMTime + FormatDesc + CMBlockBuffer。需要从 H264 的码流里面提取出以上的三个信息。最后组合成 CMSampleBuffer，提供给硬解码接口来进行解码工作。\nNALU 单元包含视频图像数据和 H264 的参数信息。其中视频图像数据就是 CMBlockBuffer，而 H264 的参数信息则可以组合成 FormatDesc。\n2、初始化解码器（VTDecompressionSessionCreate）\n3、将解析后的 H264 数据送入解码器（VTDecompressionSessionDecodeFrame）\n4、解码器回调输出解码后的数据（CVImageBufferRef）\n代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 /** sps数据 */ @property (nonatomic, assign) uint8_t *sps; /** sps数据长度 */ @property (nonatomic, assign) NSInteger spsSize; /** pps数据 */ @property (nonatomic, assign) uint8_t *pps; /** pps数据长度 */ @property (nonatomic, assign) NSInteger ppsSize; /** 解码器句柄 */ @property (nonatomic, assign) VTDecompressionSessionRef deocderSession; /** 视频解码信息句柄 */ @property (nonatomic, assign) CMVideoFormatDescriptionRef decoderFormatDescription; /* *读取本地视频文件 */ /** 解码NALU数据 @param naluData NALU数据 */ -(void)decodeNaluData:(NSData *)naluData { uint8_t *frame = (uint8_t *)naluData.bytes; uint32_t frameSize = (uint32_t)naluData.length; // frame的前4位是NALU数据的开始码，也就是00 00 00 01，第5个字节是表示数据类型，转为10进制后，7是sps,8是pps,5是IDR（I帧）信息 int nalu_type = (frame[4] \u0026amp; 0x1F); /* 将NALU的开始码替换成NALU的长度信息 方法一： */ // uint32_t nalSize = (uint32_t)(frameSize - 4); // uint8_t *pNalSize = (uint8_t*)(\u0026amp;nalSize); // frame[0] = *(pNalSize + 3); // frame[1] = *(pNalSize + 2); // frame[2] = *(pNalSize + 1); // frame[3] = *(pNalSize); //方法二： uint32_t nalSize = (uint32_t)(frameSize - 4); uint32_t *pNalSize = (uint32_t *)frame; *pNalSize = CFSwapInt32HostToBig(nalSize); switch (nalu_type) { case 0x05: // I帧 NSLog(@\u0026#34;NALU type is IDR frame\u0026#34;); if([self initH264Decoder]) { [self decode:frame withSize:frameSize]; } break; case 0x07: // SPS NSLog(@\u0026#34;NALU type is SPS frame\u0026#34;); _spsSize = frameSize - 4; _sps = malloc(_spsSize); memcpy(_sps, \u0026amp;frame[4], _spsSize); break; case 0x08: // PPS NSLog(@\u0026#34;NALU type is PPS frame\u0026#34;); _ppsSize = frameSize - 4; _pps = malloc(_ppsSize); memcpy(_pps, \u0026amp;frame[4], _ppsSize); break; default: // B帧或P帧 NSLog(@\u0026#34;NALU type is B/P frame\u0026#34;); if([self initH264Decoder]) { [self decode:frame withSize:frameSize]; } break; } } /** 初始化解码器 @return 结果 */ -(BOOL)initH264Decoder { if(_deocderSession) { return YES; } const uint8_t* const parameterSetPointers[2] = {_sps, _pps}; const size_t parameterSetSizes[2] = {_spsSize, _ppsSize}; // 根据sps pps创建解码视频参数 OSStatus status = CMVideoFormatDescriptionCreateFromH264ParameterSets(kCFAllocatorDefault, 2, parameterSetPointers, parameterSetSizes, 4, \u0026amp;_decoderFormatDescription); if(status != noErr) { NSLog(@\u0026#34;H264Decoder::CMVideoFormatDescriptionCreateFromH264ParameterSets failed status = %d\u0026#34;, (int)status); } // 从sps pps中获取解码视频的宽高信息 CMVideoDimensions dimensions = CMVideoFormatDescriptionGetDimensions(_decoderFormatDescription); // kCVPixelBufferPixelFormatTypeKey 解码图像的采样格式 // kCVPixelBufferWidthKey、kCVPixelBufferHeightKey 解码图像的宽高 // kCVPixelBufferOpenGLCompatibilityKey制定支持OpenGL渲染，经测试有没有这个参数好像没什么差别 NSDictionary* destinationPixelBufferAttributes = @{(id)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange), (id)kCVPixelBufferWidthKey : @(dimensions.width), (id)kCVPixelBufferHeightKey : @(dimensions.height), (id)kCVPixelBufferOpenGLCompatibilityKey : @(YES)}; // 设置解码输出数据回调 VTDecompressionOutputCallbackRecord callBackRecord; callBackRecord.decompressionOutputCallback = decodeOutputDataCallback; callBackRecord.decompressionOutputRefCon = (__bridge void *)self; // 创建解码器 status = VTDecompressionSessionCreate(kCFAllocatorDefault, _decoderFormatDescription, NULL, (__bridge CFDictionaryRef)destinationPixelBufferAttributes, \u0026amp;callBackRecord, \u0026amp;_deocderSession); // 解码线程数量 VTSessionSetProperty(_deocderSession, kVTDecompressionPropertyKey_ThreadCount, (__bridge CFTypeRef)@(1)); // 是否实时解码 VTSessionSetProperty(_deocderSession, kVTDecompressionPropertyKey_RealTime, kCFBooleanTrue); return YES; } /** 解码数据 @param frame 数据 @param frameSize 数据长度 */ -(void)decode:(uint8_t *)frame withSize:(uint32_t)frameSize { CMBlockBufferRef blockBuffer = NULL; // 创建 CMBlockBufferRef OSStatus status = CMBlockBufferCreateWithMemoryBlock(NULL, (void *)frame, frameSize, kCFAllocatorNull, NULL, 0, frameSize, FALSE, \u0026amp;blockBuffer); if(status != kCMBlockBufferNoErr) { return; } CMSampleBufferRef sampleBuffer = NULL; const size_t sampleSizeArray[] = {frameSize}; // 创建 CMSampleBufferRef status = CMSampleBufferCreateReady(kCFAllocatorDefault, blockBuffer, _decoderFormatDescription , 1, 0, NULL, 1, sampleSizeArray, \u0026amp;sampleBuffer); if (status != kCMBlockBufferNoErr || sampleBuffer == NULL) { return; } // VTDecodeFrameFlags 0为允许多线程解码 VTDecodeFrameFlags flags = 0; VTDecodeInfoFlags flagOut = 0; // 解码 这里第四个参数会传到解码的callback里的sourceFrameRefCon，可为空 OSStatus decodeStatus = VTDecompressionSessionDecodeFrame(_deocderSession, sampleBuffer, flags, NULL, \u0026amp;flagOut); if(decodeStatus == kVTInvalidSessionErr) { NSLog(@\u0026#34;H264Decoder::Invalid session, reset decoder session\u0026#34;); } else if(decodeStatus == kVTVideoDecoderBadDataErr) { NSLog(@\u0026#34;H264Decoder::decode failed status = %d(Bad data)\u0026#34;, (int)decodeStatus); } else if(decodeStatus != noErr) { NSLog(@\u0026#34;H264Decoder::decode failed status = %d\u0026#34;, (int)decodeStatus); } // Create了就得Release CFRelease(sampleBuffer); CFRelease(blockBuffer); return; } //解码回调函数 static void decodeOutputDataCallback(void *decompressionOutputRefCon, void *sourceFrameRefCon, OSStatus status, VTDecodeInfoFlags infoFlags, CVImageBufferRef pixelBuffer, CMTime presentationTimeStamp, CMTime presentationDuration) { // retain再输出，外层去release；pixelBuffer就是解码后的数据 CVPixelBufferRetain(pixelBuffer); Nextvc *decoder = (__bridge Nextvc *)decompressionOutputRefCon; } CMSampleBufferRef转换成YUV数据、YUV数据类型的变换： /* 1. CMSampleBufferRef 中提取yuv数据(Byte) 2. 处理yuv数据 3. yuv数据 转CVPixelBufferRef ，继续进行编码 */ -(CVPixelBufferRef)processYUV422ToYUV420WithSampleBuffer:(CMSampleBufferRef)sampleBuffer { // 1. 从CMSampleBufferRef中提取yuv数据 // 获取yuv数据 // 通过CMSampleBufferGetImageBuffer方法，获得CVImageBufferRef。 // 这里面就包含了yuv420数据的指针 CVImageBufferRef pixelBuffer_Before = CMSampleBufferGetImageBuffer(sampleBuffer); //表示开始操作数据 CVPixelBufferLockBaseAddress(pixelBuffer_Before, 0); //图像宽度（像素） size_t pixelWidth = CVPixelBufferGetWidth(pixelBuffer_Before); //图像高度（像素） size_t pixelHeight = CVPixelBufferGetHeight(pixelBuffer_Before); //yuv中的y所占字节数 size_t y_size = pixelWidth * pixelHeight; // 2. yuv中的u和v分别所占的字节数 size_t uv_size = y_size / 4; uint8_t *yuv_frame = malloc(uv_size * 2 + y_size); //获取CVImageBufferRef中的y数据 uint8_t *y_frame = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer_Before, 0); memcpy(yuv_frame, y_frame, y_size); //获取CMVImageBufferRef中的uv数据 uint8_t *uv_frame = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer_Before, 1); memcpy(yuv_frame + y_size, uv_frame, uv_size * 2); CVPixelBufferUnlockBaseAddress(pixelBuffer_Before, 0); NSData *yuvData = [NSData dataWithBytesNoCopy:yuv_frame length:y_size + uv_size * 2]; // 3. yuv 变成 转CVPixelBufferRef //现在要把NV12数据放入 CVPixelBufferRef中，因为 硬编码主要调用VTCompressionSessionEncodeFrame函数，此函数不接受yuv数据，但是接受CVPixelBufferRef类型。 CVPixelBufferRef pixelBuf_After = NULL; //初始化pixelBuf，数据类型是kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange，此类型数据格式同NV12格式相同。 CVPixelBufferCreate(NULL, pixelWidth, pixelHeight, kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange, NULL, \u0026amp;pixelBuf_After); // Lock address，锁定数据，应该是多线程防止重入操作。 if(CVPixelBufferLockBaseAddress(pixelBuf_After, 0) != kCVReturnSuccess){ NSLog(@\u0026#34;encode video lock base address failed\u0026#34;); return NULL; } //将yuv数据填充到CVPixelBufferRef中 uint8_t *yuv_frame_2 = (uint8_t *)yuvData.bytes; //处理y frame uint8_t *y_frame_2 = CVPixelBufferGetBaseAddressOfPlane(pixelBuf_After, 0); memcpy(y_frame_2, yuv_frame_2, y_size); uint8_t *uv_frame_2 = CVPixelBufferGetBaseAddressOfPlane(pixelBuf_After, 1); memcpy(uv_frame_2, yuv_frame_2 + y_size, uv_size * 2); CVPixelBufferUnlockBaseAddress(pixelBuf_After, 0); return pixelBuf_After; } 软硬编码对比：\n软编码：实现直接、简单，参数调整方便，升级易，但 CPU 负载重，性能较硬编码低，低码率下质量通常比硬编码要好一点。 硬编码：性能高，低码率下通常质量低于软编码器，但部分产品在 GPU 硬件平台移植了优秀的软编码算法（如 X264）的，质量基本等同于软编码。 苹果在 iOS 8.0 系统之前，没有开放系统的硬件编码解码功能，不过 Mac OS 系统一直有，被称为 Video ToolBox 的框架来处理硬件的编码和解码，终于在 iOS 8.0 后，苹果将该框架引入 iOS 系统。\n.H265 优点\n压缩比高，在相同图片质量情况下，比 JPEG 高两倍 能增加如图片的深度信息，透明通道等辅助图片。 支持存放多张图片，类似相册和集合。(实现多重曝光的效果) 支持多张图片实现 GIF 和 livePhoto 的动画效果。 无类似 JPEG 的最大像素限制 支持透明像素 分块加载机制 支持缩略图 在 iOS 平台上做视频的解码，一般有三种方案：\n软解码方案：ffmpeg\n缺点：消耗 CPU 太大 硬解码方案 1：采用私有接口 VideoToolBox\n优点：CPU 消耗极低，解码效率极高\n缺点：要使用私有接口 VideoToolBox 硬解码方案 2：采用 AVPlayer＋httpserver＋HttpLiveStream 的组合方案\n优点：CPU 消耗极低，解码效率极高\n缺点：视频有延迟，不适合实时视频通讯 ","date":"2020-03-09T00:00:00Z","permalink":"https://example.com/post/media/01_ios-%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81/","title":"iOS 音视频编解码"},{"content":"目录\n一、冒泡排序：\n二、插入排序：\n三、选择排序：\n四、希尔排序：\n五、堆排序：\n六、快速排序：\n6.1挖坑法：\n6.2左右指针法\n6.3前后指针法：\n七、归并排序：\n八、桶排序：\n九、计数排序：\n9.1绝对映射：\n9.2现对映射：\n十、基数排序： 一、冒泡排序： **1、思路：**通过对待排序序列从前向后（从下标较小的元素开始）,依次对相邻两个元素的值进行两两比较，若发现前一个数大于后一个数则交换，使值较大的元素逐渐从前移向后部，就如果水底下的气泡一样逐渐向上冒。\n2、先以一个数组讲解一下，然后再写代码：\n待排序数组：3，9，-1，10，20\n第一轮排序：\n（1）3，9，-1，10，20 \u0026mdash;-3跟9比较，不交换\n（2）3，-1，9，10，20 \u0026mdash;-9比 -1大，所以9跟 -1交换\n（3）3，-1，9，10，20 \u0026mdash;-9跟10比较，不交换\n（4）3，-1，9，10，20 \u0026mdash;-10跟20比较，不交换\n第一轮过后，将20这个最大的元素固定到了最后的位置。\n在第二轮的时候20不参与冒泡。\n第二轮排序：\n因为20的位置已经固定，所以只对前4个进行排序即可：\n（1）-1，3，9，10，20 \u0026mdash;-3比 -1大，进行交换\n（2）-1，3，9，10，20 \u0026mdash;-3跟9比较，不交换\n（3）-1，3，9，10，20 \u0026mdash;-9跟10比较，不交换\n第二轮过后，将第二大的元素固定到了倒数第二个位置\n第三轮排序：\n10和20的位置已经确定，只需对前三个进行排序\n（1）-1，3，9，10，20 \u0026mdash;-3和-1比较，不交换\n（2）-1，3，9，10，20 \u0026mdash;-3和9比较，不交换\n第三轮过后，将第三大的元素位置确定\n第四轮排序：\n只对前两个元素进行排序\n（1）-1，3，9，10，20 \u0026mdash;-3和-1比较，不交换\n第四轮过后，将第四大的元素位置确定，此时总共5个元素，已经排序好4个，从而最后一个自然而然就是排好序的了\n小结：\n设总的元素个数为n，那么由上边的排序过程可以看出：\n（1）总计需要进行（n-1）轮排序，也就是（n-1）次大循环\n（2）每轮排序比较的次数逐轮减少\n（3）如果发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序\n（4）时间复杂度是O(N^2) 在有序的时候，很快，因为有exchange变量优化了代码\n在乱序的时候很慢很慢。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;stdio.h\u0026gt; void swap(int* a, int* b){ int tmp = *a; *a = *b; *b = tmp; } //冒泡排序 void BubbleSort(int* a, int n) { int end = n - 1;//不能是n，不然会越界 while(end) { int exchange = 0;//优化，比较之后没有交换，说明已经排好了，就break循环 for (int i = 0; i \u0026lt; end; i++) { if (a[i] \u0026lt; a[i + 1]) { swap(\u0026amp;a[i], \u0026amp;a[i + 1]); exchange++; } } if (exchange == 0) break; end--; } } 二、插入排序： 1、思路：\n在待排序的元素中，假设前n-1个元素已有序，现将第n个元素插入到前面已经排好的序列中，使得前n个元素有序。按照此法对所有元素进行插入，直到整个序列有序。\n但我们并不能确定待排元素中究竟哪一部分是有序的，所以我们一开始只能认为第一个元素是有序的，依次将其后面的元素插入到这个有序序列中来，直到整个序列有序为止。\n2、举例：\n如下图的插入扑克牌，当摸到7的时候，会不自觉的与前面的数比较，如果比7大，把大的数向后挪动（swap），然后在第一个小于7的后面插入7\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //插入排序 void InsertSort(int* a, int n) { for (int i = 1; i \u0026lt; n; i++) { if (a[i] \u0026lt; a[i - 1])//先判断，如果i下标的值大于前面的数，就不进入 { int tmp = a[i]; int j; for (j = i - 1; j \u0026gt;= 0 \u0026amp;\u0026amp; a[j] \u0026gt;tmp; j--) { a[j+1] = a[j]; } a[j+1] = tmp; } } } //两次循环就可以实现 //内部循环完成一趟的插入 //外层循环完成插入排序 三、选择排序： 思路：\n1.内层循环一趟找出最小值的下标，与第一个数交换。重复找小，交换的两个操作。\n2.实际上，我们可以一趟选出两个值，一个最大值一个最小值，然后将其放在序列开头和末尾，这样可以使选择排序的效率快一倍。\n但时间复杂度还是O（N^2），效率还是不高\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //选择排序 void SelectSort(int* a, int n) { for (int i = 0; i \u0026lt; n-1; i++)//i\u0026lt;n-1当它是最后一个数的时候不需要进行交换排序 { int min = i; int j; for (j = i; j \u0026lt; n; j++) { if (a[j] \u0026lt; a[min]) { min=j; } } swap(\u0026amp;a[i], \u0026amp;a[min]);//交换函数，前面的代码中有出现，我就不重复写了 } } 四、希尔排序： 思路：\n1.插入排序的优化版，有一个预排序的过程。让大的数快速的跳到后面，小的数快速的跳到前面。\n2.使待排序列接近有序，然后再对该序列进行一次插入排序。\n3.相当于把直接插入排序中的1换成gap而已。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 //希尔排序 /*步骤： 1.先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再gap--，重复上述操作。 2.当gap==1时就是直接插入排序，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。*/ void ShellSort(int* a, int n) { //这里相当于把插入排序的1换成gap int gap = n; while (gap\u0026gt;1) { gap = gap / 3 + 1; for (int i = gap; i \u0026lt; n; i++) { if (a[i] \u0026lt; a[i - gap]) { int tmp = a[i]; int j; for (j = i - gap; j \u0026gt;= 0 \u0026amp;\u0026amp; a[j] \u0026gt; tmp; j-=gap)//这里是j-=gap { a[j + gap] = a[j]; } a[j + gap] = tmp; } } } } 五、堆排序： 先来认识堆：\n1.什么是堆？\n大堆：父亲大于儿子 小堆：父亲小于儿子（父亲，儿子是二叉树的概念）\n2.堆的物理结构和逻辑结构？\n物理结构：数组 逻辑结构：完全二叉树\n堆排序包括建堆（向下调整+循环） 堆排序（交换+向下调整）\n1.建堆：\n要建大堆，堆顶的元素和最后一个数交换，然后把size\u0026ndash;，就不会破坏堆的结构\n2.向下调整算法：\n比较两个孩子的大小，选出大的孩子，与父亲比较，如果孩子大于父亲，交换。然后把parent=child，child=parent*2+1；向下调整算法一共会调整h-1次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 //向下调整算法（要满足它下面的都满足堆，才能用） void AdjustDown(int* a, int n, int root) { int parent = root; int child = parent * 2 + 1; while (child \u0026lt; n) { if (child + 1 \u0026lt; n \u0026amp;\u0026amp; a[child] \u0026lt; a[child + 1]) child+=1;//把他移到右孩子那里 if (a[child] \u0026gt; a[parent]) { swap(\u0026amp;a[child], \u0026amp;a[parent]); parent = child; child = parent * 2 + 1; } else break; } } 堆排序 void HeapSort(int* arr, int n) { //建大堆 //从最后一个根开始，就相当于它下面的都满足堆，就可以用向下调整算法 for (int i = (n-1-1)/2; i \u0026gt;= 0; i--)//n-1-1是因为数组的最后一个元素下标是n-1 { AdjustDown(arr, n, i); } //排序 for (int i = n; i \u0026gt; 1; i--) { swap(\u0026amp;arr[0],\u0026amp;arr[i - 1]); AdjustDown(arr, i-1, 0); } } 六、快速排序： 三种快排方法：（一定要自己尝试着去写，会有一些坑，自己写才可以体会）\n1.挖坑法\n2.左右指针法\n3.前后指针法\n6.1挖坑法： 1.思想：\n记第一个数为key，要调整key的位置，使得左边的都要比key的小，右边的数都比key的大。\n2.步骤：\n选出一个数据（一般是最左边或是最右边的）存放在key变量中，在该数据位置形成一个坑\n还是定义一个left和一个right，left从左向右走（当遇到大于key的值时停下来）。right从右向左走（当遇到小于key的值时停下来）。（若在最左边挖坑，则需要right先走；若在最右边挖坑，则需要left先走） 把right的那个小的数放在坑中，在把left那个位置的值放在right那个位置中\n重复操作，直到left\u0026gt;right时结束，完成一趟，把key放在了正确的位置\n最后用分治思想，分成左边和右边，递归。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 //1.挖坑法的快速排序 void QuickSort(int* a,int left,int right) { if (left \u0026gt;= right)//不能写成pivot==left，pivot-1与left不匹配，会报错 { return; } int begin = left,end = right; int key = a[begin];//挖了一个关键字 int pivot = begin;//挖了一个坑 while (begin \u0026lt; end) { //右边找小，一定要先右边找小,放在pivot while (begin \u0026lt; end\u0026amp;\u0026amp;a[end] \u0026gt;= key)//在这里也要判断begin \u0026lt; end,因为这里面end-- { end--; } //小的放在左边的坑里，然后形成新的坑位 a[pivot] = a[end]; pivot = end; //左边找大 while (begin \u0026lt; end \u0026amp;\u0026amp; a[begin] \u0026lt;= key) { begin++; } a[pivot] = a[begin]; pivot = begin; } //begin==end a[pivot] = key; //[left,right] //[left,pivot-1] pivot [pivot+1,right] //如果左子区间和右子区间都有序，就全部有序。那就分治递归。 QuickSort(a, left, pivot - 1); QuickSort(a, pivot+1, right); } 6.2左右指针法 思路：\n1、选出一个key，一般是最左边或是最右边的。\n2、定义一个begin和一个end，begin从左向右走，end从右向左走。（需要注意的是：若选择最左边的数据作为key，则需要end先走；若选择最右边的数据作为key，则需要bengin先走）（考虑到最后的时候相遇点的和key交换）。\n3、在走的过程中，若end遇到小于key的数，则停下，begin开始走，直到begin遇到一个大于key的数时，将begin和right的内容交换，end再次开始走，如此进行下去，直到begin和end最终相遇，此时将相遇点的内容与key交换即可。（选取最左边的值作为key）\n4.此时key的左边都是小于key的数，key的右边都是大于key的数\n5.将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去，直到左右序列只有一个数据，或是左右序列不存在时\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 void QuickSort(int* a, int left, int right) { if (left \u0026gt;= right) { return; } int begin = left, end = right; int key = begin;//这里与挖坑法不同的地方，因为要交换key的那个数组中那个位置的数，而不是值 while (begin \u0026lt; end) { while (begin \u0026lt; end \u0026amp;\u0026amp; a[end] \u0026gt;= a[key]) { end--; } while (begin \u0026lt; end \u0026amp;\u0026amp; a[begin] \u0026lt;= a[key]) { begin++; } Swap(\u0026amp;a[begin], \u0026amp;a[end]); } Swap(\u0026amp;a[begin], \u0026amp;a[key]); QuickSort(a, left, begin - 1); QuickSort(a, begin + 1, right); } 6.3前后指针法： 思路：\n1、选出一个key，一般是最左边。\n2、起始时，prev指针指向序列开头，cur指针指向prev+1。\n3、让cur一直向前走，当遇到小于a[key]时，让prev向前走一格（这个值一定大于a[key]，因为是cur走过的），然后a[cur]和a[prev]交换。\n经过一次单趟排序，最终也能使得key左边的数据全部都小于key，key右边的数据全部都大于key。\n然后也还是将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去\n用if(left\u0026gt;right)\n{\nreurn;\n}//跳出递归\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 void QuickSort(int* a, int left,int right) { if (left \u0026gt;= right) { return; } int index=GetMidIndex(a,left, right); swap(\u0026amp;a[left], \u0026amp;a[index]); int key = left; int prev = left; int cur = left+1; while (cur \u0026lt;= right) { if (a[cur] \u0026lt; a[key]) { prev++; swap(\u0026amp;a[cur], \u0026amp;a[prev]); } /*可以简写成cur++， 但是当时一定要注意不要放在if语句的前面，因为if语句里面有让cur与prev交换的，cur==right跳出循环，但是a[cur]超过数组的范围，会越界范围。 while (cur\u0026lt;=right\u0026amp;\u0026amp;a[cur] \u0026gt;= a[key]) { cur++; }*/ cur++; } swap(\u0026amp;a[prev], \u0026amp;a[key]); QuickSort(a, left, prev - 1); QuickSort(a, prev+1,right); } 6.4优化快排 三数取中法：取左端、中间、右端三个数，然后进行比较，将中值数当做key\n否则有序时时间复杂度为O(N^2)\n三数取中法可以套入三种方法中，这里我就写一种\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 //三数取中 int GetMidIndex(int* a, int left, int right) { int mid = (left + right) / 2; if (a[mid] \u0026gt;= a[left]) { if (a[mid] \u0026lt;= a[right]) { return mid; } else { if (a[right] \u0026gt;= a[left]) { return right; } else { return left; } } } else//a[left]\u0026gt;a[mid] { if (a[right] \u0026gt;= a[left]) { return left; } else { if (a[right] \u0026gt;= a[mid]) { return right; } else { return mid; } } } } //交换 void swap(int* a, int* b) { int tmp = *a; *a = *b; *b = tmp; } //前后指针法 void QuickSort(int* a, int left,int right) { if (left \u0026gt;= right) { return; } int index=GetMidIndex(a,left, right); swap(\u0026amp;a[left], \u0026amp;a[index]); int key = left; int prev = left; int cur = left+1; while (cur \u0026lt;= right) { if (a[cur] \u0026lt; a[key]) { prev++; swap(\u0026amp;a[cur], \u0026amp;a[prev]); } cur++; } swap(\u0026amp;a[prev], \u0026amp;a[key]); QuickSort(a, left, prev - 1); QuickSort(a, prev+1,right); } 七、归并排序： 思路：\n1.不断的分割数据，让数据的每一段都有序（一个数据相当于有序）\n2.当所有子序列有序的时候，在把子序列归并，形成更大的子序列，最终整个数组有序。\n！！！需要开一个_MergeSort,而不是直接在MergeSort中直接递归，是因为MergeSort中有一个malloc\n归并排序很像二叉树中的后序思想，先递归，递归到最后的时候再合并。！！！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 //归并排序 void _MergeSort(int* a, int left, int right, int* tmp)//在这个函数中调用递归{ if (left \u0026gt;= right) { return; } int mid = (left + right) \u0026gt;\u0026gt; 1; _MergeSort(a, left, mid, tmp); _MergeSort(a, mid+1, right, tmp); //合并 int begin1 = left, end1 = mid; int begin2 = mid + 1, end2 = right; int i = left; while (begin1 \u0026lt;= end1 \u0026amp;\u0026amp; begin2 \u0026lt;= end2) { if (a[begin1] \u0026lt;= a[begin2]) { tmp[i++] = a[begin1++]; } else { tmp[i++] = a[begin2++]; } } while (begin1 \u0026lt;= end1) { tmp[i++] = a[begin1++]; } while (begin2 \u0026lt;= end2) { tmp[i++] = a[begin2++]; } for (int j = left; j \u0026lt;= right; j++) { a[j] = tmp[j]; } } void MergeSort(int* a, int n) { int* tmp = (int*)malloc(sizeof(int) * n); _MergeSort(a, 0, n - 1, tmp); free(tmp); } 八、桶排序： **思路：**大问题化小\n桶排序 (Bucket sort)或所谓的箱排序，是一种分块的排序算法，工作的原理是将数组分到有限数量的桶里，每个桶的大小都相等。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）\n把待排序序列（数组）中的数据根据函数映射方法分配到若干个桶中，在分别对各个桶进行排序，最后依次按顺序取出桶中的数据。\n适用于数据分配均匀，数据比较大，相对集中的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 //桶排序 void bucket_sort(int a[],int size,int bucket_size) { int i,j; //数组，数组长度，桶的大小 //定义动态的指针数组 KeyNode **bucket_num = (KeyNode **)malloc(bucket_size * sizeof(KeyNode*)); for(i = 0;i \u0026lt; bucket_size;i++) { bucket_num[i] = (KeyNode*)malloc(sizeof(KeyNode));//为每个链表定义头结点 bucket_num[i]-\u0026gt;num = 0; bucket_num[i]-\u0026gt;next = NULL; //指针变量初始化为空 } for(j = 0;j \u0026lt; size;j++) //准备插入 { KeyNode *node = (KeyNode *)malloc(sizeof(KeyNode));//定义一个节点 node-\u0026gt;num = a[j]; //数据域存数据 node-\u0026gt;next = NULL; //指向空 int index = a[j]/100; //映射函数 计算桶号 KeyNode *p = bucket_num[index];//p指向链表的头 //链表结构的插入排序 while(p-\u0026gt;next != NULL \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;num \u0026lt;= node-\u0026gt;num) { p = p-\u0026gt;next; //1.链表为空，p-\u0026gt;next==NULL，进入不了循环 } //2.链表不为空，因为链表从无开始按顺序插入，数据为有序的， //可以找到 前一个节点 \u0026lt;= node \u0026lt;=后一个节点 //节点插入链表 node-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next = node; (bucket_num[index]-\u0026gt;num)++; //记录一下该链表中有几个有效节点 } //打印结果 KeyNode * k = NULL; //定义一个空的结构体指针用于储存输出结果 for(i = 0;i \u0026lt; bucket_size;i++) { //for(k = bucket_num[i]-\u0026gt;next;k!=NULL;k=k-\u0026gt;next)//通过最后一个指针指向空 k = bucket_num[i]-\u0026gt;next; for(int m=0;m\u0026lt;bucket_num[i]-\u0026gt;num;m++) //通过头指针记录节点数 { printf(\u0026#34;%d \u0026#34;,k-\u0026gt;num); k=k-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } 九、计数排序： 一种特殊的排序，唯一种没有比较的排序（指没有前后比较，还是有交换的）\n以数组的下标当做数值，有这个数的时候a[i]++;\n局限：适用于整数。数要求集中（否则空间的浪费大）\n9.1绝对映射： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 int index = 0; int *tmpArr = (int *)malloc(max*sizeof(int)); int *result = (int *)malloc(max*sizeof(int)); for(int k = 0;k\u0026lt;max;k++) { tmpArr[k] = 0; } for (int i = 0; i\u0026lt;count; i++) { tmpArr[arr[i]]++; } for (int j = 0; j\u0026lt;max; j++) { while (tmpArr[j]) { result[index++] = j; tmpArr[j]--; } } free(tmpArr); tmpArr = NULL; return result; } 9.2现对映射： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 void CountSort(int* a, int n) { int max = a[0], min = a[0]; for (int i = 0; i \u0026lt; n; i++) { if (a[i] \u0026gt; max) max = a[i]; if (a[i] \u0026lt; min) min = a[i]; } int range = max - min + 1; int* count = (int*)malloc(sizeof(int) * range); memset(count, 0, sizeof(int) * range); for (int i = 0; i \u0026lt; n; i++) { count[a[i] - min]++; } int i = 0; for (int j = 0; j \u0026lt; range; j++) { while (count[j]--) { a[i++] = j + min; } } free(count); } 十、基数排序： 原理：是将整数按位数切割成不同的数字，然后按每个位数分别比较。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 #include\u0026lt;math.h\u0026gt; testBS() { inta[] = {2, 343, 342, 1, 123, 43, 4343, 433, 687, 654, 3}; int *a_p = a; //计算数组长度 intsize = sizeof(a) / sizeof(int); //基数排序 bucketSort3(a_p, size); //打印排序后结果 inti; for(i = 0; i \u0026lt; size; i++) { printf(\u0026#34;%d\\n\u0026#34;, a[i]); } intt; scanf(\u0026#34;%d\u0026#34;, t); } //基数排序 voidbucketSort3(int *p, intn) { //获取数组中的最大数 intmaxNum = findMaxNum(p, n); //获取最大数的位数，次数也是再分配的次数。 intloopTimes = getLoopTimes(maxNum); inti; //对每一位进行桶分配 for(i = 1; i \u0026lt;= loopTimes; i++) { sort2(p, n, i); } } //获取数字的位数 intgetLoopTimes(intnum) { intcount = 1; inttemp = num / 10; while(temp != 0) { count++; temp = temp / 10; } returncount; } //查询数组中的最大数 intfindMaxNum(int *p, intn) { inti; intmax = 0; for(i = 0; i \u0026lt; n; i++) { if(*(p + i) \u0026gt; max) { max = *(p + i); } } returnmax; } //将数字分配到各自的桶中，然后按照桶的顺序输出排序结果 voidsort2(int *p, intn, intloop) { //建立一组桶此处的20是预设的根据实际数情况修改 intbuckets[10][20] = {}; //求桶的index的除数 //如798个位桶index=(798/1)%10=8 //十位桶index=(798/10)%10=9 //百位桶index=(798/100)%10=7 //tempNum为上式中的1、10、100 inttempNum = (int)pow(10, loop - 1); inti, j; for(i = 0; i \u0026lt; n; i++) { introw_index = (*(p + i) / tempNum) % 10; for(j = 0; j \u0026lt; 20; j++) { if(buckets[row_index][j] == NULL) { buckets[row_index][j] = *(p + i); break; } } } //将桶中的数，倒回到原有数组中 intk = 0; for(i = 0; i \u0026lt; 10; i++) { for(j = 0; j \u0026lt; 20; j++) { if(buckets[i][j] != NULL) { *(p + k) = buckets[i][j]; buckets[i][j] = NULL; k++; } } } } ","date":"2019-03-08T00:00:00Z","permalink":"https://example.com/post/algorithm/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","title":"十大排序算法【转载】"}]